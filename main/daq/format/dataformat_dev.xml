<!-- chapter libraries -->

<chapter id="chapter.ringformat-dev">
  <title>Data Format Support Software</title>
  <para> 
    In the user guide section on <link linkend="chapter.ringformat">data
      formats</link>, the format of all the ring items were explained in
    detail. These were described without any mention of how NSCLDAQ
    implements them in software. This section seeks to provide an overview
    of the existing support that is free for use by experimenters. 
  </para>
  <para>
    This chapter is divided into these sections:
    <itemizedlist>
      <listitem>
        <para>
          A description of the C/C++ structure that represent the data
          format for I/O operations.
        </para>
      </listitem>
      <listitem>
        <para>
          A description of the class library that helps you build and
          decode items in the ring buffer in the format described in
          this chapter.
        </para>
      </listitem>
      <listitem>
        <para>
          A description of a simple library that allows you to
          create ring items that may not wind up being placed in a ring.
        </para>
      </listitem>
      <listitem>
        <para>
          A description of the mechanisms that are available to selectively
          get data from ring buffers.
        </para>
      </listitem>
    </itemizedlist>
  </para>

  <para>
    Reference material is provided in in the 3daq section that describes the
    class library.
  </para>

  <section>
    <title>The basic data formats</title>
     <para>
      The header <filename>DataFormat.h</filename> contains, among other
      things, the <literal>struct</literal> definitions that define
      the shapes of each item as they are passed around. These structs are given typenames via
      the <literal>typedef</literal> statement.  The remaining
      discussion will use these typenames, rather than the names of the
      underlying structs. The contents of each structure mirror the data as
      described in the user guide describing the data format. For that reason,
      the details of the implementation are provided here. 
    </para>
    <para>
      The general structure of a ring item is:
    </para>
    <programlisting>
#ifndef DISABLE_V11_COMPATIBILITY
#define s_mbz s_empty
#endif

typedef PSTRUCT _RingItem {
  RingItemHeader s_header;
  union {
    struct {
      uint32_t s_empty;
      uint8_t  s_body[1];
    } u_noBodyHeader;
    struct {
        BodyHeader s_bodyHeader;
        uint8_t s_body[];
    } u_hasBodyHeader;
  } s_body;
} RingItem, *pRingItem;
    </programlisting>
    <para>
      As you can see, the RingItem is composed of a RingItemHeader first,
      followed by a union of structs. The union handles the fact that there may or may not
      be a body header present. The body header is a new addition to the data
      format in NSCLDAQ 11.0 and will be explained in a bit more detail later.
      The case in which the body header is absent causes the body to have a
      uint32_t followed immediately by the body data. Alternatively, the body
      begins with at BodyHeader which is followed by the body data. This is
      common for all ring items. The s_body element refers to the remaining data
      that is lives in the body and that may or may not have a defined format.
      To representation the different body formats, there are different structs
      defined that are all variations of this theme. In the end, these are being
      treated as data entities without methods of their own.
    </para>
    <para>
      If the preprocessor symbol <literal>DISABLE_V11_COMPATIBILITY</literal>
      is not defined, then s_mbz can be used (as in version 11) for the s_empty
      field.  This is done, as shown via a preprocessor symbol, its use may cause
      problems if there are other structs with fields named <structfield>s_mbz</structfield>,
      therefore at compile time <literal>-DDISABLE_V11_COMPATIBILITY</literal>
      will turn off this definition.
    </para>
    <para>
      The header of each item type is of type <structname>RingItemHeader</structname>
      for convenience, the type <structname>pRingItemHeader</structname> is defined
      to be a pointer to a <structname>RingItemHeader</structname>.  This is a
      common pattern in the <filename>DataFormat.h</filename> header.
    </para>
    <para>
      The header has the following fields:
      <variablelist>
        <varlistentry>
          <term>uint32_t <structfield>s_size</structfield></term>
          <listitem>
            <para>Contains the size of the item in bytes.
              <structfield>s_size</structfield> should include the
              size of the header as well
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>uint32_t <structfield>s_type</structfield></term>
          <listitem>
            <para>
              Contains a value that uniquely defines the type of
              datain the item.  While this is a 32 bit field,
              the actual type values a 16 bits wide, with the
              remaining 16 bits set to zero.  This allows consumer
              software to detect byte order differences between
              systems that generate the data and consumer systems.
            </para>
            <para>
              The NSCL DAQ reserves types 1 through 32767
              for itself.  Type 0 is illegal, as it's byte order
              is indeterminate.  Types
              37678 through 65535 are available for user applications.
              The constant <varname>FIRST_USER_ITEM_CODE</varname>
              provides the symbolic value for the first item code
              available for user applications.
            </para>
            <para>
              The supported NSCLDAQ data item codes are defined in
              the <filename>DataFormat.h</filename> header. They
              are also defined i
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
    <para>
      The body header includes a timestamp, event source and barrier information
      either emitted by or intended for the event building pipeline.  This
      header is either a <type>uint32_t</type> containing sizeof(uint32_t), which indicates
      there is no header, or a structure of the following type: 
    </para>
    <programlisting>
typedef struct _BodyHeader {
  uint32_t   s_size;		/* 0 or sizeof(DataSourceHeader) */
  uint64_t   s_timestamp;
  uint32_t   s_sourceId;
  uint32_t   s_barrier;   
} BodyHeader, *pBodyHeader;
    </programlisting>
    <para>
      The fields of this structure are as follows:
    </para>
    <variablelist>
      <varlistentry>
        <term><varname>s_size</varname></term>
        <listitem>
          <para>
            The size of the header.  This value includes the
            <varname>s_size</varname> field.  Thus you can also
            think of items that don't have a body header
            as having a header size of sizeof(uint32_t); The size of the s_size
            elementWe promise to maintain
            backwards compatility by adding any new elements to the
            end of the body header.  Thus you can use
            <varname>s_size</varname> to determine where the
            body header ends and the structure fields will not
            move from version to version.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><varname>s_timestamp</varname></term>
        <listitem>
          <para>
            The value of the event/globally synchronized
            timestamp at the time this ring item was initially
            formed.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><varname>s_sourceId</varname></term>
        <listitem>
          <para>
            Unique identifier of the source of this ring item.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><varname>s_barrier</varname></term>
        <listitem>
          <para>
            If the item was part of a barrier synchronization amongst
            the data sources, this field will be non-zero and
            represent the type of the barrier.  If zero, this
            item was not part of a barrier.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>


    <para>
      To generate the various ring items, the <filename>DataFormat.h</filename>
      provides a series of functions.
      <!-- added in 11.0 -->
      <funcsynopsis>
        <funcprototype><funcdef><type>pScalerItem</type>
            <function>formatNonIncrTSScalerItem</function></funcdef>
          <paramdef>
            <parameter><type>unsigned</type> scalerCount</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>time_t</type> timestamp</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> btime</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type>  etime</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint64_t</type> eventTimestamp</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>void*</type> pCounters</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> timebaseDivisor</parameter>
          </paramdef>
        </funcprototype>
      </funcsynopsis>
      <funcsynopsis>
        <funcprototype>
          <funcdef><type>pDataFormat</type><function>formatDataFormat</function>
          </funcdef>
          <void />
        </funcprototype>
      </funcsynopsis>
      <funcsynopsis>
        <funcprototype>
          <funcdef><type>pGlomParameters</type>
            <function>formatGlomParameters</function>
          </funcdef>
          <paramdef>
            <parameter><type>uint64_t</type> coincidenceWindow</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>int</type>isBuilding</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>int</type>timestampPolicy</parameter>
          </paramdef>
        </funcprototype>
      </funcsynopsis>
      <funcsynopsis>
        <funcprototype>
          <funcdef><type>pEventBuilderFragment</type>
            <function>formatEVBFragment</function>
          </funcdef>
          <paramdef>
            <parameter><type>uint64_t</type> timestamp</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> sourceId</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> barrier</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> payloadSize</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>const void*</type>
              pPayload</parameter>
          </paramdef>
        </funcprototype>
      </funcsynopsis>
      <funcsynopsis>
        <funcprototype>
          <funcdef><type>pEventBuilderFragment</type>
            <function>formatEVBFragmentUnknown</function>
          </funcdef>
          <paramdef>
            <parameter><type>uint64_t timestamp</type></parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> sourceId</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> barrier</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> payloadSize</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>const void*</type> pPayload</parameter>
          </paramdef>
        </funcprototype>
      </funcsynopsis>
      <funcsynopsis>
        <funcprototype>
          <funcdef>
            <type>pPhysicsEventItem</type>
            <function>formatTimestampedEventItem</function>
          </funcdef>
          <paramdef>
            <parameter><type>uint64_t</type> timestamp</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> sourceId</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> barrier</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> payloadSize</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>const void*</type> pPayload</parameter>
          </paramdef>
        </funcprototype>
      </funcsynopsis>
      <funcsynopsis>
        <funcprototype>
          <funcdef>
            <type>pPhysicsEventCountItem</type>
            <function>formatTimestampedTriggerCountItem</function>
          </funcdef>
          <paramdef>
            <parameter><type>uint64_t</type> timestamp</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> sourceId</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> barrier</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> runTime</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> offsetDivisor</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>time_t</type> stamp</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint64_t</type> triggerCount</parameter>
          </paramdef>
        </funcprototype>
      </funcsynopsis>
      <funcsynopsis>
        <funcprototype>
          <funcdef>
            <type>pScalerItem</type>
            <function>formatTimestampedScalerItem</function>
          </funcdef>
          <paramdef>
            <parameter><type>uint64_t</type>timestamp</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> sourceId</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> barrier</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>int</type> isIncremental</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> timeIntervalDivisor</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> timeofday</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> btime</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> etime</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> nScalers</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>void*</type> pCounters</parameter>
          </paramdef>
        </funcprototype>
      </funcsynopsis>
      <funcsynopsis>
        <funcprototype>
          <funcdef>
            <type>pTextItem</type>
            <function>formatTimestampedTextItem</function>
          </funcdef>
          <paramdef>
            <parameter><type>uint64_t</type> timestamp</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> sourceId</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> barrier</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>unsigned</type> nStrings</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>time_t</type> stamp</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> runTime</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>const char**</type>pStrings</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>int</type> type</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> timeIntervalDivisor</parameter>
          </paramdef>
        </funcprototype>
      </funcsynopsis> 
      <funcsynopsis>
        <funcprototype>
          <funcdef>
            <type>pStateChangeItem</type>
            <function>formatTimestampedStateChange</function>
          </funcdef>
          <paramdef>
            <parameter><type>uint64_t</type> timestamp</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> sourceId</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> barrier</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>time_t</type> stamp</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> offset</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> runNumber</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>uint32_t</type> offsetDivisor</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>const char*</type> pTitle</parameter>
          </paramdef>
          <paramdef>
            <parameter><type>int</type> type</parameter>
          </paramdef>
        </funcprototype>
      </funcsynopsis>
      <funcsynopsis>
        <funcprototype>
          <funcdef>
            <type>void*</type> <function>bodyPointer</function>
          </funcdef>
          <paramdef>
            <parameter><type>pRingItem</type> pItem</parameter>
          </paramdef>
        </funcprototype>
      </funcsynopsis>

      <!-- end of 11.0 additions -->

    </para>
    <para>
      These item types break down in to four distinct categories of
      item which will be described in the remaining subsections of this
      section.
    </para>
    <section>
      <title>State Change Items</title>
      <para>
        State change items are those with types
        <varname>BEGIN_RUN</varname>, <varname>END_RUN</varname>,
        <varname>PAUSE_RUN</varname>, and <varname>RESUME_RUN</varname>.
        As the type names imply, these signal state transitions in
        data taking. 
      </para>
      <para>
        State change items have the type
        <structname>StateChangeItem</structname>.  This item has the
        following fields:
      </para>
      <variablelist>
        <varlistentry>
          <term>uint32_t <structfield>s_runNumber</structfield></term>
          <listitem>
            <para>
              Is the number of the run for which this state transition
              is being documented.  Typically, run numbers are
              unique, for recorded runs, as the run number is encoded
              into the name of the run's event file.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>uint32_t <structfield>s_timeOffset</structfield></term>
          <listitem>
            <para>
              Is the number of seconds the run has been active prior
              to this state transition.  Clearly if the type of the
              item is <varname>BEGIN_RUN</varname> this will be zero.
              For the NSCLDAQ frameworks, the time offset only
              counts seconds during which the run was active (time
              during which the run was paused are not counted).
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>uint32_t <structfield>s_Timestamp</structfield></term>
          <listitem>
            <para>
              Is the absolute time at which the transition
              occured. This is represented in seconds since
              the Unix epoch of
              <literal>00:00:00 UTC, January 1, 1970</literal>.
              Once translated into the host's byte order, it can
              be passed to any of the time formatting functions
              (e.g. <function>asctime</function>).
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>char <structfield>s_title</structfield>[TITLE_MAXSIZE+1]</term>
          <listitem>
            <para>
              Holds the run title.  Run titles are restricted in
              size to <varname>TITLE_MAXSIZE</varname> characters,
              with the <literal>+1</literal> to accomodate the
              trailing <literal>'\0'</literal>.
              <varname>TITLE_MAXSIZE</varname>
              is also defined in
              <filename>DataFormat.h</filename>.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        All item types have a field
        <structfield>s_header</structfield> of type
        RingItemHeader that holds the item header.
      </para>
    </section>
    <section>
      <title>Text List Items</title>
      <para>
        Text list items contain a list of null terminated strings.
        They are usually used to provide metadata for the run.  At present,
        two types of text list items are defined.
        <varname>PACKET_TYPES</varname> and
        <varname>MONITORED_VARIABLES</varname>.
      </para>
      <para>
        <varname>PACKET_TYPES</varname> document the packets you might
        expect to find in a run's <varname>PHYSICS_EVENT</varname> items.
        Creating instances of the
        <classname>CDocumentedPacket</classname> object
        automatically generates these.  Each packet is documented with a
        single string.  The string consists of five colon separated fields.
        These fields contain, in order:
        <orderedlist>
          <listitem>
            <para>The Name the packet.</para>
          </listitem>
          <listitem>
            <para>The id of the packet given as a hex string e.g.
              "0x1234"
            </para>
          </listitem>
          <listitem>
            <para>A desription of the packet.</para>
          </listitem>
          <listitem>
            <para>A version string for the packet.  Presumably this
              will change if the packet with this type ever
              changes 'shape'>
            </para>
          </listitem>
          <listitem>
            <para>The date and time at which the
              <classname>CDocumentedPacket</classname> object
              creating this entry was created.
            </para>
          </listitem>
        </orderedlist>
      </para>
      <para>
        <varname>MONITORED_VARIABLES</varname> items contains a snapshot
        of the values of process variables that have been declared
        by the readout software.   Each variable takes up one string and is
        formatted like a Tcl <command>set</command> command that, if executed,
        would define that variable to the value it had when the item was created.
      </para>
      <para>
        String list items have type <structname>TextItem</structname>.
        This item has the following fields:
      </para>
      <variablelist>
        <varlistentry>
          <term>uint32_t <structfield>s_timeOffset</structfield></term>
          <listitem>
            <para>
              The number of seconds of data taking that have gone on
              in this run prior to the generation of this item.
              This time offset does not count time in the paused
              state.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>uint32_t<structfield>s_timestamp</structfield></term>
          <listitem>
            <para>
              Is the absolute time at which the item was 
              created. This is represented in seconds since
              the Unix epoch of
              <literal>00:00:00 UTC, January 1, 1970</literal>.
              Once translated into the host's byte order, it can
              be passed to any of the time formatting functions
              (e.g. <function>asctime</function>).
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>uint32_t <structfield>s_stringCount</structfield></term>
          <listitem>
            <para>
              Number of strings in the item.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>char <structfield>s_strings[]</structfield></term>
          <listitem>
            <para>
              An array of characters large enough to hold all
              the strings.  Each string is a null terminated set
              of characters immediately followed by the next
              string.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section>
      <title>Scaler Items</title>
      <para>
        NSCLDAQ readout frameworks support periodically reading scaler
        data.  These data are represented as
        <structname>ScalerItem</structname> items in ring buffers.
        These items have the following fields:
      </para>
      <variablelist>
        <varlistentry>
          <term>uint32_t <structfield>s_intervalStartTime</structfield></term>
          <listitem>
            <para>
              The number of seconds of active data taking prior
              the start of the time period represented by the counts
              in this scaler item.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>uint32_t <structfield>s_intervalEndTime</structfield></term>
          <listitem>
            <para>
              The number of seconds of active data taking prior to
              the end of the time period represented by the counts
              in this scaler item.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>uint32_t  <structfield>s_timestamp</structfield></term>
          <listitem>
            <para>
              Is the absolute time of the end of the
              scaler counting period.
              This is represented in seconds since
              the Unix epoch of
              <literal>00:00:00 UTC, January 1, 1970</literal>.
              Once translated into the host's byte order, it can
              be passed to any of the time formatting functions
              (e.g. <function>asctime</function>).
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>uint32_t <structfield>s_scalerCount</structfield></term>
          <listitem>
            <para>
              The number of scalers in the item.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>uint32_t <structfield>s_scalers</structfield>[]</term>
          <listitem>
            <para>
              The array of scaler counts.  This contains
              <structfield>s_scalerCount</structfield> elements.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section>
      <title>Event Data Items</title>
      <para>
        These items are of type
        <varname>PHYSICS_EVENT</varname>.
        The contain the data read from the hardware.  Depending on the
        readout framework, this can be the response to one trigger or to
        a block of triggers. It is up to the analysis software to know
        which is which.
      </para>
      <para>
        This item is of type <structname>PhysicsEventItem</structname>
        and contains the field
        uint16_t <structfield>s_body</structfield> that is the data
        from the event.
      </para>

    </section>
    <section>
      <title>Event count items</title>
      <para>
        These items are of type <structname>PhysicsEventCountItem</structname>.
        <type>uint32_t</type> <structfield>s_timeOffset</structfield> is
        the number of seconds into the active run the event occured.
        <type>uint32_t</type> <structfield>s_timesamp</structfield>
        is the absolute timestamp indicating when this item was created.
        <type>uint64_t</type> <structfield>s_eventCount</structfield> is
        the total number of events that have been contributed to this
        ring for this run.
      </para>
    </section>

  </section>

  <section>
    <title>Selecting Data From a Ring Buffer</title>
    <para>
      Many data consumers are not interested in all of the
      item types that could be put in a ring buffer.   This section
      describes the infrastructure for selecting subsets of the data
      from ring buffers that are formatted as described in this chapter.
    </para>
    <para>
      The ring buffer low level access library provides
      two powerful mechanisms for manipulating ring buffers based
      the concept of <firstterm>predicates</firstterm>.
      A predicate is a function that implement the
      <methodname>operator()</methodname> method in a way that it returns
      a <literal>bool</literal>.
      Predicate objects can therefore be thought of as functions that can
      have state that persists between calls.
    </para>
    <para>
      <classname>CRingBuffer</classname> has two member functions
      <methodname>blockWhile</methodname> which periodically
      invokes a predicate until it returns <literal>false</literal>
      blocking for a settable time period between calls, and for a
      maximum timeout.
      <methodname>While</methodname> which simply repeatedly calls
      a predicate until it returns <literal>false</literal>.
      (like <methodname>blockWhile</methodname> but without blocking
      between calls to the predicate.
    </para>
    <para>
      Armed with predicates, these two member functions an an understanding
      that items in the ring will have the item format described in the
      previous section, it is possible to implement a scheme for selectively
      obtaining data from a ring buffer.
    </para>
    <para>
      The base class for this selectivity is
      <classname>CRingSelectionPredicate</classname>
      defined in
      <filename>CRingSelectionPredicate.h</filename>.  It provides
      base classes with the capability of specifying a list of item types
      called a <firstterm>selection  map</firstterm>.  Elements of this
      map consist of an item type and a flag.  The virtual function
      <methodname>selectThis</methodname> is given an item type peeked from
      the ring buffer and returns <literal>false</literal> if the item
      is acceptable.  Unacceptable items are skipped, and true is returned
      so that <methodname>While</methodname> continues to loop.
    </para>
    <para>
      If <methodname>selectThis</methodname> returns true, the framework
      insepcts the type's flag.  If false, the predicate as a whole
      returns true. I false, the predicate skips the item if it is not
      the last one in the ring.
    </para>
    <para>
      Two pre-packaged specific derivations of
      <classname>CRingSelectionPredicate</classname> have been built.
      In
      <classname>CDesiredTypesPredicate</classname>, any type not in the
      list is assumed to be undesirable and skipped.   In
      <classname>CAllButPredicate</classname>, the list of types define
      exceptiosn to the rule that all items are desired without sampling.
      Items in the list with the sample flag false, are assumed to be
      undesirable and are skipped.  items in the list with the sample flag
      true, are assumed to be wanted but only in sample mode.
    </para>
  </section>
  <section>
    <title>Incorporating the headers and libraries into your applications.</title>
    <para>
      NSCL DAQ provides a class library that allows you to encapsulate
      ring buffer data items in objects from which you can get/set data.
      Ring buffer item objects are intended both for producers and consumers
      of data.  See the 3daq section of the reference material for
      detailed per class documentation.
    </para>
    <para>
      Each class has a header file that is named the same as the
      class with a <filename>.h</filename> appended. Thus to incorporate
      the definitions for the
      <classname>CRingItem</classname> base class in your source code you would
      add the line:
    </para>
    <example>
      <title>Including a ring item class </title>
      <programlisting>
#include &lt;CRingItem.h&gt;
            </programlisting>
        </example>
        <para>
            To your source files.
        </para>
        <para>
            At compile time you would need to add a <literal>-I</literal> switch
            to tell the compiler where these headers are.  If the
            environment variable
            <literal>DAQROOT</literal>
            points to the top level of the NSCLDAQ installation tree you might
            do this as shown below:
        </para>
        <example>
            <title>Telling the compiler where to find Ring Item headers</title>
            <screen><command>
g++ -c -I$DAQROOT/include mymodule.cpp
            </command></screen>
        </example>
        <para>
            At link time you need to provide the location of the libraries as
            well as to specify the set of libraries that must be included.
            Note that as the example below shows, normally using the
            data format library implies you will need the data flow library as well:
        </para>
        <example>
            <title>Linking the ring item format libraries</title>
            <screen><command>
g++ -o myApplication src1.o src2.o ... -L$DAQROOT/lib \
        -ldataformat -lDataFlow -Wl,"-rpath=$DAQROOT/lib"
            </command></screen>
        </example>
        <para id='cringbuffer_links'>
            The following classes manage data formatting:
        </para>
        <variablelist>
            <varlistentry>
                <term><link linkend="manpage.cringitem"><classname>CRingItem</classname></link></term>
                <listitem>
                    <para>
                        Base class for all the ring data item format classes.
                        This class also has the static member
                        <methodname>getFromRing</methodname> which accepts a
                        ring object reference and a
                        <classname>CRingSelectionPredicate</classname> reference,
                        and returns a pointer to the next ring item that matches
                        the predicate's match criteria.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend="manpage.cringstatechangeitem"><classname>CRingStateChangeItem</classname></link></term>
                <listitem>
                    <para>
                        Represents a state change item.  Given a reference to
                        a <classname>CRingItem</classname> (e.g. one just gotten
                        from <classname>CRingItem</classname>::<methodname>getFromRing</methodname>),
                        one of the constructors constructs an equivalent ring state change object or
                        throws a <classname>std::bad_cast</classname> exception
                        if the item is not a valid state change.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend="manpage.cringscaleritem"><classname>CRingScalerItem</classname></link></term>
                <listitem>
                    <para>
                        Represents a state change item.  Given a reference to a
                        <classname>CRingItem</classname> one of the constructors
                        can produce a <classname>CRingScalerItem</classname> object
                        or throw a <classname>std::bad_cast</classname> exception
                        if the item was not actually a scaler item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend="manpage.cringtextitem"><classname>CRingTextItem</classname></link></term>
                <listitem>
                    <para>
                        Encapsulates a text list item.  As with all the above
                        classes, a constructor exists that converts a
                        <classname>CRingItem</classname> to a
                        <classname>CRingTextItem</classname> or throws a
                        <classname>std::bad_cast</classname> if that's not legal.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='manpage.cglomparameters'>
                    <classname>CGlomParameters</classname></link></term>
                <listitem>
                    <para>
                        Encapsulates the glom parameter ring items.  This ring
                        item describes how the glom component of the event builder
                        pipeline has been started.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='manpage.cphysicseventitem'>
                    <classname>CPhysicsEventItem</classname></link></term>
                <listitem>
                    <para>
                        Encapsulates the data taken in response to a physics
                        trigger.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='manpage.cringfragmentitem'>
                    <classname>CRingFragmentItem</classname></link></term>
                <listitem>
                    <para>
                        Encapsulates items produced in the ordering phase of
                        the event builder pipeline.  Items of this type are
                        believed to have other ring items as their payloads.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='manpage.cringphysicseventcountitem'>
                    <classname>CRingPhysicsEventCountItem</classname></link></term>
                <listitem>
                    <para>
                        Encapsulates an item that gives information about the
                        number of triggers that have been processed by the system
                        (or by a single event source) during the run so far.
                        This both allows software to monitor trigger rates and
                        allows you to determine the percentage of data you are
                        sampling from an online ringbuffer in the event you are
                        sampling data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='manpage.cunknownfragment'>
                <classname>CUnknownFragment</classname></link></term>
                <listitem>
                    <para>
                        Encapsulates an event fragment produced by the event
                        builder ordering stage for which there's good reason to
                        believe the payload is not a ring item.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <section>
           <title>Generic ring data sources</title>
           <para>
              You may want a program to work equally well when pointed at a 
              ring buffer and when pointed at a file of ring items, such as
              an event file created by the event logger.
           </para>
           <para>
              A set of data source classes and a data source factory allow you
              to easily write program like this.  The key point is that 
              ring data sources are specified by uniform resource identifiers
              (URIs).  The first part of a URI is called the 'protocol' and
              defines how a connection takes place.  For online rings we have
              seen that the protocol is <literal>tcp:</literal>  For offline
              event files, the protocol is <literal>file:</literal>.
            </para>
            <para>
              The data format library provides a generic base class;
              <classname>CDataSource</classname>.   Concrete subclasses include
              <classname>CRingDataSource</classname> and
              <classname>CFileDataSource</classname> provide data sources for
              online rings and offline files respectively.  The factory class
              is <classname>CDataSourceFactory</classname>.
            </para>
            <para>
                The data sources return generic ring items.  These can be
                upcast into specific ring item types by using methods in the
                <classname>CRingItemFactory</classname> class.
            </para>
            <para>
                Reference information on these classes is availabe at:
                <xref linkend="daq3_cdatasource" endterm="daq3_cdatasource_title" />,
                <xref linkend="daq3_cringdatasource" endterm="daq3_cringdatasource_title"  />,
                <xref linkend="daq3_cfiledatasource" endterm="daq3_cfiledatasource_title"  />,
                <xref linkend="daq3_cdatasourcefactory" endterm="daq3_cdatasourcefactory_title"  />,
                and
                <xref linkend="daq3_cringitemfactory" endterm="daq3_cringitemfactory_title"  />.
            </para>
        </section>
    </section>
    <section>
        <title>Generic ring data sinks</title>
        <para>
            Data sinks are places to store data.  A program that stores data
            will also generally want to work regardless of whether or not it is
            storing data in a file or a ring buffer (of course ring buffer data
            sinks must be local to the host that is running the program).
        </para>
        <para>
            The data format library provides a hierarchy of classes to support
            this that are derived from the abstract base class
            <classname>CDataSink</classname>:
            <classname>CFileDataSink</classname> allows you to put ring items
            and arbitraty data into a file.  <classname>CRingDataSink</classname>
            similarly alows you to put data in a ringbuffer.
        </para>
        <para>
            The <classname>CDataSinkFactory</classname> class allows you to produce
            ring or file data sinks depening on the form of the URI that is passed
            to the factory creation method. 
        </para>
        <para>
            For reference information on the data sink classes see:
            <link linkend='daq3_cdatasink' endterm='daq3_cdatasink_title' />,
            <link linkend='daq3_cringdatasink' endterm='daq3_cringdatasink_title' />,
            <link linkend='daq3_cfiledatasink' endterm='daq3_cfiledatasink_title' />.
            For reference information on the factory class see:
            <link linkend='daq3_cdatasinkfactory' endterm='daq3_cdatasinkfactory_title' />
        </para>
    </section>
    <section>
        <title>Creating ring items</title>
        <para>
            There are some cases where the librarires provided to create
            ring items are not well suited for the job. Specifically, sometimes
            you'd like to create ring items to be emitted on <filename>stdout</filename>.
        </para>
        <para>
            A simple set of functions that can be called by either C or C++
            programs allows you to format ring items that can be dealt with
            however you might wish.
        </para>
        <para>
            The functions provided are prototyped in <filename>DataFormat.h</filename>.
            The functions are also part of <filename>libdataformat.so</filename>.
        </para>
        <para>
            The reference section provides full documentation.  All functions
            return a pointer to storage allocated with <function>malloc(3)</function>
            that contains the ring item.  It is the caller's responsibility
            to invoke <function>free(3)</function> to release this storage.
        </para>
        <para>
            The functions defined in <filename>DataFormat.h</filename> are implemented
            in C and the header is written to be usable from both C and C++
            programs.  The functions are divided into two  sets of functions.
            The first set are intended to be used for compatiblity with
            pre nscldaq 11.0 applications.  With the exception of
            <function>formatNonIncrTSScalerItem</function>, which was introduced
            in NSLCDAQ-10.1-100 to support S800 scaler items that provide event
            timestamps, the functions below provide a body header of length
            sizeof(uint32_t) (Body header that only consists of the s_size field.).
        </para>
        <variablelist>
            <varlistentry>
                <term><function>formatEventItem</function></term>
                <listitem>
                    <para>
                        Formats the data read from a physics trigger into a
                        ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTriggerCountItem</function></term>
                <listitem>
                    <para>
                        Formats a trigger count item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatScalerItem</function></term>
                <listitem>
                    <para>
                        Creates an incremental scaler ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTextItem</function></term>
                <listitem>
                    <para>
                        Formats a text string item.  Text string items are
                        items whose payload contains, among other things,
                        a set of null terminated strings.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatStateChange</function></term>
                <listitem>
                    <para>
                        Creates a state change ring item.  State change
                        ring items indicate that the run state has changed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatNonIncrTSScalerItem</function></term>
                <listitem>
                    <para>
                        This is a convenience function that produces a
                        scaler item that has an event timestamp and has
                        the incremental flag cleared.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The functions that are new since NSCLDAQ-11.0 and, produce fully
            filled out body headers are listed below:
        </para>
        <variablelist>
            <varlistentry>
                <term><function>formatDataFormat</function></term>
                <listitem>
                    <para>
                        Creates a data format item for the format described in
                        the version of <filename>libdataformat.so</filename> your
                        application is <emphasis>linked to</emphasis>.
                        Each ring producer should emit one of these as the first
                        item it produces after attaching to the ring so that
                        consumers know what data format to expect.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatGlomParameters</function></term>
                <listitem>
                    <para>
                        Produces a glom parameters ring itme.  This is normally
                        only called by the <application>glom</application> stage
                        of the event builder pipeline.  If, however you have
                        replaced that stage of the pipeline with something different,
                        you might want to emit this or some user specific item
                        to describe the conditions being used to glue event fragments
                        together into events.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatEVBFragment</function></term>
                <listitem>
                    <para>
                        Normally this is only emitted to event builder monitor
                        rings by <application>teering</application>.  Formats
                        an event builder fragment when you have a good idea the
                        fragment contains a ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatEVBFragmentUnknown</function></term>
                <listitem>
                    <para>
                        Same as <function>formatEVBFragment</function> but
                        used when there's a pretty good idea the fragment payload
                        is not a ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTimestampedEventItem</function></term>
                <listitem>
                    <para>
                        Creates an evet ring item that has a timestamp (full
                        body header).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTimestampedTriggerCountItem</function></term>
                <listitem>
                    <para>
                        Formas a physics event count item with a full body header.
                        In addition, the ring items allows you to provide an
                        <firstterm>offsetdivisor</firstterm> for the run offset
                        which  supports run times with sub-second resolution.
                        The concept of the run time divisor which
                        (as of NSCLDAQ-11.0) is present in all ring item types that
                        have run time offsets is that if you take the run time
                        offset, and divide it by the run time divisor (floating
                        point arithmetic), you get the offset into the run
                        in seconds.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTimestampedScalerItem</function></term>
                <listitem>
                    <para>
                        Formats a periodic scaler item that has a full body
                        header.  Again, this version allows you to set the
                        run time offset divisor to something other than 1.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTimestampedTextItem</function></term>
                <listitem>
                    <para>
                        Formats a text array item that has a full body header.
                        The full body headder no only allows the emitter to
                        specify a timestamp at which the item was created, but also
                        to specify which data source created the item.  If the
                        text item should not have a timestamp, you should either
                        fill in the most recent timestamp emitted by that source or,
                        if that's not convenient, the value
                        <literal>NULL_TIMESTAMP</literal> which is defined in
                        the header <filename>fragment.h</filename>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTimestampedStateChange</function></term>
                <listitem>
                    <para>
                        Formats a state change item that has a full body header and,
                        possible, value for the run time divisor other than 1.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>bodyPointer</function></term>
                <listitem>
                    <para>
                        Given a pointer to a ring item that comes from
                        NSCLDAQ-11.0 or later, returns a pointer to the
                        body payload of the item. The body payload is the
                        section of the ring item that is just after the
                        Body Header.  Note that this method can properly deal
                        with NSCLDAQ-11 or NSCLDAQ-12 data in the sense that
                        a body header size of zero or sizeof(uint32_t) is interpreted
                        to mean there's no body header.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
</chapter>

<!-- /chapter -->

<!-- manpage 3daq -->

    <refentry id='manpage.cringitem'>
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
            <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
      <refmeta>
         <refentrytitle>CRingItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>CRingItem</refname>
	 <refpurpose>Encapsulates an item in a ring buffer.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CRingItem.h&gt;
         </programlisting>
         <synopsis>
            <ooclass><classname>CRingITem</classname></ooclass>
            <constructorsynopsis>
                <methodname>CRingItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>maxBody</parameter>
                    <initializer>8192</initializer>
                </methodparam>
            </constructorsynopsis>
            
            <!-- new in 11.0 -->
            
            <constructorsynopsis>
                <methodname> CRingItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>uint64_t</type><parameter>timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>sourceId</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter> barrierType</parameter>
                    <initializer>0</initializer>
                </methodparam>
                <methodparam>
                    <type>size_t</type><parameter> maxBody</parameter>
                    <initializer>8192</initializer>
                </methodparam>
            </constructorsynopsis>
            <!-- end of 11.0 addition -->
            
            <constructorsynopsis>
                <methodname>CRingItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CRingItem</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CRingItem&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>getStorageSize</methodname>
                                    <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>getBodySize</methodname>
                                    <void /><modifier> const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void*</type> <methodname>getBodyPointer</methodname>
                                   <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void*</type> <methodname> getBodyCursor</methodname>
                                   <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>_RingItem*</type>
                <methodname>getItemPointer</methodname> <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>type</methodname>
                                        <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setBodyCursor</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pNewCursor</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>commitToRing</methodname>
                <methodparam>
                    <type>CRingBuffer&amp;</type> <parameter>ring</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type>
                <methodname>mustSwap</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>void </type>
                <methodname>updateSize</methodname>
                <void />
                <modifier></modifier>
            </methodsynopsis>
            <!-- New in 11.0 -->
            
            <methodsynopsis>
                <type>bool</type>
                <methodname> hasBodyHeader</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>uint64_t</type>
                <methodname> getEventTimestamp</methodname>
                <void />
                <exceptionname>std::string</exceptionname>
                <modifier>const</modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <type>uint32_t </type>
                <methodname>getSourceId</methodname>
                <void />
                <exceptionname>std::string</exceptionname>
                <modifier>const</modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <type>uint32_t </type>
                <methodname>getBarrierType</methodname>
                <void />
                <exceptionname>std::string</exceptionname>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>setBodyHeader</methodname>
                <methodparam>
                    <type>uint64_t</type><parameter>timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>sourceId</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>barrierType</parameter>
                    <initializer>0</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::string </type>
                <methodname>typeName() </methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>std::string </type>
                <methodname>toString() </methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>  
             
            
            <!-- End of methods new in 11.0 -->
           
            <methodsynopsis>
                <modifier>static</modifier>
                <type>CRingItem*</type>
                <methodname>getFromRing</methodname>
                <methodparam>
                    <type>CRingBuffer&amp;</type> <parameter>ring</parameter>
                </methodparam>
            
                <methodparam>
                    <type>CRingSelectionPredicate&amp;</type> <parameter>predicate</parameter>
                </methodparam>
            </methodsynopsis>

         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CRingItem</classname> is the base class of a hierarchy
            of classes that encapsulate the format of items put in ring buffers
            by the NSCL DAQ readout frameworks.  
         </para>
         <para>
            The class hierarchy as a whole is intended both to help application
            writers format item to be submitted to a ring buffer and to
            fetch and decode items from a ring buffer.  The fetch logic works
            closely with the set of classes derived from
            <classname>CRingSelectionPredicate</classname>
            to support selective reception of data inserted by a producer program.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
             <methodname>CRingItem</methodname>
             <methodparam>
                 <type>uint16_t</type> <parameter>type</parameter>
             </methodparam>
             <methodparam>
                 <type>size_t</type> <parameter>maxBody</parameter>
                                     <initializer>8192</initializer>
             </methodparam>
         </constructorsynopsis>
        <para>
            Constructs a Ring Item.  <parameter>type</parameter> initializes the
            type field of the item, and maximum size of the body is
            set to be <parameter>maxBody</parameter>.
        </para>
        <para>
            The size of the actual ring buffer item placed in a ring
            via <methodname>commitToRing</methodname> is computed from the
            position of the <firstterm>body cursor</firstterm> as set by the
            last invocation of <methodname>setBodyCursor</methodname>.
        </para>
        <para>
            In order to reduce the amount of dynamic memory management required
            for ring buffer items, a static buffer of size
            <varname>CRingItemStaticBufferSize</varname> is carried by
            all objects.  Only if the maximum size is requested to be larger than
            that is a dynamically allocated body produced by the constructor
            and deleted by the destructor.
        </para>
        <!-- new in 11.0 -->
        
        <constructorsynopsis>
            <methodname> CRingItem</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <type>uint64_t</type><parameter>timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>sourceId</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> barrierType</parameter>
                <initializer>0</initializer>
            </methodparam>
            <methodparam>
                <type>size_t</type><parameter> maxBody</parameter>
                <initializer>8192</initializer>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a ring item with a full body header.  The
            <parameter>timestamp</parameter>, <parameter>sourceId</parameter>
            and <parameter>barriereType</parameter> parameters set the corresponding
            fields in the body header.  The default <parameter>barrierType</parameter>
            of 0 indicates a non-barrier item.
        </para>
        <!-- end of 11.0 addition -->

         <constructorsynopsis>
             <methodname>CRingItem</methodname>
             <methodparam>
                 <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
             </methodparam>
         </constructorsynopsis>
         <para>
            Constructs a ring item by creating a functional copy of
            <parameter>rhs</parameter> (copy construction).
         </para>

         <methodsynopsis>
             <type>CRingItem&amp;</type>
             <methodname>operator=</methodname>
             <methodparam>
                 <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Makes the current object (on the left hand side of an assignment statement)
            a functional equivalent of <parameter>rhs</parameter>.
         </para>
         <methodsynopsis>
             <type>int</type> <methodname>operator==</methodname>
             <methodparam>
                 <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
             </methodparam>
             <modifier>const</modifier>
         </methodsynopsis>
         <para>
            Compares the object on the left hand side of an <literal>==</literal>
            to <parameter>rhs</parameter> for functional equivalence.
            If the two objects reasonably represent the same ring item, returns
            nonzero, else returns zero.
         </para>
         <methodsynopsis>
             <type>int</type> <methodname>operator!=</methodname>
             <methodparam>
                 <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
             </methodparam>
             <modifier>const</modifier>
         </methodsynopsis>
         <para>
            Computes the logical inverse of <methodname>operator==</methodname>
         </para>
         <methodsynopsis>
             <type>size_t</type> <methodname>getStorageSize</methodname>
                                 <void /><modifier>const</modifier>
         </methodsynopsis>
         <para>
            Returns the total size available for the ring item, header and body
            together.
         </para>
         <methodsynopsis>
             <type>size_t</type> <methodname>getBodySize</methodname>
                                 <void /><modifier> const</modifier>
         </methodsynopsis>
         <para>
            Returns the amount of data in the body of the ring.
         </para>
         <methodsynopsis>
             <type>void*</type> <methodname>getBodyPointer</methodname>
                                <void />
         </methodsynopsis>
         <para>
            Returns a pointer to the start of the body.  Note that this returns
            a pointer to the body payload, that is the first byte after the
            Body Header if one is present or the byte after the zero (Version 11) or
            sizeof(uint32_t) (verion 12 or later) indicating
            there is no body header if one is not.
         </para>
         <methodsynopsis>
             <type>void*</type> <methodname> getBodyCursor</methodname>
                                <void />
         </methodsynopsis>
         <para>
            Returns the last stored body cursor.  This is intended to allow you
            (along with <methodname>setBodyCursor</methodname>) to keep track of
            where you should next add information to a ring item.
         </para>
         <methodsynopsis>
             <type>_RingItem*</type>
             <methodname>getItemPointer</methodname> <void />
         </methodsynopsis>
         <para>
            Returns a pointer to the items storage.  This should be a
            <type>RingItemHeader</type> followed by whatever has been
            put in the body.
         </para>
         <methodsynopsis>
             <type>uint32_t</type> <methodname>type</methodname>
                                     <void /> <modifier>const</modifier>
         </methodsynopsis>
         <para>
            Returns the type of the item encapsulated by the object.
            This member does account for byte order mismatches in the event the
            generating system had a different byte order than the system running
            the object.
         </para>
         <methodsynopsis>
             <type>void</type> <methodname>setBodyCursor</methodname>
             <methodparam>
                 <type>void*</type> <parameter>pNewCursor</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Items have a <firstterm>bodyCursor</firstterm>.  This is intended
            to allow software that is building up an item to keep track of
            the next free hunk of memory in the item.  The cusor can be
            fetched via <methodname>getBodyCursor</methodname> and stored
            back via <methodname>setBodyCursor</methodname> which sets the
            body cursor to <parameter>pNewCursor</parameter>
         </para>
         <para>
            This is intended as  a performance compromise that enables
            data such as physics events to insert data into items with no
            penalty other than a pointer dereference.  The
            body cursor is also used to compute the size of an item when it
            is requested, and when or if it is committed to a ring buffer.
         </para>
         <methodsynopsis>
             <type>void</type>
             <methodname>commitToRing</methodname>
             <methodparam>
                 <type>CRingBuffer&amp;</type> <parameter>ring</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Inserts the item that is encapsulated by the object into the
            ring buffer represented by the object <parameter>ring</parameter>.
            At this time, the body cursor must point to the first unused
            byte following the body, as it is used to calculate the size field
            of the item.
        </para>
        <para>
            This call may block indefinitely if space is not available in the ring.
        </para>
         <methodsynopsis>
             <type>bool</type>
             <methodname>mustSwap</methodname>
             <void /><modifier>const</modifier>
         </methodsynopsis>
         <para>
            Returns true if the byte order of the object is the opposite of the
            running system.  Two assumptions are used to derive this result.
            First, that all ring items that are formatted in the local host
            will have local host byte ordering and therefore should return
            <literal>false</literal>
            for <methodname>mustSwap</methodname>.
            Second, that the top 16 bits of the data type are always zero
            and that this can be used to determine the byte ordering of an item.
         </para>
          <methodsynopsis>
            <modifier></modifier>
            <type>void</type>
            <methodname>updateSize</methodname>
            <void />
            <modifier></modifier>
          </methodsynopsis>
          <para>
            Should be called prior to committing an item to the ring.
            This recomputes the header size based on the position of the
            insertion cursor and presence or absence of a body header.
          </para>
            <!-- New in 11.0 -->
            
        <methodsynopsis>
            <type>bool</type>
            <methodname> hasBodyHeader</methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns <literal>true</literal> if the ring item has a body header.
            Returns <literal>false</literal> if not.  Note that the condition
            for returning true is that the length of the body header is greater than
            sizeof(uint32_t).
        </para>
        <methodsynopsis>
            <modifier></modifier>
            <type>uint64_t</type>
            <methodname> getEventTimestamp</methodname>
            <void />
            <exceptionname>std::string</exceptionname>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the value of the timestamp from the items' body header. If
            <methodname>hasBodyHeader</methodname> would return <literal>false</literal>
            a string exception containing an explanatory error message is
            thrown as an exception.
        </para>
        <methodsynopsis>
            <type>uint32_t </type>
            <methodname>getSourceId</methodname>
            <void />
            <exceptionname>std::string</exceptionname>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the source id from the item's body header.
            If
            <methodname>hasBodyHeader</methodname> would return <literal>false</literal>
            a string exception containing an explanatory error message is
            thrown as an exception.
        </para>
        <methodsynopsis>
            <type>uint32_t </type>
            <methodname>getBarrierType</methodname>
            <void />
            <exceptionname>std::string</exceptionname>
            <modifier>const</modifier>
        </methodsynopsis>  
        <para>
            Returns the barrier type of the item.
            If
            <methodname>hasBodyHeader</methodname> would return <literal>false</literal>
            a string exception containing an explanatory error message is
            thrown as an exception.
        </para>
 
        <methodsynopsis>
            <type>void</type>
            <methodname>setBodyHeader</methodname>
            <methodparam>
                <type>uint64_t</type><parameter>timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>sourceId</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>barrierType</parameter>
                <initializer>0</initializer>
            </methodparam>
        </methodsynopsis>
        <para>
            If the item does not yet have a BodyHeader the body contents are
            moved to make room and the <parameter>timestramp</parameter>
            <parameter>sourceId</parameter> and <parameter>barrierType</parameter>
            parameters are used to fill in the corresponding fields of the
            Body Header.  If the item already has a body header, the parameters
            replace the contents of the body header in place.
        </para>
        <para>
            Naturally if you have an event item witha potentially large body,
            it is more efficient to construct it with a body header, even with
            nonsensical values and then invoke <methodname>setBodyHeader</methodname>
            than it is to construct the item without a body header, fill it in
            and then invoke <methodname>setBodyHeader</methodname>.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>std::string </type>
            <methodname>typeName() </methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            This virtual method is intended to be overriden in subclasses
            to provide a textual name of the item type.  This method along
            with <methodname>toString</methodname> below are intended to provide
            support for creating human readable dumps of ring items.  If not
            overriden, the method will produce string like:
            <literal>Unknown (<replaceable>hex-type</replaceable>)</literal>
            where <replaceable>hex-type</replaceable> is the hexadecimal value
            of the item type code  in the ring item header.
        </para>
        <methodsynopsis>
            <modifier>virtual </modifier>
            <type>std::string </type>
            <methodname>toString() </methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>          
        <para>
            This virtual method is inteded to be overridden in the subclasses
            to provide a human readable string representation of the item.
            If not overridden, the body header formatted and the body payload
            is simply dumped as hexadecimal bytes.
        </para>
        <note>
            <title>Note</title>
            <para>
                The protected method <methodname>bodyHeaderToString</methodname>
                will produce a string that both describes whether or not
                an item has a body header and the contents of that header if it
                does.  Since that method is protected, base classes may use
                it to include a formatted body header to their output.
            </para>
        </note>
        
        <!-- End of 11.0 additions -->

         <methodsynopsis>
             <modifier>static</modifier>
             <type>CRingItem*</type>
             <methodname>getFromRing</methodname>
             <methodparam>
                 <type>CRingBuffer&amp;</type> <parameter>ring</parameter>
             </methodparam>
             <methodparam>
                 <type>CRingSelectionPredicate&amp;</type> <parameter>predicate</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Returns a pointer to a dynamically allocated ring item that was
            fetched from the ring buffer <parameter>ring</parameter>.
            The item must satisfy the selection criteria defined by
            <parameter>predicate</parameter>.
            If you want all items, simply pass in an un-reconfigured
            <classname>CAllButPredicate</classname> object.
         </para>
        <para>
            Predicates provide a powerful mechanism for selecting and sampling
            data from ring buffers.  For more information about them,
            see the web documentation chapter
            Ring Format
            which provides background information about ring buffer predicates.
            For reference information, see the reference pages for:
            <link linkend="manpage.cringselectionpredicate"><classname>CRingSelectionPredicate</classname></link>,
            <link linkend="manpage.callbutpredicate"><classname>CAllButPredicate</classname></link>,
            and
            <link linkend="manpage.cdesiredtypespredicate"><classname>CDesiredTypesPredicate</classname></link>.
            Note that you may also construct your own predicate classes should
            these not be sufficient to meet your needs.
        </para>
        <para>
            The caller is responsible for deleting the object.
        </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            While not explicitly referenced in the public interfaces
            of
            <classname>CRingItem</classname>, if you use this class directly,
            you should be familiar with the data types defined in the header
            <filename>DataFormat.h</filename>.  
         </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            The code fragment below shows how to sample the next physics buffer
            from a ring which is represented by the object <varname>ring</varname>
         </para>
         <example>
            <title>Selecting sampled event from a ring.</title>
            <programlisting>
#include &lt;DataFormat.h&gt;                            <co id="cringitem.include" />
...
CDesiredTypesPredicate sampledEventsOnly;                <co id="cringitem.predicate" />
sampledEventsOnly.addDesiredType(PHYSICS_EVENT, true);   <co id="cringitem.addtype" />
CRingItem* item = CRingItem::getFromRing(ring, sampledEventsOnly); <co id="cringitem.get" />

// work with the item...
                                                        <co id="cringitem.process" />
//  Done with the item.

delete item;                                           <co id="cringitem.delete" />
            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs="cringitem.include">
                <para>
                    This <literal>#include</literal> obtains the data type and
                    constant definitions for ring items.  Specifically, we wil
                    need at least the <literal>PHYSICS_EVENT</literal>
                    constant.
                </para>
            </callout>
            <callout arearefs="cringitem.predicate">
                <para>
                    We will limit the ring items processed to the most recently
                    inserted physics event items.  This requires a predicate
                    that will select those items.  The simplest one to use
                    is the <classname>CDesiredTypesPredicate</classname> which
                    selects only the types we tell it to in the mode requested.
                </para>
            </callout>
            <callout arearefs="cringitem.addtype">
                <para>
                    This line informs the predicate that we want to select
                    ring items of type
                    <literal>PHYSICS_EVENT</literal> only and in sampled mode
                    meaning the predicate will skip all but the most recently
                    inserted physics event.
                </para>
            </callout>
            <callout arearefs="cringitem.get">
                <para>
                    This gets a pointer to the ring item that satisfies our
                    selection criteria.  Note that given our predicate,
                    we are assured that
                    <literal>item->type()</literal> would return
                    <literal>PHYSICS_EVENT</literal>.
                </para>
            </callout>
            <callout arearefs="cringitem.process">
                <para>
                    I'm omitting what you do to process the item as that's application
                    dependent.
                </para>
            </callout>
            <callout arearefs="cringitem.delete">
                <para>
                    Once you are done processing the ring item, it's storage
                    must be deleted or else eventually the memory leak
                    you would introduce will cause your program to fail.
                </para>
            </callout>
         </calloutlist>
      </refsect1>
   </refentry>
    
    <refentry id="manpage.cringscaleritem">
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
            <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
      <refmeta>
         <refentrytitle>CRingScalerItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>CRingScalerItem</refname>
	 <refpurpose>Encapsulate ring buffer scaler items.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CRingScaleritem.h&gt;
         </programlisting>
         <synopsis>
            <ooclass><classname>CRingScalerItem</classname></ooclass>
            <varname>CRingScalerItem::m_ScalerFormatMask(32)</varname>
            <constructorsynopsis>
                <methodname>CRingScalerItem</methodname>
                <methodparam>
                    <type>size_t</type> <parameter>numScalers</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingScalerItem</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>startTime</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>stopTime</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type>   <parameter>timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>std::vector&lt;uint32_t&gt;</type> <parameter>scalers</parameter>
                </methodparam>
            </constructorsynopsis>
            
            <!-- NSCLDAQ-11.0 addition -->
            <constructorsynopsis>
                <methodname>CRingScalerItem</methodname>
                <methodparam>
                    <type>uint64_t</type><parameter> eventTimestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter> source</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>barrier</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>startTime</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>stopTime</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type><parameter>timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>std::vector&lt;uint32_t&gt;</type>
                    <parameter>scalers</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>timeDivisor</parameter>
                    <initializer>1</initializer>
                </methodparam>
            </constructorsynopsis>
            <!-- end of 11.0 addition -->
            
            <constructorsynopsis>
                <methodname>CRingScalerItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingScalerItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CRingScalerItem</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CRingScalerItem&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
                                                        <modifier>const</modifier>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>setStartTime</methodname>
                <methodparam><type>uint32_t</type> <parameter>startTime</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getStartTime</methodname>
                                      <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
               <type>float</type>
               <methodname>computeStartTime</methodname>
               <void />
               <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setEndTime</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>endTime</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getEndTime</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
               <type>float</type>
               <methodname>computeEndTime</methodname>
               <void />
               <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
               <type>uint32_t</type>
               <methodname>getTimeDivisor</methodname>
               <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>setTimestamp</methodname>
                <methodparam>
                    <type>time_t</type> <parameter>stamp</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>time_t</type> <methodname>getTimestamp</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setScaler</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>channel</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
                <exceptionname>CRangeError</exceptionname>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type>
                <methodname>getScaler</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>channel</parameter>
                </methodparam>
                <exceptionname>CRangeError</exceptionname>
                <modifier>const</modifier>
            </methodsynopsis>
            
            <methodsynopsis>
                <type>std::vector&lt;uint32_t&gt;</type> <methodname>getScalers</methodname>
                                                         <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getScalerCount</methodname>
                                      <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
               <type>uint32_t</type>
               <methodname>getOriginalSourceId</methodname>
               <void /> <modifier>const</modifier>
            </methodsynopsis>     // Since NSCLDAQ-12.0
            <!-- 11.0 additions -->
            
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>typeName</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type> std::string</type>
                <methodname>toString</methodname><modifier>const</modifier>
            </methodsynopsis>
            
            <!-- end of 11.0 additions -->
            
         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CRingScalerItem</classname> encapsulates scaler items
            that either have been gotten from a ring or are being formatted
            to be inserted into a ring.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CRingScalerItem</methodname>
            <methodparam>
                <type>size_t</type> <parameter>numScalers</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructor for a ring scaler item that will hold
            <parameter>numScalers</parameter>
            incremental scaler values.
            The interval start and stop times are set to zero and the
            timestamp to the current time. Scaler values are not initialized
            (specifically don't assume they are zero).
        </para>
        <constructorsynopsis>
            <methodname>CRingScalerItem</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>startTime</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>stopTime</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type>   <parameter>timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>std::vector&lt;uint32_t&gt;</type> <parameter>scalers</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Full constructor for a scaler ring item.
            <parameter>startTime</parameter>
            is the number of seconds of active run time at the start of the
            interval measured by these scalers, and
            <parameter>stopTime</parameter> the end.
            <parameter>timestamp</parameter> is the absolute time of the end of
            the measurement interval (or more accurately, the time at which
            the scaler item was formatted).
            <parameter>sclaers</parameter> are a vector of scaler values.
        </para>
        <!-- NSCLDAQ-11.0 addition -->
        <constructorsynopsis>
            <methodname>CRingScalerItem</methodname>
            <methodparam>
                <type>uint64_t</type><parameter> eventTimestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> source</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>barrier</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>startTime</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>stopTime</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type><parameter>timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>std::vector&lt;uint32_t&gt;</type>
                <parameter>scalers</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>timeDivisor</parameter>
                <initializer>1</initializer>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a ring scaler item with a full body header described
            by the <parameter>eventTimestamp</parameter>, <parameter>source</parameter>
            and <parameter>barrier</parameter> parameters.  If the optional
            <parameter>timeDivisor</parameter> parameter is supplied, it
            will set the time divisor that is used to provide sub-second
            granularity to the interval start and end times.
        </para>
        <!-- end of 11.0 addition -->
        <constructorsynopsis>
            <methodname>CRingScalerItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <exceptionname>std::bad_cast</exceptionname>
        </constructorsynopsis>
        <para>
            Constructs a scaler item from an existing ring item
            <parameter>rhs</parameter>.
            If <parameter>rsh</parameter>'s type is not
            <literal>INCREMENTAL_SCALERS</literal>,
            a <type>std::bad_cast</type> exception is thrown.
        </para>
        <constructorsynopsis>
            <methodname>CRingScalerItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a functional duplicate of the scaler item
            <parameter>rhs</parameter> (copy construction).
        </para>
        <methodsynopsis>
            <type>CRingScalerItem&amp;</type> <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Assigns to this object from <parameter>rhs</parameter>.
            The object will become a functional equivalent of <parameter>rhs</parameter>.
            If later compared to <parameter>rhs</parameter> equality will be true.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier><type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Compares <parameter>rhs</parameter> with the object for
            functional equivalency.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
                                                    <modifier>const</modifier>
            </methodparam>
        </methodsynopsis>
        <para>
            Compares the item for functional equivalency and returns the
            logical inverse of the result.
        </para>
        <methodsynopsis>
            <type>void</type>
            <methodname>setStartTime</methodname>
            <methodparam><type>uint32_t</type> <parameter>startTime</parameter></methodparam>
        </methodsynopsis>
        <para>
            Sets the interval start time offset to
            <parameter>startTime</parameter>.  This is supposed to be the
            time into the run at which this set of scalers started counting.
            Inactive run time is not  counted.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getStartTime</methodname>
                                  <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the counting interval start time.
        </para>
        <methodsynopsis>
           <type>float</type>
           <methodname>computeStartTime</methodname>
           <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
          Computes the counting interval start time in seconds.
          The method <methodname>getStartTime</methodname> gets
          the start time in "tick" units.  To convert this
          time to seconds, the ticks must be divided by the time
          divisor.  This convenience method performs that computation.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setEndTime</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>endTime</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the interval end time to
            <parameter>endTime</parameter>.
            This is supposed to be the number of seconds in to the run
            at which the scalers for this item were read and cleared.
            Note that only active seconds are acounted.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getEndTime</methodname>
            <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the time offset into the run at which the scalers were read.
            For a properly formatted item, this value should be larger than
            that returned by <methodname>getStartTime</methodname>.
        </para>
        <methodsynopsis>
           <type>uint32_t</type>
           <methodname>getTimeDivisor</methodname>
           <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
          NSCLDAQ-11.0 introduced subsecond precision for run
          offset times.  This is accomplished by allowing the
          time offsets to be provided in arbitrary tick units along
          with a divisor that, when dividing those ticks in a floating
          point division produces seconds.
        </para>
        <para>
          <methodname>getTimeDivisor</methodname> returns this
          timing divisor.  Note that ordinarily, just to get
          run offset times in seconds, just use the
          <methodname>computeStartTime</methodname> and
          <methodname>computeEndTime</methodname> methods..
        </para>
        <methodsynopsis>
           <type>float</type>
           <methodname>computeEndTime</methodname>
           <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
          Returns the interval end time in units of seconds.
          The method <methodname>getEndTime</methodname>
          returns the end time in counter tick units.  To convert
          those units to seconds they must be divided by the time
          divisor.  This convenience method performs that
          computation.
        </para>
        <methodsynopsis>
            <type>void</type>
            <methodname>setTimestamp</methodname>
            <methodparam>
                <type>time_t</type> <parameter>stamp</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the timestamp for the item.  This should be the time at which
            the buffer was formatted.  It is a <type>time_t</type> as described
            in documentation of the unix <function>time</function> function.
        </para>
        <methodsynopsis>
            <type>time_t</type> <methodname>getTimestamp</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the timestamp for an item.  This is supopsed to be
            compatible for the argument to e.g. <function>ctime</function>
            in the byte order of the creating system.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setScaler</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>channel</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
            <exceptionname>CRangeError</exceptionname>
        </methodsynopsis>
        <para>
            Sets the value of scaler number <parameter>channel</parameter>
            to <parameter>value</parameter>.  If <parameter>channel</parameter>
            is larger than the number of scalers the item was constructed with,
            <type>CRangError</type> is thrown.
        </para>
        <methodsynopsis>
            <type>uint32_t</type>
            <methodname>getScaler</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>channel</parameter>
            </methodparam>
            <exceptionname>CRangeError</exceptionname>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the value of the scaler channel <parameter>channel</parameter>.
            If the <parameter>channel</parameter> is too large a
            <type>CRangeError</type> is thrown.
        </para>
        <methodsynopsis>
            <type>std::vector&lt;uint32_t&gt;</type> <methodname>getScalers</methodname>
                                                     <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns a vector that consists of the values of all of the incremental
            scalers in the item.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getScalerCount</methodname>
                                  <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the number of scalers in the item.
        </para>
        <!-- 12.0 addition  -->
        <methodsynopsis>
           <type>uint32_t</type>
           <methodname>getOriginalSourceId</methodname>
           <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
          The Source id of the ring item in the body header can be
          re-written by the event building pipeline.  Since the original
          sourceid (the one supplied to construct the ring item) is
          important for determining the actual meaning of the scaler
          data in analysis, that source id is stored, as well in the
          scaler body.  This method returns that value.  
        </para>
        <para>
          This method is an NSCLDAQ-12.0 addition.
        </para>
        <!-- 11.0 additions -->
        
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>typeName</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Provides a textual string that describes the scaler item type.
            This overrides the base class method with code that returns the
            string <literal>Scaler:</literal>.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier><type> std::string</type>
            <methodname>toString</methodname><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Overrides the base class method with code that returns a formatted
            dump of the scaler values and scaler rates over the period in which
            the scalers were acquired.  Note that the rate is only produced
            for incremental scalers.
        </para>
        <para>
            The public static variable <varname>CRingScalerItem::m_ScalerFormatMask</varname>
            is bitwise anded with each scaler item after the scaler items are
            fetched from the ring item prior to output. This allows
            a clean formatting of scaler counters that have fewer than 32 bits
            but have garbage in their top bits.
        </para>
        
        <!-- end of 11.0 additions -->

      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            See the <type>ScalerItem</type> type in
            <filename>&lt;DataFormat.h&gt;</filename>.
         </para>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <variablelist>
            <varlistentry>
                <term><type>std::bad_cast</type></term>
                <listitem>
                    <para>This is thrown in the event an attempt is made
                        to construct a
                        <classname>CRingScalerItem</classname> object
                        from a
                        <classname>CRingItem</classname> whose type is not
                        <literal>INCREMENTAL_SCALERS</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>CRangeError</type></term>
                <listitem>
                    <para>
                        Thrown in the event an effort is made to access a scaler
                        channel that does not exist.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            In the following example, an item is gotten from a ring buffer.
            If it is a scaler item, it is used to construct a new scaler
            item.  <literal>ring</literal> is assumed to be a
            <classname>CRingBuffer</classname>
            object or a reference to one.
         </para>
         <example>
            <title>Constructing a scaler item from an item gotten from a ring</title>
            <programlisting>
#include &lt;DataFormat.h&gt;
#include &lt;CRingItem.h&gt;
#include &lt;CRingScalerItem&gt;
...

CAllButPredicate  all;                                        <co id="scaler.allpred" />
CRingItem*        pItem = CRingItem::getFromRing(ring, all);  <co id="scaler.get" />

if (pItem->type() == INCREMENTAL_SCALERS) {                   <co id="scaler.isscaler" />
   CRingScalerItem scalers(*pItem);                           <co id="scaler.construct" />
   ...
}
else {
...
}
delete pItem;                                                <co id="scaler.delete" />
 
            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs="scaler.allpred">
                <para>
                    This predicate accepts all ring buffer item types without
                    sampling.  The
                    <classname>CAllButPredicate</classname> accepts all ring
                    types without sampling except those explicitly defined.
                </para>
            </callout>
            <callout arearefs="scaler.get">
                <para>
                    Gets the next item from the ring, regardless of type.
                </para>
            </callout>
            <callout arearefs="scaler.isscaler">
                <para>
                    Before constructing a
                    <classname>CRingScalerItem</classname> object, it's important
                    to ensure the object is atually a scaler item.  Without this
                    check it would be necessary to wrap this code in a
                    <literal>try/catch</literal> block for <type>std::bad_cast</type>.
                </para>
            </callout>
            <callout arearefs="scaler.construct">
                <para>
                    If the item is a scaler item, it is converted into a
                    <classname>CScalerItem</classname>
                    and processed.
                </para>
            </callout>
            <callout arearefs="scaler.delete">
                <para>
                    Regardless, the original
                    <classname>CRingItem</classname> object must be deleted.
                </para>
            </callout>
         </calloutlist>
      </refsect1>
   </refentry>
    <refentry id="manpage.cringstatechangeitem">
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
            <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
      <refmeta>
         <refentrytitle>CRingStateChangeItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>CRingStateChangeItem</refname>
	 <refpurpose>Encapsulate a ring buffer state change item.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CRingStateChangeItem&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CRingStateChangeItem</classname></ooclass>
	 </classsynopsis>
	 <synopsis>
            <constructorsynopsis>
                <methodname>CRingStateChangeItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>reason</parameter><initializer> BEGIN_RUN</initializer>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingStateChangeItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>reason</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>runNumber</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>timeOffset</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type> <parameter>timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>title</parameter>
                </methodparam>
                <exceptionname>CRangeError</exceptionname>
            </constructorsynopsis>
            
            <!-- 11.0 additions -->
            
            <constructorsynopsis>
                <methodname>CRingStateChangeItem</methodname>
                <methodparam>
                    <type>uint64_t</type> <parameter>eventTimestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>sourceId</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>barrierType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>reason</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>runNumber</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>timeOffset</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type><parameter> timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type><parameter> title</parameter>
                </methodparam>
            </constructorsynopsis>
            
            <!-- end of 11.0 additions -->
            
            <constructorsynopsis>
                <methodname>CRingStateChangeItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>item</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingStateChangeItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CRingStateChangeItem</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CRingStateChangeItem&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>setRunNumber</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>run</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getRunNumber</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setElapsedTime</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>offset</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getElapsedTime</methodname>
                                      <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
               <type>uint32_t</type>
               <methodname>getTimeDivisor</methodname>
               <void /><modifier>const</modifier> 
            </methodsynopsis>        // added V12.0
            <methodsynopsis>
               <type>float</type>
               <methodname>computeElapsedTime</methodname>
               <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setTitle</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>title</parameter>
                </methodparam>
                <exceptionname>CRangeError</exceptionname>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>getTitle</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setTimestamp</methodname>
                <methodparam>
                    <type>time_t</type> <parameter>stamp</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>time_t</type> <methodname>getTimestamp</methodname>
                                    <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
               <type>uint32_t</type>
               <methodname>getOriginalSourceId</methodname>
               <void /> <modifier>const</modifier>
            </methodsynopsis>    // Added in 12.0
    
            <!-- 11.0 additions -->
            
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>typeName</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>toString</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            
            <!-- end of 11.0 additions -->
	};
         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Encapsulates a ring buffer item for the ring items that represent
            changes in state of a data taking run.  These are specifically
            ring items of the type:
            <literal>BEGIN_RUN</literal>,
            <literal>END_RUN</literal>,
            <literal>PAUSE_RUN</literal>,
            and <literal>RESUME_RUN</literal>.
         </para>
         <para>
            In a ring buffer, these items take the form of a
            <type>StateChangeItem</type> as defined in
            <filename>&lt;DataFormat.h&gt;</filename>.
         </para>
         <para>
            The class can be used both to format state change items for later
            insertion into a ring, or to decode existing state change items.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CRingStateChangeItem</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>reason</parameter><initializer> BEGIN_RUN</initializer>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a state change item with the type <parameter>reason</parameter>.
            The run number, and time offset will be set to zero.  The
            timestamp will be set to the current time, and the title will be
            empty.
        </para>
        <constructorsynopsis>
            <methodname>CRingStateChangeItem</methodname>
            <methodparam>
                <type>uint16_tM</type> <parameter>reason</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>runNumber</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>timeOffset</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type> <parameter>timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>title</parameter>
            </methodparam>
            <exceptionname>CRangeError</exceptionname>
        </constructorsynopsis>
        <para>
            Constructs a run state change item in a fully specified way.
            <parameter>reason</parameter> is the actual type of the item.
            <parameter>runNumber</parameter> will be stored in the item as
            the number of the run undergoing state change.
            <parameter>timeOffset</parameter> should be the time in the run
            at which the state change occured in seconds.  This time should not
            include time spent in the paused state, and the begin run is always
            emitted at <parameter>timeOffset</parameter> zero.
            <parameter>timestamp</parameter> is an absolute time at which the
            transition occured.  This can be gotten via the POSIX
            <function>time(2)</function> function.
            <parameter>title</parameter> is the title string.
        </para>
        <para>
            The <parameter>title</parameter> string must be at most
            <literal>TITLE_MAXSIZE</literal> characters long.  If it is longer
            than that, a <classname>CRangeError</classname> will be thrown.

        </para>
        <!-- 11.0 additions -->
        
        <constructorsynopsis>
            <methodname>CRingStateChangeItem</methodname>
            <methodparam>
                <type>uint64_t</type> <parameter>eventTimestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>sourceId</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>barrierType</parameter>
            </methodparam>
            <methodparam>
                <type>uint16_t</type> <parameter>reason</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>runNumber</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>timeOffset</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type><parameter> timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type><parameter> title</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a ring state change item that has a full body header.
            The contents of the body header are determined by
            <parameter>eventTimestamp</parameter>, <parameter>sourceId</parameter>
            and <parameter>barrierType</parameter>.
        </para>
        
        <!-- end of 11.0 additions. -->
            
        <constructorsynopsis>
            <methodname>CRingStateChangeItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>item</parameter>
            </methodparam>
            <exceptionname>std::bad_cast</exceptionname>
        </constructorsynopsis>
        <para>
            Attempts to construct a <classname>CRingStateChangeItem</classname>
            from a reference to an existing
            <classname>CRingItem</classname>; <parameter>item</parameter>.
            If <parameter>item</parameter> is not a value state change
            item, a
            <type>std::bad_cast</type> exception will be thrown.
        </para>
        <constructorsynopsis>
            <methodname>CRingStateChangeItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs an object that is a functional copy of
            <parameter>rhs</parameter>.
        </para>
        <methodsynopsis>
            <type>CRingStateChangeItem&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides assignment to <classname>CRingStateChangeItem</classname> objects
            from other <classname>CRingStateChangeItem</classname>s.
            After assignment is done the object on the left side of the
            <literal>=</literal> is a functional equivalent of
            <parameter>rhs</parameter>.
        </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Compares the object on the left hand side of the
            <literal>==</literal> for functional equivalence with the
            <parameter>rhs</parameter> object.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Compares the object for functional equivalence with
            <parameter>rhs</parameter>.
            Returns the logical inverse of the comparison.
        </para>
        <methodsynopsis>
            <type>void</type>
            <methodname>setRunNumber</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>run</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the run number of the item to
            <parameter>run</parameter>.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getRunNumber</methodname>
            <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the current value of the run number.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setElapsedTime</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>offset</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Set the elapsed time for the item to <parameter>offset</parameter>.
            This value is supposed to represent the number of active seconds
            into the run at which the state transition occured.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getElapsedTime</methodname>
                                  <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the object's current elapsed run time value.
        </para>
        <methodsynopsis>
           <type>uint32_t</type>
           <methodname>getTimeDivisor</methodname>
           <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
          Returns the time divisor.
          <methodname>getElapsedTime</methodname> returns the time
          into the run in ticks with arbitrary units. The time divisor,
          introduced in version 11.0 allows <methodname>cmoputeElapsedTime</methodname>
          to convert these ticks into seconds.  This method
          returns the value of that time divisor.
        </para>
        <para>
          The purpose of the timing divisor is to support sub-second
          timing resolution for these run offsets.
        </para>
        <methodsynopsis>
           <type>float</type>
           <methodname>computeElapsedTime</methodname>
           <void />
        </methodsynopsis>
        <para>
          Returns the elapsed time into the run in seconds.
          This is done by getting the elapsed time in ticks and
          dividing it by the timing divisor in a floating point
          division.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setTitle</methodname>
            <methodparam>
                <type>std::string</type> <parameter>title</parameter>
            </methodparam>
            <exceptionname>CRangeError</exceptionname>
        </methodsynopsis>
        <para>
            Sets a new value for the title of the run.
            If the title is longer than
            <literal>TITLE_MAXSIZE</literal> characters,
            a <classname>CRangeError</classname> will be thrown.
        </para>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>getTitle</methodname>
            <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the value of the title string.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setTimestamp</methodname>
            <methodparam>
                <type>time_t</type> <parameter>stamp</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the absolute time of the state transition to
            <parameter>stamp</parameter>.
            This is a value that might be gotten via the
            Unix <function>time(2)</function> function
        </para>
        <methodsynopsis>
            <type>time_t</type> <methodname>getTimestamp</methodname>
                                <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the value of the absolute run time.
        </para>
        <methodsynopsis>
           <type>uint32_t</type>
           <methodname>getOriginalSourceId</methodname>
           <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
          In an environment where the NSCL event builder is used,
          the source Id of a ring item determines which data source
          emitted the item.  To support multi-level event building,
          however event builders, themselves are data sources
          and rewrite the source id stored in the body header to the
          source id assigned to the event builder.  In order
          to allow state change items to be tracked back to their
          original data source the source id used to construct
          a <classname>CRingStateChangeItem</classname> object,
          beginning with NSCLDAQ-V12.0, is also stored in the state
          change body.  <methodname>getOriginalSourceId</methodname>
          returns that source id and should, in most cases, be used
          rather than the value in the body header.
        </para>
        <!-- 11.0 additions -->
        
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>typeName</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Overrides the base class method.
            Returns a textual description of the type of the ring item
            (e.g. <literal>Begin Run</literal>).
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>toString</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Overrides the base class method to produce a text string that describes
            the state change item.
        </para>
        <!-- end of 11.0 additions -->
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            The underlying item encapsulated by this class is a
            <type>StateChangeItem</type> which is defined in
            <filename>&lt;DataFormat.h&gt;</filename>.
         </para>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <variablelist>
            <varlistentry>
                <term><type>std::bad_cast</type></term>
                <listitem>
                    <para>
                        Called if an attempt is made to construct from
                        a <classname>CRingItem</classname> that is not
                        a valid run state transition item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CRangeError</classname></term>
                <listitem>
                    <para>
                        Thrown if an attempt is made to provide a title string
                        that is longer than allowed by run-state transition
                        items.  The maximum title string length is
                        <literal>TITLE_MAXSIZE</literal>.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            The example below creates a begin run and informs a ring about this.
         </para>
         <example>
            <title>Creating a begin run state transition item</title>
            <programlisting>
#include &lt;DataFormat.h&gt;
#include &lt;CRingStateChange.h&gt;

CRingStateChange item;
item.setTitle(string("This is the run title"));
item.setRunNumber(1234);

item.commitToRing(aring);

            </programlisting>
         </example>
      </refsect1>
   </refentry>

    <refentry id="manpage.cringtextitem">
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
            <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
      <refmeta>
         <refentrytitle>CRingTextItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>CRingTextItem</refname>
	 <refpurpose>Encapsulate ring items that are lists of text strings.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CRingTextItem&gt;
         </programlisting>
         <synopsis>
            <ooclass><classname>CRingTextItem</classname></ooclass>
            <constructorsynopsis>
                <methodname>CRingTextItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>std::vector&lt;std::string&gt;</type> <parameter>theStrings</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingTextItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>std::vector&lt;std::string&gt;</type> <parameter>theStrings</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>offsetTime</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type> <parameter>timestamp</parameter>
                </methodparam>
            </constructorsynopsis>
            
            <!-- 11.0 additions -->
            <constructorsynopsis>
                <methodname>CRingTextItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>uint64_t</type><parameter>eventTimestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>source</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter> barrier</parameter>
                </methodparam>
                <methodparam>
                    <type>std::vector&lt;std::string&gt;</type>
                    <parameter>theStrings</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter> offsetTime</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type><parameter> timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>offsetDivisor</parameter>
                    <initializer>1</initializer>
                </methodparam>
            </constructorsynopsis>
            <!-- end of 11.0 additions -->
            
            <constructorsynopsis>
                <methodname>CRingTextItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingTextItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CRingTextItem</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CRingTextItem&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::vector&lt;std::string&gt;</type>
                <methodname>getStrings</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setTimeOffset</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>offset</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getTimeOffset</methodname>
                                      <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
               <type>float</type>
               <methodname>computeElapsedTime</methodname>
               <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
               <type>uint32_t</type>
               <methodname>getTimeDivisor</methodname>
               <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setTimestamp</methodname>
                <methodparam>
                    <type>time_t</type> <parameter>stamp</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>time_t</type> <methodname>getTimestamp</methodname>
                                    <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
               <type>uint32_t</type>
               <methodname>getOriginalSourceId</methodname>
               <void /><modifier>const</modifier>
            </methodsynopsis>   // Since V12.0
            <!-- 11.0 additions -->
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>typeName</methodname><void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>toString</methodname><void />
                <modifier>const</modifier>
            </methodsynopsis>
            <!-- end 11.0 additions -->
            
         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Text string items contain lists of null terminated documentation strings.
            These are stored in ring buffers in structures of the type:
            <type>TextItem</type>.  These items have a type code of
            <literal>PACKET_TYPES</literal> or
            <literal>MONITORED_VARIABLES</literal>.  These items are used to
            document the set of packets you can expect to see in
            a <literal>PHYSICS_EVENT</literal> and provide the value of monitored
            process variables respectively.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CRingTextItem</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <type>std::vector&lt;std::string&gt;</type> <parameter>theStrings</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a ring text item of the type specified by
            <parameter>type</parameter>.  The text strings will be filled in with
            the values of the individual strings in <parameter>theStrings</parameter>.
        </para>
        <para>
            The run offset time will be initialized to zero, and the
            absolute timestamp to the construction time of the object.
        </para>
        <constructorsynopsis>
            <methodname>CRingTextItem</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <type>std::vector&lt;std::string&gt;</type> <parameter>theStrings</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>offsetTime</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type> <parameter>timestamp</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a text item in a fully specified way.
            In addition to <parameter>type</parameter> and <parameter>theStrings</parameter>
            providing the item type and the strings for the item respectively,
            <parameter>offsetTime</parameter>, and <parameter>timestamp</parameter>
            provide the run time offset and absolute timestamp values respectively.
        </para>
                <!-- 11.0 additions -->
        <constructorsynopsis>
            <methodname>CRingTextItem</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <type>uint64_t</type><parameter>eventTimestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>source</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> barrier</parameter>
            </methodparam>
            <methodparam>
                <type>std::vector&lt;std::string&gt;</type>
                <parameter>theStrings</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> offsetTime</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type><parameter> timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>offsetDivisor</parameter>
                <initializer>1</initializer>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a text item with  a full body header. The contents of the
            header are determined by the values of <parameter>eventTimestamp</parameter>
            <parameter>source</parameter> and <parameter>barrier</parameter>.
            The <parameter>offsetDivisor</parameter> parameter is optional and
            defaults to 1.  It represents the granularity of the <parameter>offsetTime</parameter>
            in seconds.  To get the actual time into the run in seconds compute:
            <literal>(float)offsetTime/offsetDivisor</literal>.
        </para>
            
            <!-- end of 11.0 additions -->
            

        <constructorsynopsis>
            <methodname>CRingTextItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <exceptionname>std::bad_cast</exceptionname>
        </constructorsynopsis>
        <para>
            Constructs a text item from a reference to an existing ring item;
            <parameter>rhs</parameter>.
            If the ring item is not of an appropriate type for a text item,
            a <type>std::bad_cast</type> exception is thrown.
        </para>
        <constructorsynopsis>
            <methodname>CRingTextItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a functional copy of of an existing text ring item;
            <parameter>rhs</parameter>.
        </para>
        <methodsynopsis>
            <type>CRingTextItem&amp;</type> <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides for assignment between ring text items.  When done, the object
            that is acted on will be a functional copy of the
            <parameter>rhs</parameter>  object.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Provides for comparison for functional equivalence between two
            ring text items.  The item is compared with
            <parameter>rhs</parameter>.
            The comparison returns non zero if there is functional equivalence.
        </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the logical inverse  of
            <methodname>operator==</methodname>.
        </para>
        <methodsynopsis>
            <type>std::vector&lt;std::string&gt;</type>
            <methodname>getStrings</methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the strings in the string list as a vector of strings.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setTimeOffset</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>offset</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the time offset at which the item was created to
            <parameter>offset</parameter>.  
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getTimeOffset</methodname>
                                  <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the most recently set time offset for the item.
        </para>
        <methodsynopsis>
           <type>float</type>
           <methodname>computeElapsedTime</methodname>
           <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
          Since NSCLDAQ-V11.0, elapsed run time is represented in
          arbitrary ticks.  A time divisor is then provided which,
          in a floating point division of an elapsed run time
          produces the elapsed time in seconds.
        </para>
        <para>
          The convenience method <methodname>computeElapsedTime</methodname>
          peforms that computation and returns the elapsed run time
          in seconds.
        </para>
        <methodsynopsis>
           <type>uint32_t</type>
           <methodname>getTimeDivisor</methodname>
           <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
          Returns the timing divisor that is used to convert
          elapsed run times to seconds.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setTimestamp</methodname>
            <methodparam>
                <type>time_t</type> <parameter>stamp</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets an absolute timestamp for the item.
        </para>
        <methodsynopsis>
            <type>time_t</type> <methodname>getTimestamp</methodname>
                                <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the item's absolute timestamp.
        </para>
        <methodsynopsis>
           <type>uint32_t</type>
           <methodname>getOriginalSourceId</methodname>
           <void />
        </methodsynopsis>
        <para>
          This method was added in NSCLDAQ-12.0.  In environments that use
          the NSCLDAQ event builder, each event source is identified
          with a unique source id.  An event builder, itself,
          can be used as a data source in a multi-level event builder.
          This means that event builders can rewrite the body headers
          of items they otherwise emit unmodified.
        </para>
        <para>
          Since the original source id is a unique identification
          of where the data in this ring item comes from, beginning
          with NSCLDAQ-12.0, the
          source id supplied at constrution time is also stored
          in the ring item body itself.  This method returns
          <emphasis>that</emphasis> source id and should be used
          to identify the source of this data.
        </para>
        <!-- 11.0 additions -->
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>typeName</methodname><void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns a text string that describes the item type. For example if
            the ring item type is <literal>PACKET_TYPES</literal> the string
            <literal>Packet types:</literal> is returned.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>toString</methodname><void />
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns a string that is a human readable dump of the
            ring item.  This incluces a list of the strings in the item.
        </para>
        <!-- end 11.0 additions -->
        
      </refsect1>
      <refsect1>
        <title>Exceptions</title>
        <para>
            Construction from a ring item can throw a
            <type>std::bad_cast</type> exception if the underlying
            ring item is not either a
            <literal>PACKET_TYPES</literal> or
            <literal>MONITORED_VARIABLES</literal> item.
        </para>
      </refsect1>

   </refentry>
    <refentry id="manpage.cphysicseventitem">
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
            <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
      <refmeta>
         <refentrytitle>CPhysicsEventItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>CPhysicsEventitem</refname>
         <refpurpose>Response to trigger.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include &lt;CPhysicsEventItem.h&gt;
        </programlisting>
       <synopsis>
        
           <ooclass><classname>CPhysicsEventItem</classname></ooclass> : public CRingItem {
           <constructorsynopsis>
            <methodname>CPhysicsEventItem</methodname>
            <methodparam>
                <type>size_t</type><parameter>maxBody</parameter>
                <initializer>8192</initializer>
            </methodparam>
           </constructorsynopsis>
           <constructorsynopsis>
            <methodname>CPhysicsEventItem</methodname>
            <methodparam>
                <type>uint64_t</type><parameter>timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> source</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> barrier</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type><parameter>maxBody</parameter>
                <initializer>8192</initializer>
            </methodparam>
           </constructorsynopsis>
           <constructorsynopsis>
            <methodname>CPhysicsEventItem</methodname>
            <methodparam>
                <modifier>const</modifier><type>CPhysicsEventItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            </constructorsynopsis>
           <destructorsynopsis>
            <modifier>virtual</modifier><methodname> ~CPhysicsEventItem</methodname>
            <void />
           </destructorsynopsis>
           <methodsynopsis>
            <type>CPhysicsEventItem&amp;</type><methodname> operator=</methodname>
            <methodparam>
                <modifier>const</modifier><type>CPhysicsEventItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
           </methodsynopsis>
           <methodsynopsis>
            <type>int</type><methodname> operator==</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CPhysicsEventItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
           </methodsynopsis>
           <methodsynopsis>
            <type>int</type><methodname> operator!=</methodname>
            <methodparam>
                <modifier>const</modifier><type> CPhysicsEventItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
           <methodsynopsis>
            <modifier>virtual</modifier><type> std::string</type>
            <methodname>typeName</methodname>
            <void /><modifier>const</modifier>
           </methodsynopsis>
           <methodsynopsis>
            <modifier>virtual</modifier> <type>std::string</type>
            <methodname>toString</methodname><void /><modifier>const</modifier>
           </methodsynopsis>

};
       </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>DESCRIPTION</title>
         <para>
            Encapsulates the data read by a readout program in response to a
            trigger.  Note the actual meaning of this data depends on which ring
            you are looking at.  For example, if an experiment consists of
            several readout programs operating in parallel, there may be rings
            whose events are really fragments of full events (and an event
            builder data source that turns those events into fragments that
            are input to an event building pipeline).  In the same situation
            the ring to which the output of the glom stage of the event builder
            goes would have complete events (unless one is doing a mulitlevel
            build).
         </para>
      </refsect1>
      <refsect1>
         <title>
        METHODS
         </title>
         <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                     <methodname>CPhysicsEventItem</methodname>
                     <methodparam>
                         <type>size_t</type><parameter>maxBody</parameter>
                         <initializer>8192</initializer>
                     </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a physics item with the specified maximum
                        body size.  You are then responsible for obtaining the
                        body cursor, inserting data, updating the body cursor and
                        sizeo fht item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                     <methodname>CPhysicsEventItem</methodname>
                     <methodparam>
                         <type>uint64_t</type><parameter>timestamp</parameter>
                     </methodparam>
                     <methodparam>
                         <type>uint32_t</type><parameter> source</parameter>
                     </methodparam>
                     <methodparam>
                         <type>uint32_t</type><parameter> barrier</parameter>
                     </methodparam>
                     <methodparam>
                         <type>size_t</type><parameter>maxBody</parameter>
                         <initializer>8192</initializer>
                     </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates an empty physics event item with a full body
                        header whose contents are described by
                        <parameter>timestamp</parameter>, <parameter>source</parameter>
                        and <parameter>barrier</parameter>.
                        As before  you must still fill in the event data itself.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                     <methodname>CPhysicsEventItem</methodname>
                     <methodparam>
                         <modifier>const</modifier><type>CPhysicsEventItem&amp;</type>
                         <parameter>rhs</parameter>
                     </methodparam>
                     </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Copy constructor.  Creates a copy of the object
                        <parameter>rhs</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <type>CPhysicsEventItem&amp;</type><methodname> operator=</methodname>
                     <methodparam>
                         <modifier>const</modifier><type>CPhysicsEventItem&amp;</type>
                         <parameter>rhs</parameter>
                     </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Assigns <parameter>rhs</parameter> to this object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <type>int</type><methodname> operator==</methodname>
                     <methodparam>
                         <modifier>const</modifier>
                         <type>CPhysicsEventItem&amp;</type>
                         <parameter>rhs</parameter>
                     </methodparam>
                     <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Compares <parameter>rhs</parameter> for equality
                        with this object.  If the two objects are
                        equal, a non zero result is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <type>int</type><methodname> operator!=</methodname>
                     <methodparam>
                         <modifier>const</modifier><type> CPhysicsEventItem&amp;</type>
                         <parameter>rhs</parameter>
                     </methodparam>
                     <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns nonzero if <methodname>operator==</methodname>
                        would have returned zero.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <modifier>virtual</modifier><type> std::string</type>
                     <methodname>typeName</methodname>
                     <void /><modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a string that provides a human with the
                        type of this ring item.  The string returned is:
                        <literal>Event </literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <modifier>virtual</modifier> <type>std::string</type>
                     <methodname>toString</methodname><void /><modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Converts the ring item into a human readable string.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect1>
    </refentry>     
    <refentry id="manpage.cringphysicseventcountitem">
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
            <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
      <refmeta>
         <refentrytitle>CRingPhysicsEventCountItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>CRingPhysicsEventCountItem</refname>
	 <refpurpose>Provides statistics regarding the number of events produced.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CRingPhysicsEventCountItem.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CRingPhysicsEventCountItem</classname></ooclass>
	 </classsynopsis>
	 <synopsis>
            <constructorsynopsis>
                <methodname>CRingPhysicsEventCountItem</methodname>
                <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingPhysicsEventCountItem</methodname>
                <methodparam>
                    <type>uint64_t</type> <parameter>count</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>timeOffset</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingPhysicsEventCountItem</methodname>
                <methodparam>
                    <type>uint64_t</type> <parameter>count</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>timeoffset</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type> <parameter>stamp</parameter>
                </methodparam>
            </constructorsynopsis>
            
            <!-- 11.0 additions -->
            <constructorsynopsis>
                <methodname>CRingPhysicsEventCountItem</methodname>
                <methodparam>
                    <type>uint64_t</type><parameter> timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>source</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter> barrier</parameter>
                </methodparam>
                <methodparam>
                    <type>uint64_t</type><parameter> count</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>timeoffset</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type><parameter>stamp</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter>divisor</parameter>
                    <initializer>1</initializer>
                </methodparam>
            </constructorsynopsis>
            
            <!-- end of 11.0 additions -->
            
            <constructorsynopsis>
                <methodname>CRingPhysicsEventCountItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingPhysicsEventCountItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CRingPhysicsEventCountItem</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CRingPhysicsEventCountItem&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getTimeOffset</methodname>
                                      <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setTimeOffset</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>offset</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
               <type>float</type>
               <methodname>computeElapsedTime</methodname>
               <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
               <type>uint32_t</type>
               <methodname>getTimeDivisor</methodname>
               <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>time_t</type>   <methodname>getTimestamp</methodname>
                                      <void />
                                      <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>     <methodname>setTimestamp</methodname>
                <methodparam>
                    <type>time_t</type> <parameter>stamp</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint64_t</type> <methodname>getEventCount</methodname>
                                      <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>     <methodname>setEventCount</methodname>
                <methodparam>
                    <type>uint64_t</type> <parameter>count</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
               <type>uint32_t</type>
               <methodname>getOriginalSourceId</methodname>
               <void /><modifier>const</modifier>
            </methodsynopsis>    // Added in V12.0

            <!-- 11.0 additions -->
            
            <methodsynopsis>
                <modifier>virtual</modifier><type> std::string</type>
                <methodname>typeName</methodname><void /><modifier> const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type> std::string</type>
                <methodname>toString</methodname><void /> <modifier>const</modifier>
            </methodsynopsis>

            <!-- end of 11.0 additions -->
}
         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class encapsulates the
            <type>PhysicsEventCountItem</type> ring item.  That item is used
            to indicate how many events have been acquired so far this run.
            Timestamps and run time offset allow this to be used to compute
            trigger rates.   Clients that need to know the fraction of
            <varname>PHYSICS_EVENT</varname> items they are receiving
            can also use this.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CRingPhysicsEventCountItem</methodname>
            <void />
        </constructorsynopsis>
        <para>
            Default constructor.  The event count and time offset will be
            zeroed.  The timestamp will be the time the constructor was called.
        </para>
        <constructorsynopsis>
            <methodname>CRingPhysicsEventCountItem</methodname>
            <methodparam>
                <type>uint64_t</type> <parameter>count</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>timeOffset</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs an event count item which is initialized with the
            specified <parameter>count</parameter> of triggers and is
            said to have occured <parameter>timeOffset</parameter> seconds
            into the run.
        </para>
        <constructorsynopsis>
            <methodname>CRingPhysicsEventCountItem</methodname>
            <methodparam>
                <type>uint64_t</type> <parameter>count</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>timeoffset</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type> <parameter>stamp</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Same as the previous constructor with the added initialization of
            the item's timestamp to <parameter>stamp</parameter>.
        </para>
        <!-- 11.0 additions -->
        <constructorsynopsis>
            <methodname>CRingPhysicsEventCountItem</methodname>
            <methodparam>
                <type>uint64_t</type><parameter> timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>source</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> barrier</parameter>
            </methodparam>
            <methodparam>
                <type>uint64_t</type><parameter> count</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>timeoffset</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type><parameter>stamp</parameter>
            </methodparam>
            <methodparam>
                <type>int</type><parameter>divisor</parameter>
                <initializer>1</initializer>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a physics event count item with a full body header.
            The contents of the body header are determined by the values
            of <parameter>timestamp</parameter>, <parameter>source</parameter>
            and <parameter>barrier</parameter>.  The <parameter>divisor</parameter>
            optional parameter provides support for run time intervals that
            are less than one second.  The actual time in seconds into the
            run is <programlisting>(float)timeoffset/divisor</programlisting>.
        </para>
        <!-- end of 11.0 additions -->
        <constructorsynopsis>
            <methodname>CRingPhysicsEventCountItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
            <exceptionname>std::bad_cast</exceptionname>
        </constructorsynopsis>
        <para>
            Constructs an event count item from an existing ring item;
            <parameter>rhs</parameter>.
            If <parameter>rhs</parameter> is not of type
            <literal>PHYSICS_EVENT_COUNT</literal>, a
            <classname>std::bad_cast</classname> exception is thrown.
        </para>
        <constructorsynopsis>
            <methodname>CRingPhysicsEventCountItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Provides support for copy construction.
        </para>
        <methodsynopsis>
            <type>CRingPhysicsEventCountItem&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides support for assignment of another event count item,
            <parameter>rhs</parameter> to the object.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Provides support for comparing two event count items to each other
            for functional equality.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Compares two items for functional equality and returns the logical
            inverse of the result.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getTimeOffset</methodname>
                                  <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the current value of the time offset field of the item.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setTimeOffset</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>offset</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the value of the time offset field of the item to
            <parameter>offset</parameter>.
        </para>
        <methodsynopsis>
           <type>float</type>
           <methodname>computeElapsedSourceId</methodname>
           <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
          Since NSCLDAQ-11.0, the elapsed time can is expressed
          in arbitrary ticks that are at least one tick per second.
          This allows for sub-second precision.  This
          method returns the elapsed time in units of second.
        </para>
        <methodsynopsis>
           <type>uint32_t</type>
           <methodname>getTimeDivisor</methodname>
           <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
          Returns the conversion divisor that converts the elapsed
          time ticks into seconds.
        </para>
        <methodsynopsis>
            <type>time_t</type>   <methodname>getTimestamp</methodname>
                                  <void />
                                  <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the current timestamp of the item.
        </para>
        <methodsynopsis>
            <type>void</type>     <methodname>setTimestamp</methodname>
            <methodparam>
                <type>time_t</type> <parameter>stamp</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the object's absolute timestamp to <parameter>stamp</parameter>.
        </para>
        <methodsynopsis>
            <type>uint64_t</type> <methodname>getEventCount</methodname>
                                  <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the count of the number of eveents that have been
            accepted in the run so far (according to this item).
        </para>
        <methodsynopsis>
            <type>void</type>     <methodname>setEventCount</methodname>
            <methodparam>
                <type>uint64_t</type> <parameter>count</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the event count field of the item to <parameter>count</parameter>.
        </para>
        <methodsynopsis>
           <type>uint32_t</type>
           <methodname>getOriginalSourceId</methodname>
           <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
          This method is available since NSCLDAQ V12.0.
          When the NSCLDAQ event builder is used, each data source
          is assigned a unique source id.  Since multi-level event
          building is supported, the event builders themselves are
          assigned source ids and, emit data with body headers that
          reflect the event builder's source id.
        </para>
        <para>
          This means that the source id of the body header can no longer
          be used to identify the actual source of the event count item.
          Therefore, beginning in NSCLDAQ-12.0, the source id used to
          construct these items is also stored in the item body, which
          the event builder does not touch.
          <methodname>getOriginalSourceId</methodname> returns
          this source id and should be used rather than the
          source id in the item's body header to identify the source
          of this data.
        </para>
        <!-- 11.0 additions -->
        
        <methodsynopsis>
            <modifier>virtual</modifier><type> std::string</type>
            <methodname>typeName</methodname><void /><modifier> const</modifier>
        </methodsynopsis>
        <para>
            Returns a text version of the ring item type field. This consists of
            the text <literal>Trigger count:</literal>.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier><type> std::string</type>
            <methodname>toString</methodname><void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns a human readable string representation of the item.
        </para>
        <!-- end of 11.0 additions -->
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <para>
            <type>std::bad_cast</type> is thrown on an attempt to construct
            an event count item out of an item that is not of type
            <literal>PHYSICS_EVENT_COUNT</literal>.
         </para>
      </refsect1>
   </refentry>
    <refentry id="manpage.cringfragmentitem">
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
            <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
      <refmeta>
         <refentrytitle id='manpage.cringfragmentitem.title'>CRingFragmentItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>CRingFragmentItem</refname>
         <refpurpose>Encapsulate a <literal>EVB_FRAGMENT</literal> ring item
         </refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include &lt;CRingFragmentItem.h&gt;
        </programlisting>
       <classsynopsis>
           <ooclass><classname>CRingFragmentItem : public CRingItem </classname></ooclass>
       </classsynopsis> 
       <synopsis>
          <constructorsynopsis>
         <methodname>CRingFragmentItem</methodname>
         <methodparam>
            <type>uint64_t</type> <parameter>timestamp</parameter>
         </methodparam>
         <methodparam>
            <type>uint32_t</type> <parameter>source</parameter>
         </methodparam>
         <methodparam>
            <type>uint32_t</type> <parameter>payloadSize</parameter>
         </methodparam>
         <methodparam>
            <modifier>const</modifier> <type>void*</type> <parameter>pBody</parameter>
         </methodparam>
         <methodparam>
            <type>uint32_t</type> <parameter>barrier</parameter>
            <initializer>0</initializer>
         </methodparam>
          </constructorsynopsis>
          
         <constructorsynopsis>
            <methodname>CRingFragmentItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            <exceptionname>std::bad_cast</exceptionname>
         </constructorsynopsis>
         
         <constructorsynopsis>
            <methodname>CRingFragmentItem</methodname>
            <methodparam>
                <modifier>const</modifier><type>CRingFragmentItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
         </constructorsynopsis>
         
         <destructorsynopsis>
            <modifier>virtual</modifier>
            <methodname>~CRingFragmentItem</methodname>
            <void />
         </destructorsynopsis>
         
         <methodsynopsis>
            <type>CRingFragmentItem&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier><type>CRingFragmentItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
         </methodsynopsis>
         
         <methodsynopsis>
            <type>int</type><methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingFragmentItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
         </methodsynopsis>
         
         <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier><type>CRingFragmentItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
         </methodsynopsis>
         
         // accessors.
         
        <methodsynopsis>
            <type>uint64_t</type>
            <methodname>timestamp</methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>
        
        <methodsynopsis>
            <type>uint32_t</type>
            <methodname>source</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        
        <methodsynopsis>
            <type>size_t</type>
            <methodname>payloadSize</methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>
        
        <methodsynopsis>
            <modifier>const</modifier>
            <type>void*</type>
            <methodname>payloadPointer</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        
        <methodsynopsis>
            <type>uint32_t</type> <methodname>barrierType</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        
        <!-- 11.0 additions -->
        
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>typeName</methodname><void />
            <modifier>const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>toString</methodname>
            <modifier>const</modifier>
        </methodsynopsis>
        
        <!-- end of 11.0 additions -->
       };
        </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>DESCRIPTION</title>
         <para>
            Objects of this class encapsulate a <literal>EVB_FRAGMENT</literal>
            ring item.  These items are intended to be strung together into
            events by an event builder.  Placing them in a ring allows
            for a test point.
         </para>
         <para>
            Since this class is derived from
            <link linkend='manpage.cringitem'>CRingItem</link>,
            you can create ring items and then commit them to an existing
            ring via calls to
            <classname>CRingItem</classname>::<methodname>commitToRing</methodname>.
            Similarly calls to
            <classname>CRingItem</classname>::<methodname>getFromRing</methodname>.
            allow you to get a ring item and then, when you determine from the
            item type this is an event fragment, construct a
            <classname>CRingFragmentItem</classname> from that item.
         </para>
         <para>
            For a full description of the methods available, see
            both <link linkend='manpage.cringitem'>CRingItem</link>'s manpage, and
            the METHODS section below.
         </para>
      </refsect1>
      <refsect1>
         <title>
        METHODS
         </title>
         <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                    <methodname>CRingFragmentItem</methodname>
                    <methodparam>
                       <type>uint64_t</type> <parameter>timestamp</parameter>
                    </methodparam>
                    <methodparam>
                       <type>uint32_t</type> <parameter>source</parameter>
                    </methodparam>
                    <methodparam>
                       <type>uint32_t</type> <parameter>payloadSize</parameter>
                    </methodparam>
                    <methodparam>
                       <modifier>const</modifier> <type>void*</type> <parameter>pBody</parameter>
                    </methodparam>
                    <methodparam>
                       <type>uint32_t</type> <parameter>barrier</parameter>
                       <initializer>0</initializer>
                    </methodparam>
                     </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Construct an event fragment ring item.  This constructor
                        is normally used prior to inserting  fragment item
                        into a ring buffer via
                        <classname>CRingItem</classname>::<methodname>commitToRing</methodname>.
                    </para>
                    <para>
                        The parameters are pretty much self explanatory.
                        The default on the <parameter>barrier</parameter>
                        parameter is correct for fragments that are not part
                        of barrier synchronization.
                    </para>
                    <para>
                        The <parameter>timestamp</parameter> parameter is the
                        timestamp that will be associated with the fragment.
                        The <parameter>source</parameter> parameter identifies
                        the source of the fragment.  The <parameter>payloadSize</parameter>
                        parameter is the number of bytes of payload data that
                        will be copied into the ring item from
                        <parameter>pBody</parameter>.  <parameter>barrier</parameter>
                        is non-zero for barrier fragments and zero if
                        'normal' non-barrier fragments.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                    <constructorsynopsis>
                       <methodname>CRingFragmentItem</methodname>
                       <methodparam>
                           <modifier>const</modifier> <type>CRingItem&amp;</type>
                           <parameter>rhs</parameter>
                       </methodparam>
                       <exceptionname>std::bad_cast</exceptionname>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a fragment ring item from a
                        <classname>CRingItem</classname>.  This is normally
                        used after a call from
                        <classname>CRingItem</classname>::<methodname>getFromRing</methodname>
                        that returned a <classname>CRingItem</classname> object
                        whose type is <literal>EVB_FRAGMENT</literal>.
                    </para>
                    <para>
                        The construction then allows your software to get the
                        values of fields of the fragment ring item via
                        the accessor methods described later in this ssection.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                    <constructorsynopsis>
                       <methodname>CRingFragmentItem</methodname>
                       <methodparam>
                           <modifier>const</modifier><type>CRingFragmentItem&amp;</type>
                           <parameter>rhs</parameter>
                       </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Copy constructor for ring fragment items.  If you find
                        yourself doing a lot of copy construction, you should
                        re-think your code and possibly have
                        <classname>CRingFragmentItem</classname> objects
                        passed by pointer or reference to your functions/methods.
                    </para>
                </listitem>
            </varlistentry>
            
            
            
            <varlistentry>
                <term>
            <destructorsynopsis>
               <modifier>virtual</modifier>
               <methodname>~CRingFragmentItem</methodname>
               <void />
            </destructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Destroys a <classname>CRingFragmentItem</classname>
                        and frees any dynamic storage that's associated with
                        it.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                <methodsynopsis>
                   <type>CRingFragmentItem&amp;</type>
                   <methodname>operator=</methodname>
                   <methodparam>
                       <modifier>const</modifier><type>CRingFragmentItem&amp;</type>
                       <parameter>rhs</parameter>
                   </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Assigns the <parameter>rhs</parameter> to
                        <varname>*this</varname>.  Any dynamic storage associated
                        with <varname>this</varname> prior to the assignment
                        is disposed of and it is possible that additional dynamic
                        storage will be allocated to satisfy the needs of the
                        assignment.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                <methodsynopsis>
                   <type>int</type><methodname>operator==</methodname>
                   <methodparam>
                       <modifier>const</modifier> <type>CRingFragmentItem&amp;</type>
                       <parameter>rhs</parameter>
                   </methodparam>
                   <modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Tests for equality.  The payload is not included
                        in the test.  If the timestamp, event source
                        barrier type and payload size are equal the
                        ring items are assumed to be equal.  This is
                        because there are real problems with an experimental
                        setup that allows more than one fragment to have
                        the same timestamp (except for barriers and non
                        timestamped other items).
                    </para>
                </listitem>
             </varlistentry>
            
            <varlistentry>
                <term>
                <methodsynopsis>
                   <type>int</type> <methodname>operator!=</methodname>
                   <methodparam>
                       <modifier>const</modifier><type>CRingFragmentItem&amp;</type>
                       <parameter>rhs</parameter>
                   </methodparam>
                   <modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>true</literal> if
                        <methodname>operator==</methodname> returns
                        <literal>false</literal> and vica versa.
                    </para>
                </listitem>
             </varlistentry>
            
           <varlistentry>
            <term>
                <methodsynopsis>
                    <type>uint64_t</type>
                    <methodname>timestamp</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                <para>
                    Accessor method that returns the value of the item's timestamp.
                </para>
            </listitem>
        </varlistentry>
        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <type>uint32_t</type>
                    <methodname>source</methodname>
                    <void /><modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                 <para>
                     Accessor method that returns the value of the item's
                     source id.
                </para>
            </listitem>
        </varlistentry>
       
        <varlistentry>
            <term>
                <methodsynopsis>
                    <type>size_t</type>
                    <methodname>payloadSize</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                 <para>
                    Accessor mehthod that returns the size of the item's
                    payload. Using this and <methodname>payloadPointer</methodname>
                    allows complete access to the object's payload.
                </para>
            </listitem>
        </varlistentry>
        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>const</modifier>
                    <type>void*</type>
                    <methodname>payloadPointer</methodname>
                    <void /><modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                 <para>
                    Accessor method that returns a pointer to the item's
                    payload.  With this method and
                    <methodname>payloadSize</methodname> you can access the
                    contents of the payload.
                </para>
            </listitem>
         </varlistentry>
         
         <varlistentry>
            <term>
           <methodsynopsis>
               <type>uint32_t</type> <methodname>barrierType</methodname>
               <void /><modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                 <para>
                     Accessor method that returns the barrier type field
                     of the item.
                 </para>
            </listitem>
        </varlistentry>
              
        <!-- 11.0 additions -->
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>typeName</methodname><void />
                <modifier>const</modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a stringified version of the ring item type.  This
                    is <literal>Event fragment</literal>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>toString</methodname>
                <modifier>const</modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a stringified version of the event fragment.
                    This includes inormation in the body h eader and a
                    formatted dump of the payload.  If the payload is recognizable
                    as a ring item it is dumped as a formatted ring item, otherwise
                    a straight byte by byte hex dump of the payload is performed.
                </para>
            </listitem>
        </varlistentry>
        
        <!-- end of 11.0 additions -->

                
         </variablelist>
      </refsect1>
    </refentry>
	 <refentry id="manpage.cunknownfragment">
          <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
        <personblurb><para></para></personblurb>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
       <refmeta>
          <refentrytitle>CUnknownFragment</refentrytitle>
          <manvolnum>3daq</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
       </refmeta>
       <refnamediv>
          <refname>CUnknownFragment</refname>
          <refpurpose>Event fragment likley not containing a ring item</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <programlisting>
#include &lt;CUnknownFragment.h&gt;
        </programlisting>
        <classsynopsis>

            <ooclass><classname>CRingFragment : public CRingItem</classname></ooclass>
	</classsynopsis>
	<synopsis>
            <constructorsynopsis>
                <methodname>CUnknownFragment</methodname>
                <methodparam>
                    <type>uint64_t</type><parameter>timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>sourceid</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>barrier</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>size</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type><parameter>pPayload</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CUnknownFragment</methodname>
                <void />
            </destructorsynopsis>
            <constructorsynopsis>
                <methodname>CUnknownFragment</methodname>
                <methodparam>
                    <modifier>const</modifier><type> CUnknownFragment&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CUnknownFragment</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CRingItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <methodsynopsis>
                <type>CUnknownFragment&amp;</type><methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CUnknownFragment&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type><methodname> operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CUnknownFragment&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type><methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CUnknownFragment&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type><methodname>typeName</methodname>
                <void /><modifier> const</modifier>
            </methodsynopsis>
}
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This class is a thin wrapper that derived from
            <link linkend='manpage.cringfragmentitem'>
                <classname>CRingFragmentItem</classname></link>.
                There are only two differences between that class and this:
          </para>
          <orderedlist>
            <listitem>
                <para>
                    The ring item type is set to <literal>EVB_UNKNOWN_PAYLOAD</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    The <methodname>typeName</methodname> method returns the string:
                    <literal>Fragment with unknown payload</literal>
                </para>
            </listitem>
          </orderedlist>
                    
       </refsect1>
     </refentry>     
	 <refentry id="manpage.cdataformatitem">
          <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
                <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
       <refmeta>
          <refentrytitle>CDataFormatItem</refentrytitle>
          <manvolnum>3daq</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
       </refmeta>
       <refnamediv>
          <refname>CDataFormatItem</refname>
          <refpurpose>Describe the format of a stream of ringitems.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <programlisting>
#include &lt;CDataFormatItem.h&gt;
        </programlisting>
        <classsynopsis>
            <ooclass><classname>CDataFormatItem : public CRingItem</classname></ooclass>
	</classsynopsis>
       <synopsis>
            <constructorsynopsis>
                <methodname>CDataFormatItem</methodname><void />
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CDataFormatItem</methodname><void />
            </destructorsynopsis>
            <constructorsynopsis>
                <methodname>CDataFormatItem</methodname>
                <methodparam>
                    <modifier>const</modifier><type> CDataFormatItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CDataFormatItem</methodname>
                <methodparam>
                    <modifier>const</modifier><type> CRingItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <methodsynopsis>
                <type>CDataFormatItem&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CDataFormatItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>CDataFormatItem&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CRingItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CDataFormatItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CDataFormatItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint16_t</type><methodname>getMajor</methodname><void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint16_t</type><methodname>getMinor</methodname><void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>typeName</methodname><void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>toString</methodname><void /><modifier>const</modifier>
            </methodsynopsis>
    };
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <note>
            <title>NOTE:</title>
            <para>This item is new as of version 11.0</para>
          </note>
          <para>
            The <classname>CDataFormatItem</classname> encapsulates a
            Ring item of type <literal>RING_FORMAT</literal>.  This ring item
            provides information about the format of the stream of ring items to
            follow.  It should be emitted by producers at the beginning of each
            coherent stream (run), so that downstream clients know how to parse
            the ring items that follow.
          </para>
          <para>
            The item contains the major and minor version of the least recently
            released version of NSCDAQ capable of processing the item completely.
          </para>
          <para>
            In NSCLDAQ-12.0, this has been updated to contain
            12.0 reflecting the addition of original source id
            fields in scaler, state change, event count and text
            items.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CDataFormatItem</methodname><void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a ring format item.  The major and minor versions
                        of the format are set to the values of
                        <varname>FORMAT_MAJOR</varname> and
                        <varname>FORMAT_MINOR</varname> in <filename>DataFormat.h</filename>
                        for the version of the
                        <filename>libdataformat.so</filename>
                        library the program has loaded.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <destructorsynopsis>
                        <modifier>virtual</modifier>
                        <methodname>~CDataFormatItem</methodname><void />
                    </destructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Destructor
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CDataFormatItem</methodname>
                        <methodparam>
                            <modifier>const</modifier><type> CDataFormatItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Copy constructs another <classname>CDataForamtItem</classname>
                        making an object that is identical to
                        <parameter>rhs</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CDataFormatItem</methodname>
                        <methodparam>
                            <modifier>const</modifier><type> CRingItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <exceptionname>std::bad_cast</exceptionname>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a <classname>CDataFormatItem</classname>
                        by copying a <classname>CRingItem</classname> that is
                        the <parameter>rhs</parameter> parameter.  If
                        <parameter>rhs</parameter> is not a
                        <literal>RING_FORMAT</literal> type ring item a
                        <classname>std::bad_cast</classname> exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>CDataFormatItem&amp;</type>
                        <methodname>operator=</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CDataFormatItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Assignment operator.  This allows one <classname>CDataFormatItem</classname>
                        to be assigned from another right hand side (<parameter>rhs</parameter>).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>CDataFormatItem&amp;</type>
                        <methodname>operator=</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CRingItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <exceptionname>std::bad_cast</exceptionname>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Assignment operator from a <parameter>rhs</parameter> operand
                        that is an undifferentiated <classname>CRingItem</classname>.
                        If the <parameter>rhs</parameter>'s type is no
                        <literal>RING_FORMAT</literal>,
                        a <classname>std::bad_cast</classname> exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>int</type>
                        <methodname>operator==</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CDataFormatItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Equality comparison.  The <parameter>rhs</parameter> must
                        be bit by bit equal to <varname>*this</varname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>int</type>
                        <methodname>operator!=</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CDataFormatItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns nonzero if <methodname>operator==</methodname> returns
                        <literal>0</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint16_t</type><methodname>getMajor</methodname><void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the major version number field of the ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint16_t</type><methodname>getMinor</methodname><void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the minor version number field of the ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier><type>std::string</type>
                        <methodname>typeName</methodname><void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a text string that represents the item type
                        of the ring itme.  This is
                        <literal>Ring Item format version</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier><type>std::string</type>
                        <methodname>toString</methodname><void /><modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Return a textual, human readable bit of text that
                        dumps information about the ring item.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>         
	 <refentry id="manpage.cglomparameters">
          <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
                <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
       <refmeta>
          <refentrytitle>CGlomParameters</refentrytitle>
          <manvolnum>3daq</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
       </refmeta>
       <refnamediv>
          <refname>CGlomParameters</refname>
          <refpurpose>Reports event building parameters.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
            <programlisting>
#include &lt;CGlomParameters.h&gt;
            </programlisting>
        
        <classsynopsis>
            <ooclass><classname>CGlomParameters  : public CRingItem </classname></ooclass>
	</classsynopsis>
	<synopsis>
            <constructorsynopsis>
                <methodname>CGlomParameters</methodname>
                <methodparam>
                    <type>uint64_t</type> <parameter>interval</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>isBuilding</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>tsPolicy</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CGlomParameters</methodname>
                <void />
            </destructorsynopsis>
            <constructorsynopsis>
                <methodname>CGlomParameters</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CGlomParameters&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CGlomParameters</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CRingItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <methodsynopsis>
                <type>CGlomParameters&amp;</type><methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CGlomParameters&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type><methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CGlomParameters&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type><methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CGlomParameters&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint64_t</type><methodname>coincidenceTicks</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type><methodname>isBuilding</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>TimestampPolicy</type><methodname>timestampPolicy</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>std::string</type>
                <methodname>typeName</methodname> <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>toString</methodname><void />
                <modifier>const</modifier>
            </methodsynopsis>

};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <application>glom</application> is a stage in the event builder pipeline
            that actually glues event fragments in close temporal proximity
            together into events.  It is important for consumers of data to know
            the parameters that <application>glom</application> uses to know
            how it should operate.  Therefore <application>glom</application> emits
            a ring item of type<literal>EVB_GLOM_INFO</literal> describing this information.
            The <classname>CGlomParameters</classname> class provides a C++
            class the wraps this ring item.
          </para>
          <para>
            See METHODS for detailed information about how to use this class.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGlomParameters</methodname>
                        <methodparam>
                            <type>uint64_t</type> <parameter>interval</parameter>
                        </methodparam>
                        <methodparam>
                            <type>bool</type> <parameter>isBuilding</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGlomParameters::TimestampPolicy</type>
                            <parameter>timestampPolicy</parameter> 
                            <modifier>const</modifier>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs the ring item. object.  The contents of
                        the ring item are goverend by <parameter>isBuilding</parameter>
                        which should be true if glom is running in builder mode,
                        and <parameter>interval</parameter>, which is only
                        meaningful in build mode and represents the event
                        coincidence interval in timestamp ticks.  That is
                        given and event fragment a time t, All fragments
                        up until <literal>t+interval</literal> will be
                        glommed into a single event at which point glom
                        will start again with the next event found.
                    </para>
                    <para>
                        <application>glom</application> can also run in
                        non-building mode.  That mode means that each
                        fragment results in its own output event.
                    </para>
                    <para>
                        The <parameter>timestampPolicy</parameter> argument sets the
                        timestamp policy used by this version of glom and
                        can be one of <literal>CGlomParameters::first</literal>,
                        <literal>CGlomParametesr::last</literal> or
                        <literal>CGlomParameters::average</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <destructorsynopsis>
                        <modifier>virtual</modifier>
                        <methodname>~CGlomParameters</methodname>
                        <void />
                    </destructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Destructor
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGlomParameters</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CGlomParameters&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Copy constructor of a glom object.   Constructs a new object
                        that is an exact duplicate of <parameter>rhs</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGlomParameters</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CRingItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <exceptionname>std::bad_cast</exceptionname>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a <classname>CRingItem</classname> that is a
                        duplicate of the arbitrary ring item <parameter>rhs</parameter>.
                        If <parameter>rhs</parameter> is not in fact a
                        <classname>CGLomParameters</classname> object a
                        <classname>std::bad_cast</classname> exception will
                        be thron.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>CGlomParameters&amp;</type><methodname>operator=</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CGlomParameters&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Assignment operator.  The object on the left hand
                        side of an assignment becomes an exact duplicate of
                        <parameter>rhs</parameter> (the right hand side object).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>int</type><methodname>operator==</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CGlomParameters&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Compares the object on the left hand side of the
                        <literal>==</literal> operator to <parameter>rhs</parameter>.
                        A nonzero value is returned if the two objects can be
                        said to be equal.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>int</type><methodname>operator!=</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CGlomParameters&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns nonzero if <methodname>operator==</methodname> would
                        return zero.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint64_t</type><methodname>coincidenceTicks</methodname>
                        <void /><modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of ticks that define a coincidence
                        interval for building an event.  This only has meaning
                        if <methodname>isBuilding</methodname> returns
                        <literal>true</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>bool</type><methodname>isBuilding</methodname>
                        <void /><modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>true</literal> if
                        <application>glom</application> was in event building
                        mode <literal>false</literal> otherwise.  The
                        value returned from <methodname>coincidenceTicks</methodname>
                        is only meaningful if this method returns
                        <literal>true</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <type>CGlomParametrs::TimestampPolicy</type>
                    <methodname>timestampPolicy</methodname>
                    <void /><modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the timestamp policy field.  This will
                        See the documentation of the constructor for information
                        about the possible values this can have.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier> <type>std::string</type>
                        <methodname>typeName</methodname> <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a string version of the ring item type
                        associated with this item.  This is:
                        <literal>Glom Parameters</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier><type>std::string</type>
                        <methodname>toString</methodname><void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a human readable string representation
                        of the object.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>
    <refentry id="manpage.cabnormalenditem">
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
            <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
      <refmeta>
         <refentrytitle>CAbnormaEndItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
             <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>CAbnormalEndItem</refname>
         <refpurpose>Abnormal end of run.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
       <synopsis>
           <ooclass><classname>CAbnormalEnditem</classname></ooclass>
          <constructorsynopsis>
         <methodname>CAbnormalEndItem</methodname>
         <void />
         <exceptionname></exceptionname>
          </constructorsynopsis>
          <constructorsynopsis>
            <methodname>CAbnormalEndItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CAbnormalEndItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
          </constructorsynopsis>
          <constructorsynopsis>
            <methodname>CAbnormalEndItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
          </constructorsynopsis>
          <methodsynopsis>
         <type>CAbnormalEndItem&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CAbnormalEndItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
          </methodsynopsis>
          <methodsynopsis>
              <modifier></modifier>
              <type>int</type>
              <methodname>operator==</methodname>
              <methodparam>
                <modifier>const</modifier><type>CAbnormalEndItem&amp;</type>
                <parameter>rhs</parameter>
              </methodparam>
              <modifier>const</modifier>
          </methodsynopsis>
          <methodsynopsis>
              <modifier></modifier>
              <type>int</type>
              <methodname>operator==</methodname>
              <methodparam>
                <modifier>const</modifier> <type>CRingitem&amp;</type>
                <parameter>rhs</parameter>
              </methodparam>
              <modifier>const</modifier>
          </methodsynopsis>
          <methodsynopsis>
              <modifier></modifier>
              <type>int</type>
              <methodname>operator!=</methodname>
              <methodparam>
                <modifier>const</modifier> <type>CAbnormalEndItem&amp;</type>
                <parameter>rhs</parameter>
              </methodparam>
              <modifier>const</modifier>
          </methodsynopsis>
          <methodsynopsis>
              <modifier></modifier>
              <type>int</type>
              <methodname>operator!=</methodname>
              <methodparam>
                <modifier>const</modifier><type>CRingItem&amp;</type>
                <parameter>rhs</parameter>
              </methodparam>
              <modifier>const</modifier>
          </methodsynopsis>
          <methodsynopsis>
              <modifier>virtual </modifier>
              <type>std::string </type>
              <methodname>typeName</methodname>
              <void />
              <modifier>const</modifier>
          </methodsynopsis>
          <methodsynopsis>
              <modifier>virtual </modifier>
              <type>std::string </type>
              <methodname>toString() </methodname>
              <modifier>const</modifier>
          </methodsynopsis>  
};
       </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>DESCRIPTION</title>
         <para>
            Provides a class for objects that represent abnormal end of run
            ring items.
         </para>
      </refsect1>
      <refsect1>
         <title>
        METHODS
         </title>
         <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                   <methodname>CAbnormalEndItem</methodname>
                   <void />
                   <exceptionname></exceptionname>
                    </constructorsynopsis>
                    
                </term>
                <listitem>
                    <para>
                        Default constructor for abnormal end items.
                        In most applications, this is the only
                        constructor you ever need.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                      <methodname>CAbnormalEndItem</methodname>
                      <methodparam>
                          <modifier>const</modifier> <type>CAbnormalEndItem&amp;</type>
                          <parameter>rhs</parameter>
                      </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a ring item that is a duplicate of the <parameter>rhs</parameter>
                        argrument.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                       <methodname>CAbnormalEndItem</methodname>
                       <methodparam>
                           <modifier>const</modifier> <type>CRingItem&amp;</type>
                           <parameter>rhs</parameter>
                       </methodparam>
                     </constructorsynopsis>           
                </term>
                <listitem>
                    <para>
                        Constructs an abnormal end item from an arbitrary
                        ring item reference.  The only requirement to avoid an
                        exception is that <parameter>rhs</parameter> has the type
                        <literal>ABNORMAL_ENDRUN</literal>.  If this is not the case
                        a <classname>std::bad_cast</classname> exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
           <varlistentry>
               <term>
                <methodsynopsis>
                  <type>CAbnormalEndItem&amp;</type>
                  <methodname>operator=</methodname>
                  <methodparam>
                      <modifier>const</modifier> <type>CAbnormalEndItem&amp;</type>
                      <parameter>rhs</parameter>
                  </methodparam>
                </methodsynopsis>
               </term>
               <listitem>
                   <para>
                    Assigns this to the contents of <parameter>rhs</parameter>.
                   </para>
               </listitem>
           </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int</type>
                        <methodname>operator==</methodname>
                        <methodparam>
                          <modifier>const</modifier><type>CAbnormalEndItem&amp;</type>
                          <parameter>rhs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>

                </term>
                <listitem>
                    <para>
                        Returns <literal>1</literal> because there is no payload
                        in abnormal end run item to differentiate one from another.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int</type>
                        <methodname>operator==</methodname>
                        <methodparam>
                          <modifier>const</modifier> <type>CRingitem&amp;</type>
                          <parameter>rhs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>1</literal> if <parameter>rhs</parameter>
                        is an abnormal end ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int</type>
                        <methodname>operator!=</methodname>
                        <methodparam>
                          <modifier>const</modifier> <type>CAbnormalEndItem&amp;</type>
                          <parameter>rhs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int</type>
                        <methodname>operator!=</methodname>
                        <methodparam>
                          <modifier>const</modifier><type>CRingItem&amp;</type>
                          <parameter>rhs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>

                </term>
                <listitem>
                    <para>
                        Returns the logical negation of the corresponding
                        <methodname>operator==</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>typeName</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a string that describes the type of the
                        ring item.  In this case the string is
                        <literal>Abnormal End</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::string </type>
                        <methodname>toString() </methodname>
                        <modifier>const</modifier>
                    </methodsynopsis>  

                </term>
                <listitem>
                    <para>
                        Returns a string that represents the contents
                        of the ring item.  In this case, with no
                        payload, the result of
                        <methodname>typeName</methodname> is returned.
                    </para>
                </listitem>
            </varlistentry>
            


         </variablelist>
      </refsect1>
    </refentry>     
    <refentry id="manpage.cringselectionpredicate">
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
            <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
      <refmeta>
         <refentrytitle>CRingSelectionPredicate</refentrytitle>
         <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>CRingSelectionPredicate</refname>
	 <refpurpose>Base class for predicates that select items from
            ring buffers.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CRingSelectionPredicate.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CRingSelectionPredicate</classname></ooclass>
	 </classsynopsis>
	 <synopsis>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>types</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>bool*</type> <parameter>sample</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CRingSelectionPredicate</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CRingSelectionPredicate&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                                             <methodname>operator()</methodname>
                <methodparam>
                    <type>CRingBuffer&amp;</type> <parameter>ring</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                                             <methodname>selectThis</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>type</parameter>
                </methodparam>
                <modifier>= 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>selectItem</methodname>
                <methodparam><type>CRingBuffer&amp;</type><parameter>ring</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>void</type> <methodname>addSelectionItem</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>sample</parameter><initializer> false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>SelectionMapIterator</type> <methodname>find</methodname>
                <methodparam><type>uint32_t</type> <parameter>type</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>SelectionMapIterator</type>
                <methodname>end</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>uint32_t</type> <methodname>longswap</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>input</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>void</type> <methodname>addSelectionItems</methodname>
                <methodparam>
                    <type>std::vector&lt;ItemType&gt;</type> <parameter>selections</parameter>
                </methodparam>
            </methodsynopsis>
};
         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CRingSelectionPredicate</classname> is an abstract base
            class that can be subclassed to create specific predicates to selectively
            grab items from a ring buffer via
            <classname>CRingItem</classname>::<methodname>getFromRing</methodname>.
         </para>
         <para>
            The base class provides a set of item types and flags, and functions
            to maintain that set.  The meaning of those are up to the specific concrete
            predicate.  The <methodname>operator()</methodname> is provided that
            is sufficient for predicates that treat the flag as a request to
            sample data of that type by checking if a type is acceptable or not
            via the pure virtual function <methodname>selectThis</methodname>.
         </para>
      </refsect1>
      <refsect1>
         <title>
           Member functions
         </title>
         <refsect2>
            <title>Public members</title>
           <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <void />
            </constructorsynopsis>
            <para>
                Default constructor for a the base class, the list of
                type/flag pairs remains empty.
            </para>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>types</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Constructs the base class with
                <parameter>nType</parameter> type/flag pairs where
                <parameter>types</parameter> is an array of types and all of
                the flags are set to be <literal>false</literal>.
            </para>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>bool*</type> <parameter>sample</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Constructs a base class as above, however the state of the
                flag that corresponds to each <parameter>type</parameter>
                is specfied in the corresponding element of <parameter>sample</parameter>.
            </para>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Provides support for copy construction of an object derived
                from <classname>CRingSelectionPredicate</classname> by copying the
                type/flag pairs from <parameter>rhs</parameter>.
            </para>

            <methodsynopsis>
                <type>CRingSelectionPredicate&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Provides support for assignment in selection predicates, by
                assigning the type/flag set of <parameter>rhs</parameter> to
                those of the object.
            </para>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Provides support for equality comparison of
                selection predicates by comparing the type/flag pairs of
                <parameter>rhs</parameter> to those of the object.
            </para>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Provides support for inequality comparisons of selection predicates
                by comparing for equality and returning the boolean inverse of
                the result.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                                             <methodname>operator()</methodname>
                <methodparam>
                    <type>CRingBuffer&amp;</type> <parameter>ring</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Provides a default predicate call for
                <classname>CRingBuffer</classname>::<methodname>blockWhile</methodname>.
                The default action is to block until an item is in the ring.
                when an item is in the ring, its type is retrieved and passed to
                <methodname>selectThis</methodname>.  If that function returns
                <literal>true</literal> the item is skipped.  If
                <literal>false</literal> is returned, and either the item type
                is not in the item list or is in the item list but with its flag
                false, then <literal>false</literal> is returned, ending the
                block and allowing the caller to retrieve the selected item.
                If the item is in the list an has a true flag, the item is skipped
                if it is not the most recently inserted item in the ring, otherwise
                blocking is terminated.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                                             <methodname>selectThis</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>type</parameter>
                </methodparam>
                <modifier>= 0</modifier>
            </methodsynopsis>
            <para>
                This is a pure virtual member that must be implemented by
                concrete classes.  <parameter>type</parameter> is the item type
                of an item in the ring buffer.  The function should return
                <literal>true</literal> to skip the item,and
                <literal>false</literal> if the item is of an acceptable type.
                See, however the description of
                <methodname>operator()</methodname>
                to see how that item type's flag can modify the interpretation
                of this return value.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>selectItem</methodname>
                <methodparam><type>CRingBuffer&amp;</type> <parameter>ring</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                This member function interacts with the ring buffer
                <parameter>ring</parameter> to block the caller, skipping
                items inserted in the ring until one that matches the predicate
                is available. 
            </para>
            <para>
                Normally, this is intended to be called from
                <classname>CRingItem</classname>::<methodname>getFromRing</methodname>.
            </para>
         </refsect2>
         <refsect2>
            <title>Protected members</title>
            <para>
                Protected member functions are utilities that area
                available to derived classes.  Note that since the
                <classname>CRingSelectionPredicate</classname> class is
                an abstract base class, there can never be instances of it.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>void</type> <methodname>addSelectionItem</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>sample</parameter><initializer> false</initializer>
                </methodparam>
            </methodsynopsis>
            <para>
                Adds an item <parameter>type</parameter> and <parameter>sample</parameter>
                flag to the set of type/flag pairs maintained by this base class.
                As the actual interpretation of this list is partially up to
                the <methodname>selectThis</methodname> method, this is not exposed
                to the public. Concrete class implementations are expected to provide
                an appropriately named member function that delegates to this.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>SelectionMapIterator</type> <methodname>find</methodname>
                <methodparam><type>uint32_t</type> <parameter>type</parameter></methodparam>
            </methodsynopsis>
            <para>
                Locates <parameter>type</parameter> in the list of type/flag pairs.
                Returns a pointer like object <type>SelectionMapIterator</type>.
                This 'points' to a <type>std::pair&lt;uint32_t, ItemType&gt;</type>.
                If the item is not found, the iterator will compare as
                <literal>==</literal> to the value returned from
                <methodname>end</methodname>.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>SelectionMapIterator</type>
                <methodname>end</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns the value that <methodname>find</methodname> returns if
                the item type searched for is not found.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>uint32_t</type> <methodname>longswap</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>input</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Swaps bytes in the longword <parameter>input</parameter> and
                returns the result.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>void</type> <methodname>addSelectionItems</methodname>
                <methodparam>
                    <type>std::vector&lt;ItemType&gt;</type> <parameter>selections</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Calls <methodname>addSelectionItem</methodname> once for each item
                in <parameter>selections</parameter>.
            </para>
         </refsect2>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            While the class does not export any public data or data types,
            it does provide several protected data types that are important
            to know about if you are deriving a class from
            <classname>CRingSelectionPredicate</classname>.  All of the type
            names are in the scope of <classname>CRingSelectionPredicate</classname>::.
         </para>
         <variablelist>
            <varlistentry>
                <term><structname>ItemType</structname></term>
                <listitem>
                    <para>
                        This is the structure that holds type/value pairs.
                        It contains the fields
                        <structfield>s_sampled</structfield>, which is the flag, and
                        <structfield>s_itemType</structfield>, which is the item
                        type.
                    </para>
                    <para>
                        While <structfield>s_sampled</structfield> is intended
                        to convey that tiems of that <structfield>s_itemType</structfield>
                        should be sampled, this is not required if the concrete class
                        overrides <methodname>operator()</methodname>
                    </para>
                    <para>
                        This struct supports equality and inequality comparision.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>SelectionMap</type></term>
                <listitem>
                    <para>
                        This is a typedef for
                        <type>std::map&lt;uint32_t, ItemType&gt;</type>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>SelectionMapIterator</type></term>
                <listitem>
                    <para>
                        This is a typedef for
                        <type>SelectionMap::iterator</type>.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect1>
   </refentry>
    <refentry id="manpage.callbutpredicate">
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
            <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
      <refmeta>
         <refentrytitle>CAllButPredicate</refentrytitle>
         <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>CAllButPredicate</refname>
	 <refpurpose>Select all ring items except some.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CAllButPredicate&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CAllButPredicate</classname></ooclass>
	 </classsynopsis>
	 <synopsis>
            <constructorsynopsis>
                <methodname>CAllButPredicate</methodname>
                <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CAllButPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>types</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CAllButPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>types</parameter>
                </methodparam>
                <methodparam>
                    <type>bool*</type> <parameter>sample</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CAllButPredicate</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CAllButPredicate&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CAllButPredicate</methodname> <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CAllButPredicate&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CAllButPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CAllButPredicate&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CAllButPredicate&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addExceptionType</methodname>
                <methodparam>
                    <type>uint32_t</type>
                    <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>sample</parameter><initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type> <methodname>selectThis</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>type</parameter>
                </methodparam>
            </methodsynopsis>
}
         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CAllButPredicate</classname> is a ring selection predicate
            whose list of type/flag pairs are treated as exceptions to the rule
            that all types are wanted with no sampling.
         </para>
         <para>
            If an item is in the exception list and has the flag false, it will
            be skipped by the predicate when encountered in the ring buffe while
            blocking on the predicate.  If an item is in the exception ilst, but
            the flag is true, the item will be skipped unless it's the last one
            in the ring buffer.  Any item not in the list is accepted.
         </para>
      </refsect1>
      <refsect1>
        <title>
            Public member functions
        </title>
            <constructorsynopsis>
               <methodname>CAllButPredicate</methodname>
               <void />
           </constructorsynopsis>
            <para>
                Constructs the predicate.  When constructed in this way,
                all ring buffer item types are accepted without sampling unless
                the application makes a subsequent call to
                <methodname>addExceptionType</methodname>.
            </para>
           <constructorsynopsis>
               <methodname>CAllButPredicate</methodname>
               <methodparam>
                   <type>unsigned int</type> <parameter>nType</parameter>
               </methodparam>
               <methodparam>
                   <type>uint32_t*</type> <parameter>types</parameter>
               </methodparam>
           </constructorsynopsis>
           <para>
            Constructs the predicate so that the <parameter>nType</parameter>
            parameters in the array <parameter>types</parameter> of item types
            are not skipped by the predicate.
           </para>
           <constructorsynopsis>
               <methodname>CAllButPredicate</methodname>
               <methodparam>
                   <type>unsigned int</type> <parameter>nType</parameter>
               </methodparam>
               <methodparam>
                   <type>uint32_t*</type> <parameter>types</parameter>
               </methodparam>
               <methodparam>
                   <type>bool*</type> <parameter>sample</parameter>
               </methodparam>
           </constructorsynopsis>
           <para>
            Constructs the predicate so that the <parameter>nType</parameter>
            exceptions described by <parameter>types</parameter> and
            <parameter>sample</parameter> are either skipped (if their
            <parameter>sample</parameter> element is <literal>false</literal>,
            or sampled if their <parameter>sample</parameter> element is true.
           </para>
           <constructorsynopsis>
               <methodname>CAllButPredicate</methodname>
               <methodparam>
                   <modifier>const</modifier> <type>CAllButPredicate&amp;</type> <parameter>rhs</parameter>
               </methodparam>
           </constructorsynopsis>
           <para>
            Supports copy construction of the predicate.
           </para>
           <methodsynopsis>
               <type>CAllButPredicate&amp;</type>
               <methodname>operator=</methodname>
               <methodparam>
                   <modifier>const</modifier> <type>CAllButPredicate&amp;</type>
                                              <parameter>rhs</parameter>
               </methodparam>
           </methodsynopsis>
           <para>
            Supports assignment of the predicate.
           </para>
           <methodsynopsis>
               <type>int</type> <methodname>operator==</methodname>
               <methodparam>
                   <modifier>const</modifier> <type>CAllButPredicate&amp;</type> <parameter>rhs</parameter>
               </methodparam>
               <modifier>const</modifier>
           </methodsynopsis>
           <para>
            Supports testing for equality of the predicate with another.
           </para>
           <methodsynopsis>
               <type>int</type> <methodname>operator!=</methodname>
               <methodparam>
                   <modifier>const</modifier> <type>CAllButPredicate&amp;</type> <parameter>rhs</parameter>
               </methodparam>
               <modifier>const</modifier>
           </methodsynopsis>
           <para>
            Supports testing for inequality between the predicate and another.
           </para>
           <methodsynopsis>
               <type>void</type> <methodname>addExceptionType</methodname>
               <methodparam>
                   <type>uint32_t</type>
                   <parameter>type</parameter>
               </methodparam>
               <methodparam>
                   <type>bool</type> <parameter>sample</parameter><initializer>false</initializer>
               </methodparam>
           </methodsynopsis>
            <para>
                Adds an excpetion to the list of exceptions to the rule that
                all item types are accepted without sampling.  If
                <parameter>sample</parameter> is <literal>false</literal>,
                ring items of type <parameter>type</parameter> will be skipped.
                If <parameter>sample</parameter> is <literal>true</literal>
                Items of that type will be sampled.
            </para>
            <para>
                Specifying a type already in the exculsion list will
                overwrite the existing definition (e.g. you can change
                the state of the sampling flag).  It is not possible, however
                to remove an entry from the exception list.
            </para>
      </refsect1>

   </refentry>
    <refentry id="manpage.cdesiredtypespredicate">
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
            <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
      <refmeta>
         <refentrytitle>CDesiredTypesPredicate</refentrytitle>
         <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>CDesiredTypesPredicate</refname>
	 <refpurpose>Only accept specified ring item types.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CDesiredTypesPredicate&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CDesiredTypesPredicate</classname></ooclass>
	 </classsynopsis>
	 <synopsis>
            <constructorsynopsis>
                <methodname>CDesiredTypesPredicate</methodname> <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CDesiredTypesPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>types</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CDesiredTypesPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>types</parameter>
                </methodparam>
                <methodparam>
                    <type>bool*</type> <parameter>sample</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CDesiredTypesPredicate</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CDesiredTypesPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CDesiredTypesPredicate</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CDesiredTypesPredicate&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CDesiredTypesPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CDesiredTypesPredicate&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CDesiredTypesPredicate&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>addDesiredType</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>sample</parameter><initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
}
         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The <classname>CDesiredTypes</classname> predicate is a ring item
            type selector that skips all ring item types except those in its
            item/flag list.  The flag determines if the data for that item type are
            sampled (if <literal>true</literal>) or if all items of that type are
            accepted (if <literal>false</literal>).
         </para>
         <para>
            <methodname>addDesiredType</methodname> is used to build up the list
            of desired item types. 
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CDesiredTypesPredicate</methodname> <void />
        </constructorsynopsis>
        <para>
            Constructs the predicate with an empty list of desired types.
            If no types are added via <methodname>addDesiredType</methodname>,
            the predicate will skip all of the data in the ring
            (not very useful).
        </para>  
        <constructorsynopsis>
            <methodname>CDesiredTypesPredicate</methodname>
            <methodparam>
                <type>unsigned int</type> <parameter>nType</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t*</type> <parameter>types</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs the predicate with <parameter>nType</parameter> types
            in its acceptance list.  These types are specified in the
            array <parameter>types</parameter>.  The sample flags on all of these
            types is set to <literal>false</literal>
            so that all items of these types are accepted.
        </para>
        <constructorsynopsis>
            <methodname>CDesiredTypesPredicate</methodname>
            <methodparam>
                <type>unsigned int</type> <parameter>nType</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t*</type> <parameter>types</parameter>
            </methodparam>
            <methodparam>
                <type>bool*</type> <parameter>sample</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Same as the previous constructor, however the sample flags for
            each item type are explicitly specified by the
            <parameter>sample</parameter>
            array.
        </para>
        <constructorsynopsis>
            <methodname>CDesiredTypesPredicate</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CDesiredTypesPredicate&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Provides support for creating a new predicate by copying a previously
            existing one.
        </para>
        <methodsynopsis>
            <type>CDesiredTypesPredicate&amp;</type> <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CDesiredTypesPredicate&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides support for replacing the acceptance list of an existing
            object with the acceptance list of <parameter>rhs</parameter>.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CDesiredTypesPredicate&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Provides a mechanism for comparing two predicates for equality.
        </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CDesiredTypesPredicate&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Provides the mechanism for comparing two predicates for inequality.
        </para>
        <methodsynopsis>
            <type>void</type>
            <methodname>addDesiredType</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>sample</parameter><initializer>false</initializer>
            </methodparam>
        </methodsynopsis>
        <para>
            Adds a type to the set of item types that  may be accepteed by the
            predicate.  <parameter>type</parameter> is the type id, and
            <parameter>sample</parameter> the flag that determines if the types
            are accepted in sampled mode.
        </para>
      </refsect1>
   </refentry>
    	 <refentry id="ref-dataformat">
          <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
                <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
           <refmeta>
              <refentrytitle id='ref-dataformat-title'>DataFormat.h</refentrytitle>
              <manvolnum>3daq</manvolnum>
              <refmiscinfo class='empty'></refmiscinfo>
           </refmeta>
           <refnamediv>
              <refname>DataFormat.h</refname>
              <refpurpose>Format of ring items.</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>


<programlisting>
    
#include &lt;DataFormat.h&gt;

typedef struct _RingItemHeader {
  uint32_t     s_size;
  uint32_t     s_type;
} RingItemHeader, *pRingItemHeader;


typedef struct _BodyHeader {
  uint32_t   s_size;		
  uint64_t   s_timestamp;
  uint32_t   s_sourceId;
  uint32_t   s_barrier;   
} BodyHeader, *pBodyHeader;




typedef struct _RingItem {
  RingItemHeader s_header;
  union {
    struct {
      uint32_t s_empty;
      uint8_t  s_body[0];
    } u_noBodyHeader;
    struct {
        BodyHeader s_bodyHeader;
        uint8_t s_body[0];
    } u_hasBodyHeader;
  } s_body;
} RingItem, *pRingItem;


typedef struct _StateChangeItemBody {
  uint32_t        s_runNumber;
  uint32_t        s_timeOffset;
  uint32_t        s_Timestamp;
  uint32_t        s_offsetDivisor;
  uint32_t        s_originalSid;     // Added in V12.0
  char            s_title[TITLE_MAXSIZE+1];
} StateChangeItemBody, *pStateChangeItemBody;

typedef struct _StateChangeItem  {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t            s_empty;      
            StateChangeItemBody s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader          s_bodyHeader;
            StateChangeItemBody s_body;
        } u_hasBodyHeader;
    } s_body;
    
} StateChangeItem, *pStateChangeItem;


typedef struct _ScalerItemBody {
  uint32_t        s_intervalStartOffset;
  uint32_t        s_intervalEndOffset;
  uint32_t        s_timestamp;
  uint32_t        s_intervalDivisor; 
  uint32_t        s_scalerCount;
  uint32_t        s_isIncremental;
  uint32_t        s_originalSid;    // Added in v12.0
  uint32_t        s_scalers[0];
} ScalerItemBody, *pScalerItemBody;

typedef struct _ScalerItem {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t       s_empty;          
            ScalerItemBody s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader     s_bodyHeader;
            ScalerItemBody s_body;
        } u_hasBodyHeader;
    } s_body;
} ScalerItem, *pScalerItem;

typedef struct _TextItemBody {
  uint32_t       s_timeOffset;
  uint32_t       s_timestamp;
  uint32_t       s_stringCount;
  uint32_t       s_offsetDivisor;
  uint32_t       s_originalSid;     // Added in V12.0
  char           s_strings[0];
} TextItemBody, *pTextItemBody;

typedef struct _TextItem {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t       s_empty; 
            TextItemBody   s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader     s_bodyHeader;
            TextItemBody   s_body;
        } u_hasBodyHeader;
    } s_body;
} TextItem, *pTextItem;



typedef struct _PhysicsEventItem {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t      s_empty;
            uint16_t      s_body[];  
        } u_noBodyHeader;
        struct {
            BodyHeader    s_bodyHeader;
            uint16_t      s_body[0];
        } u_hasBodyHeader;
    } s_body;
} PhysicsEventItem, *pPhysicsEventItem;


typedef struct __PhysicsEventCountItemBody {
  uint32_t       s_timeOffset;
  uint32_t       s_offsetDivisor;
  uint32_t       s_timestamp;
  uint32_t        s_originalSid;    // Added in V12.0
  uint64_t       s_eventCount;
} PhysicsEventCountItemBody, *pPhysicsEventCountItemBody;

typedef struct _PhysicsEventCountItem {
    RingItemHeader   s_header;
    union {
        struct {
            uint32_t             s_empty; 
            PhysicsEventCountItemBody s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader           s_bodyHeader;
            PhysicsEventCountItemBody s_body;
        } u_hasBodyHeader;
    } s_body;
} PhysicsEventCountItem, *pPhysicsEventCountItem;


typedef struct _EventBuilderFragment {
  RingItemHeader s_header;
  BodyHeader     s_bodyHeader;
  uint8_t       s_body[0];
} EventBuilderFragment, *pEventBuilderFragment;


typedef struct _DataFormat {
    RingItemHeader s_header;
    uint32_t       s_empty;   
    uint16_t       s_majorVersion;
    uint16_t       s_minorVersion;
} DataFormat, *pDataFormat;

typedef struct _GlomParameters  {
    RingItemHeader s_header;
    uint32_t       s_empty;
    uint64_t       s_coincidenceTicks;
    uint16_t       s_isBuilding;
    uint16_t       s_timestampPolicy;
    
} GlomParameters, *pGlomParameters;

typedef strucst _AbnormalEndItem {
    RingItemHeader s_header;
    uint32_t      s_empty;                   // Empty body header.

} AbnormalEndItem, *pAbnormalEndItem;



  pPhysicsEventItem  formatEventItem(size_t nWords, void* pPayload);
  pPhysicsEventCountItem formatTriggerCountItem(uint32_t runTime, time_t stamp, uint64_t triggerCount);
  pScalerItem         formatScalerItem(unsigned scalerCount, time_t timestamp, 
				      uint32_t btime, uint32_t etime, void* pCounters);
  pScalerItem         formatNonIncrTSScalerItem(unsigned scalerCount, time_t timestamp, 
						       uint32_t btime, uint32_t etime, 
						       uint64_t eventTimestamp, void* pCounters,
						       uint32_t timebaseDivisor);
  pTextItem          formatTextItem(unsigned nStrings, time_t stamp, uint32_t runTime,
				    const char** pStrings, int type);
  pStateChangeItem   formatStateChange(time_t stamp, uint32_t offset, uint32_t runNumber,
				       const char* pTitle, int type);
  
  pDataFormat           formatDataFormat();
  pGlomParameters       formatGlomParameters(uint64_t coincidenceWindow, int isBuilding,
                            int timestampPolicy);
  
  pEventBuilderFragment formatEVBFragment(
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    uint32_t payloadSize, const void* pPayload
  );
  pEventBuilderFragment formatEVBFragmentUnknown (
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    uint32_t payloadSize, const void* pPayload
  );
  pPhysicsEventItem formatTimestampedEventItem(
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    uint32_t payloadSize, const void* pPayload    
  );
  pPhysicsEventCountItem formatTimestampedTriggerCountItem (
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    uint32_t runTime, uint32_t offsetDivisor, time_t stamp, uint64_t triggerCount  
  );
  pScalerItem formatTimestampedScalerItem(
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    int isIncremental, uint32_t timeIntervalDivisor, uint32_t timeofday,
    uint32_t btime, uint32_t etime, uint32_t nScalers, void* pCounters
  );
  pTextItem formatTimestampedTextItem(
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    unsigned nStrings, time_t stamp, uint32_t runTime,
    const char**pStrings, int type,
    uint32_t timeIntervalDivisor
  );
  pStateChangeItem formatTimestampedStateChange(
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    time_t stamp, uint32_t offset, uint32_t runNumber, uint32_t offsetDivisor,
    const char* pTitle, int type
  );
  
 pAbnormalEndItem formatAbnormalEndItem();
  
  // Most of these were added in V12.0
  
  int  hasBodyHeader(const RingItem* pItem);
  void* bodyPointer(RingItem* pItem);
  void* bodyHeader(RingItem* pItem);

  uint32_t itemSize(const RingItem* pItem);
  uint16_t itemType(const RingItem* pItem);
  int      mustSwap(const RingItem* pItem);

  // Make these visible so that e.g. ring item classes can use
  // proven code.
  
  void* fillRingHeader(pRingItem pItem, uint32_t size, uint32_t type);
  void* fillBodyHeader(
      pRingItem pItem, uint64_t timestamp, uint32_t sourceId,
      uint32_t barrier
  );
  void* fillEventCountBody(
    pRingItem pItem, uint32_t offset, uint32_t divisor, uint32_t unixTime,
    uint64_t count, uint32_t sid
  );
  void* fillScalerBody(
    pRingItem pItem, uint32_t start, uint32_t end, uint32_t divisor,
    uint32_t unixTime, uint32_t count, int incremental, uint32_t* pScalers,
    uint32_t sid
  );
  void* fillTextItemBody(
    pRingItem pItem, uint32_t offset, uint32_t divisor, uint32_t unixTime,
    uint32_t nStrings, const char** ppStrings, int sid
  );
  void* fillStateChangeBody(
    pRingItem pItem, uint32_t run, uint32_t offset, uint32_t divisor,
    uint32_t unixTime, const char* pTitle, int sid
  );

</programlisting>

           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
                This header describes the format of data placed in NSCL ring
                buffers.  Each item consists of an envelope and a payload.
                The envelope, 
                <type>RingItemHeader</type> contains a size:
                <fieldsynopsis><type>uint32_t</type> <varname>s_size</varname></fieldsynopsis>
                which is the total size of the item (inlcuding the header) in
                bytes, and an item type
                <fieldsynopsis><type>uint32_t</type> <varname>s_type</varname></fieldsynopsis>
                which indicates what the item contains.  The payload immediately
                follows the header and varies in structure depending on the
                value in <varname>s_type</varname>.
              </para>
              <para>
                Items are placed in rings in native machine byte ordering.
                While the data type is 32 bits long, only the least significant
                16 bits are nonzero.  This allows a determination of
                the endianness of the system that generated the item.
              </para>
              <para>
                Starting with NSCLDAQ 11.0, ring items may have an additional
                <type>BodyHeader</type>.  The first field of this
                is the size of the body header (allowing for future expansion).
                If the body header size is <literal>sizeof(uint32_t)</literal> there is no
                body header.  The body header is intended to carry information
                relevant to data that requires an event builder for assembly.
              </para>
              <note>
                <title>NOTE:</title>
                <para>
                  The use of <literal>sizeof(uint32_t)</literal>
                  to denote an empty body header is new as of NSCLDAQ V12.0.
                  In NSCLDAQ 11.0, which introduced body headers, the
                  value <literal>0</literal> was used to indicate
                  the lack of a body  header.   NSCLDAQ 12.0 will
                  properly process either of those body header values.
                </para>
              </note>
              <para>
                NSCLDAQ 12.0 introduces a new
                <structfield>s_originalSid</structfield> field
                for state change, scaler, event count and text
                ring items that is used to hold the source id
                used to construc the item. This allows the event
                builder to modify the body headers in ways it always
                has, but to nonetheless retain the ability to
                determine which data source originally emitted
                the item.
              </para>
              <para>
                STRUCTURES below describes each of the ring items defined
                at this time.  CONSTANTS defines the set of values that
                <varname>s_type</varname> can take (once converted to
                the localh host's endian-ness).
              </para>
           </refsect1>
           <refsect1>
              <title>STRUCTURES</title>
              <para>
                The following ring items have been defined:
              </para>
              <refsect2>
                <title>RingItemHeader</title>
                <para>
                    This structure appears at beginning of each ring item.
                    The type <type>pRingItemHeader</type> represents a pointer
                    to a <type>RingItemHeader</type>.
                    <type>RingItemHeader</type> structs contain the following fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <type>uint32_t</type><structfield> s_size</structfield>
                        </term>
                        <listitem>
                            <para>
                                The size in bytes of the entire ring item.  The
                                size includes the size of the <type>RingItemHeader</type>
                                as well.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>uint32_t</type><structfield>s_type</structfield>
                        </term>
                        <listitem>
                            <para>
                                Contains the ring item type.  See the section
                                CONSTANTS below for valid ring item types. While
                                the <structfield>s_type</structfield> field is
                                <type>uint32_t</type>, the most significant 16
                                bits of this field are always zero, and the least
                                significant bits are always non-zero allowing
                                code to determine the endianness of data  in this
                                item (including the size).
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
              </refsect2>
              <refsect2>
                <title><type>BodyHeader</type></title>
                <para>
                    Contains data about the event as a fragment of a larger event.
                    The type <type>pBodyHeader</type> represents a pointer to this
                    type.
                </para>
                <para>
                    The body header has the following fiels:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>uint32_t</type><structfield>s_size</structfield></term>
                        <listitem>
                            <para>
                                Contains the size of the ring item header.  note that
                                if this field is <literal>0</literal> there are no
                                more fields (the item has no body header).
                                This possibility in general means that ring items
                                are described best by <type>union</type>s.
                                See the documentation about the remaining ring
                                item structures for more information.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>uint64_t</type><structfield>s_timestamp</structfield></term>
                        <listitem>
                            <para>
                                The timestamp of the event in ticks of the clock
                                that defines event building.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>uint32_t</type><structfield>s_sourceId</structfield></term>
                        <listitem>
                            <para>
                                The id of the source that produced this item.
                                Note that the event builder can modify
                                this source id.  For  ring items where
                                the original source id is important, the
                                version 12.0 adds the field
                                <structfield>s_originalSid</structfield>
                                to maintain that value.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>uint32_t</type><structfield>s_barrier; </structfield>
                        </term>
                        <listitem>
                            <para>
                                If nonzero, this item is part of a barrier
                                synchronization event.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
              </refsect2>
              <refsect2>
                <title>RingItem</title>
                <para>
                    This is a generic ring item.  The type <type>pRingItem</type>
                    defines a pointer to a ring item.   This item has the
                    following structure:
                </para>
                <programlisting>
typedef struct _RingItem {
  RingItemHeader s_header;
  union {
    struct {
      uint32_t s_empty;
      uint8_t  s_body[0];
    } u_noBodyHeader;
    struct {
        BodyHeader s_bodyHeader;
        uint8_t s_body[0];
    } u_hasBodyHeader;
  } s_body;
} RingItem, *pRingItem;
                </programlisting>
                <para>
                    The <structfield>s_header</structfield> is the
                    <type>RingItemHeader</type> decribed above.  The
                    union that follows provides support for ring items
                    that have (<structfield>u_hasBodyHeader</structfield>)
                    and do not have (<structfield>u_noBodyHeader</structfield>)
                    body headers.
                </para>
                <para>
                    The <structfield>s_empty</structfield> field is zero
                    (Version 11) or sizeof(uint32_t) (Version 12+) indicating
                    that the item has no body header.
                </para>
                <para>
                    The <structfield>s_bodyHeader</structfield> is the
                    full body header.
                </para>
                <para>
                    In both branches of the union, the field
                    <structfield>s_body</structfield> is where the actual
                    payload (body) of the ring item actually
                    is.
                </para>
              </refsect2>
              <refsect2>
                <title>StateChangeItem</title>
                <para>
                    These contain information about a run state change.
                    They have the following form:
                </para>
                <programlisting>
typedef struct _StateChangeItem  {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t            s_empty;       /* Must be sizeof(uint32_t) - no body header*/
            StateChangeItemBody s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader          s_bodyHeader;
            StateChangeItemBody s_body;
        } u_hasBodyHeader;
    } s_body;
    
} StateChangeItem, *pStateChangeItem;
                </programlisting>
                <para>
                    As you can see this is a union whose inner struture
                    depends on whether or not there is a body header
                    (<structfield>u_hasBodyHeader</structfield>) or
                    not (<structfield>u_noBodyHeader</structfield>).
                    You can tell which version of the union to use by examining
                    the <structfield>s_empty</structfield> field.  If this is
                    zero (version 11) or sizeof(uint32_t) (version 12+)
                    use <structfield>u_noBodyHeader</structfield> otherwise
                    use <structfield>u_hasBodyHeader</structfield>
                </para>
                <para>
                    The <structfield>s_header</structfield> field is the
                    ring item header.  If there is a Body header is  is
                    <structfield>s_bodyHeader</structfield>
                </para>
                <para>
                    Regardless of which branch of the union you select, the
                    payload of the ring item is a <type>StateChangeItemBody</type>
                    in <structfield>s_body</structfield> which has the following
                    structure:
                </para>
                <programlisting>
typedef struct _StateChangeItemBody {
  uint32_t        s_runNumber;
  uint32_t        s_timeOffset;
  uint32_t        s_Timestamp;
  uint32_t        s_offsetDivisor;
  uint32_t        s_originalSid;     // 12.0 original source id.
  char            s_title[TITLE_MAXSIZE+1];
} StateChangeItemBody, *pStateChangeItemBody;
                </programlisting>
                <para>
                    <structfield>s_runNumber</structfield> is the number of the
                    run that is undergoig a transition.  <structfield>s_timeoffset</structfield>
                    together with <structfield>s_offsetDivisor</structfield>
                    determine when relative to the start of the run this state change
                    occured.  <structfield>s_timeoffset</structfield> is a time
                    offset in unites of 1/<structfield>s_offsetDivisor</structfield>
                    seconds.
                </para>
                <para>
                    The unix <type>time_t</type> for the absolute time at
                    which this occured is truncated to 32 bits and stored
                    in <structfield>s_Timestamp</structfield> (note that
                    on 64 bit systems  <type>time_t</type> is 64 bits
                    but on 32 bit systems 32 bits making it intrinsically
                    non-portable).  This 32 bit time is good into the year
                    2038.  <structfield>s_offsetDivisor</structfield>
                    stores the units of <structfield>s_Timestamp</structfield>
                    in 1/seconds.  Thus <structfield>s_Timestamp/s_offsetDivisor</structfield>
                    is the offset in to the run in floating point seconds
                    (floating point values are also not as portable as fixed
                    length integers).
                </para>
                <para>
                    <structfield>s_title</structfield> is the run title.
                    The title string is a null terminated string at most
                    <literal>TITLE_MAXSIZE</literal> non null characters long.
                    The additional <type>char</type> allocated ensures the
                    title has a null terminator.  See <literal>CONSTANTS</literal>
                    below for more information about <literal>TITLE_MAXSIZE</literal>.
                </para>
                <para>
                  The <structfield>s_originalSid</structfield> field
                  is new in V12.0 and allows the body to maintain knowledge of
                  the ring item's original source id in the presence of
                  the event builder's manipulation of body headers.
                  The functions prototyped in
                  <filename>DataFormat.h</filename> that format
                  ring state change items set this field properly.
                  <classname>CRingStateCHangeItem</classname> uses
                  those functions to format its ring item and therefore
                  also properly sets this field.
                </para>
              </refsect2>
              <refsect2>
                <title><type>ScalerItem</type></title>
                <para>
                    The <type>ScalerItem</type> item contains a set of periodically
                    read scaler items.  Starting in NSCLDAQ-11.0 these may or may
                    not be incremental and may have interval start/stop
                    time values that have a sub-second resolution.
                </para>
                <para>
                    As with most ring item data, the actual structure of this is
                    represented as a union:
                </para>
                <programlisting>
typedef struct _ScalerItem {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t       s_empty;              /* Must be sizeof(uint32_t).. no header */
            ScalerItemBody s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader     s_bodyHeader;
            ScalerItemBody s_body;
        } u_hasBodyHeader;
    } s_body;
} ScalerItem, *pScalerItem;
                </programlisting>
                <para>
                    The union has the standard branches that most <type>RingItem</type>s
                    have, <structfield>u_noBodyHeader</structfield> when
                    <structfield>s_empty</structfield> is zero (version 11)
                    or sizeof(uint32_t) (version 12) indicating a lack
                    of a body header and
                    <structfield>s_hasBodyHeader</structfield> when it is
                    the size of an action <type>BodyHeader</type> struct.
                </para>
                <para>
                    Regardless, <structfield>s_body</structfield> has the
                    actual scaler data body and looks like this:
                </para>
                <programlisting>
 typedef struct _ScalerItemBody {
  uint32_t        s_intervalStartOffset;
  uint32_t        s_intervalEndOffset;
  uint32_t        s_timestamp;
  uint32_t        s_intervalDivisor;  /* 11.0 sub second time intervals */
  uint32_t        s_scalerCount;
  uint32_t        s_isIncremental;    /* 11.0 non-incremental scaler flag */
  uint32_t        s_originalSid;      /* V12.0 */
  uint32_t        s_scalers[0];
} ScalerItemBody, *pScalerItemBody;
                </programlisting>
                <para>
                    The fields <structfield>s_intervalStartOffset</structfield>,
                    <structfield>s_intervalEndOffset</structfield> and
                    <structfield>s_intervalDivisor</structfield> allow you to
                    determine the time relative to the beginning of the run at which
                    the counting interval started and ended.  Dividing the offsets
                    by the divisor produces seconds (if done in floating point
                    arithmetic).
                </para>
                <para>
                    <structfield>s_timetamp </structfield> provides the unix
                    time of day (trucated <type>time_t</type>) of the end of the
                    counting interval.
                </para>
                <para>
                    The <structfield>s_isIncremental</structfield> is non-zero
                    if the the scalers are zeroed at the start of each interval.
                    Otherwise it is assumed that history is required to be able
                    to compute rates.
                </para>
                <para>
                    <structfield>s_scalerCount</structfield> is the
                    number of scalers in item and <structfield>s_scales</structfield>
                    is the location of the first element of the array of 32
                    bit wide scalers.
                </para>
                <para>
                  <structfield>s_orignalSid</structfield> contains
                  the sourceid of the data source that originally
                  emitted this item. This field is immune from the
                  manipulations the event builder performs on the
                  body header.  The <filename>DataFormat.h</filename>
                  functions that format scaler items, as well as
                  the <classname>CRingScalerItem</classname> 
                  initialize this field correctly.
                </para>
                <para>
                  <structfield>s_scalers</structfield> is actually
                  an array of <structfield>s_scalerCount</structfield>
                  members containing the actual scaler values.
                </para>
              </refsect2>
              <refsect2>
                <title><type>TextItem</type></title>
                <para>
                    <type>TextItem</type> items contain a set of text strings
                    that are used for documentation purposes or to allow
                    the data acquisition system to track a set of slow controls
                    parameters.  As with almost all ringt items, the top level
                    structure is a union:
                </para>
                <programlisting>
 typedef struct _TextItem {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t       s_empty;            /* Must be sizeof(uint32_t) (no body header) */
            TextItemBody   s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader     s_bodyHeader;
            TextItemBody   s_body;
        } u_hasBodyHeader;
    } s_body;
} TextItem, *pTextItem;
                </programlisting>
                <para>
                    The <type>TextItemBody</type> has the following shape:
                </para>
                <programlisting>
typedef struct _TextItemBody {
  uint32_t       s_timeOffset;
  uint32_t       s_timestamp;
  uint32_t       s_stringCount;
  uint32_t       s_offsetDivisor;
  uint32_t       s_originalSid;   /* Added in V12.0   */
  char           s_strings[0];
} TextItemBody, *pTextItemBody;
                </programlisting>
                <para>
                    The <structfield>s_timeOffset</structfield> and
                    <structfield>s_offsetDivisor</structfield> are used to
                    represent the time at which this item was emitted relative
                    to the start of the run.  <structfield>s_timeOffset</structfield>
                    is the offset.  Doing a floating point by <structfield>s_offsetDivisor</structfield>
                    produces the seconds into the run at which the item was emitted.
                </para>
                <para>
                    <structfield>s_timestamp</structfield> is the truncated
                    <type>time_t</type> that represents the absolute time at
                    which this item was emitted.
                </para>
                <para>
                    <structfield>s_stringCount</structfield> is the number
                    of strings in the body. <structfield>s_strings</structfield>
                    points to the first byte of an array of bytes that contain
                    the null terminated strings carried by the item.  The
                    format of these strings is entirely up to the emitter.
                </para>
                <para>
                  <structfield>s_originalSid</structfield>
                  contains the source id of the data source that
                  emitted this item. This value is immune to the
                  modifications event builders can make on the
                  source id in the body header.   The
                  functions prototyped in <filename>DataFormat.h</filename>
                  and <classname>CRingTextItem</classname>
                  properly initialize this field for you.
                </para>
              </refsect2>
              <refsect2>
                <title><type>PhysicsEventItem</type></title>
                <para>
                    This item represents the response of a readout subsystem
                    to a trigger.  This may be passed as an event fragment
                    to an event building pipeline.  The struture of the item is
                    the normal union shape:
                </para>
                <programlisting>
typedef struct _PhysicsEventItem {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t      s_empty;
            uint16_t      s_body[];      /* Aribrtary length body */
        } u_noBodyHeader;
        struct {
            BodyHeader    s_bodyHeader;
            uint16_t      s_body[];
        } u_hasBodyHeader;
    } s_body;
} PhysicsEventItem, *pPhysicsEventItem;
                </programlisting>
                <para>
                    <structfield>s_body</structfield> is the first word of the
                    event body.  The size of the body can be determined from the
                    <structfield>s_size</structfield> field of the
                    <structfield>s_header</structfield> ring item header.
                    Typically, the readout frameworks place a word or longword
                    into the <structfield>s_body</structfield> that contains
                    the length of the event.
                </para>
              </refsect2>
              <refsect2>
                <title><type>DataFormat</type></title>
                <para>
                    This ring item (new starting in NSCLDAQ-11.0) describes
                    the oldest version of NSCLDAQ that is capable of handling
                    this form of data in the ring buffer.  The structure
                    of this item is:
                </para>
                <programlisting>
typedef struct _DataFormat {
    RingItemHeader s_header;
    uint32_t       s_empty;              /* No body header */
    uint16_t       s_majorVersion;     /* FORMAT_MAJOR */
    uint16_t       s_minorVersion;     /* FORMAT_MINOR */
} DataFormat, *pDataFormat;
                </programlisting>
                <para>
                    As the <structfield>s_empty</structfield> implies,
                    This item does not have a body header.  All data submitted
                    to a single ring buffer is assumed to be in a compatible
                    format.  The <structfield>s_majorVersion</structfield> and
                    <structfield>s_minorVersion</structfield> fields are the
                    major and minor versions of the oldest NSCLDAQ that can
                    deal with this data.  For example for NSCLDAQ-11.0
                    <structfield>s_majorVersion</structfield> is <literal>11</literal>
                    while <structfield>s_minorVersion</structfield> is
                    <literal>0</literal>
                </para>
              </refsect2>
              <refsect2>
                <title><type>PhysicsEventCountItem</type></title>
                <para>
                    This ring item provides counts of the number of
                    triggers a readout subsystem has responded to.
                    This can be used to keep track of trigger rates and,
                    for software that samples data, the fraction of data that
                    has ben seen.
                </para>
                <para>
                    The structure of this data item is the usual union:
                </para>
                <programlisting>
typedef struct _PhysicsEventCountItem {
    RingItemHeader   s_header;
    union {
        struct {
            uint32_t             s_empty;      /* Must be sizeof(uint32_t) - no body header*/
            PhysicsEventCountItemBody s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader           s_bodyHeader;
            PhysicsEventCountItemBody s_body;
        } u_hasBodyHeader;
    } s_body;
} PhysicsEventCountItem, *pPhysicsEventCountItem;
                </programlisting>
                <para>
                    The union is used so that individual contributors of fragments
                    to the event builder can create uniquely identifiable
                    trigger count items.
                </para>
                <para>
                    The <structfield>s_body</structfield> field of both branches
                    of the union has the following shape:
                </para>
                <programlisting>
typedef struct __PhysicsEventCountItemBody {
  uint32_t       s_timeOffset;
  uint32_t       s_offsetDivisor;
  uint32_t       s_timestamp;
  uint32_t        s_originalSid;     /* Added with version 12.0 */
  uint64_t       s_eventCount;	/* Maybe 4Gevents is too small ;-) */
} PhysicsEventCountItemBody, *pPhysicsEventCountItemBody;
                </programlisting>
                <para>
                    The time into the run is determined in the usual way
                    from <structfield>s_timeOffset</structfield> and
                    <structfield>s_offsetDivisor</structfield>. Furthermore,
                    <structfield>s_timestamp</structfield> provides the
                    truncated <type>time_t</type> value that identifies the
                    absolute time at which this item was emitted.
                </para>
                <para>
                  The <structfield>s_originalSid</structfield>, added
                  in NSCLDAQ V12.0 contains the source id of the data
                  source that originally emitted this item.  This
                  field is immune to the transformations the event builder
                  performs on the source id in the body header and,
                  therefore, should be used to get the source id
                  that generated this item.
                  The functions prototyped in
                  <filename>DataFormat.h</filename>, as well
                  as the <classname>CRingPhysicsEventCountItem</classname>
                  transparently set this field's value appropriately.
                </para>
                
                <para>
                    <structfield>s_eventCount</structfield> are the number
                    of triggers that have been responded to since the start
                    of the run.
                </para>
              </refsect2>
              <refsect2>
                <title><type>EventBuilderFragment</type></title>
                <para>
                    An event builder fragment item is produced in event builder
                    monitor rings.  These rings allow users to monitor the ordered
                    data data from the ordering stage of the event builder pipeline.
                    These data are produced by the <application>teering</application>
                    program, and are also inputs to <application>glom</application>.
                </para>
                <para>
                    Since the event builder operates on timestamps and
                    needs to know about barriers and event sources all
                    event fragments have a body header:
                </para>
                <programlisting>
typedef struct _EventBuilderFragment {
  RingItemHeader s_header;
  BodyHeader     s_bodyHeader;
  uint8_t       s_body[];	/* Really s_payload bytes of data.. */
} EventBuilderFragment, *pEventBuilderFragment;
                </programlisting>
                <para>
                    <structfield>s_body</structfield> is the first byte of
                    the payload of the fragment.  The size of the fragment
                    can be determined from <structfield>s_header.s_size</structfield>
                    (specifically
                    <literal>s_header.s_size - sizeof(RingItemHeader) - sizeof(BodyHeader))</literal>).
                </para>
                <para>
                    It is also not unusual for the structure of the body to
                    describe the size of the <structfield>s_body</structfield> independent
                    of the rest of the item..
                </para>
              </refsect2>
              <refsect2>
                <title><type>GlomParameters</type></title>
                <para>
                    This item type is produced by the <application>glom</application>
                    stage of the event building pipeline.  <application>glom</application>
                    is the stage that can glue (or glom) ordered event fragments
                    into full events.
                </para>
                <para>
                    This event item captures the values of the run time parameters
                    handed to ghlom at startup time so that consumers of this
                    data know what they mean,
                </para>
                <programlisting>
typedef struct _GlomParameters  {
    RingItemHeader s_header;
    uint32_t       s_empty;
    uint64_t       s_coincidenceTicks;
    uint16_t       s_isBuilding;
    uint16_t       s_timestampPolicy;
    
} GlomParameters, *pGlomParameters;
                </programlisting>
                <para>
                    As you can see by the <structfield>s_empty</structfield> field,
                    this item does not have a ring body header.  The
                    <structfield>s_isBuilding</structfield>, is non zero if
                    glom is gluing events together and zero otherwise.
                    <structfield>s_coincidenceTicks</structfield> is therefore
                    only meaningful if <structfield>s_isBuilding</structfield>
                    is nonzero.  It represents the timestamp interval that
                    glom considers defines a fragment coincidence window.
                    Finally the <structfield>s_timestampPolicy</structfield>
                    contains the timestamp policy that glom used to determine                    
                    how timestamp fields in body headers of built events should
                    be chosen.  This is one of <literal>GLOM_TIMESTAMP_FIRST</literal>,
                    <literal>GLOM_TIMESTAMP_LAST</literal> or <literal>GLOM_TIMESTAMP_AVERAGE</literal>.
                </para>
                <programlisting>

typedef strucst _AbnormalEndItem {
    RingItemHeader s_header;
    uint32_t      s_empty;                   // Empty body header.

} AbnormalEndItem, *pAbnormalEndItem;

                </programlisting>
                <para>
                     This can be emitted to let downstream software know that
                     a run was ended prematurely.  When emitted no more data
                     shouild be emitted for the current run.
                </para>
              </refsect2>
              
              
           </refsect1>
            <refsect1>
               <title>CONSTANTS</title>
               <para>
                    <filename>DataFormat.h</filename> provides constant definitions
                    for the possible item type values as well as other definitions:
               </para>
               <variablelist>
                <varlistentry>
                    <term><fieldsynopsis>
                        <modifier>static const</modifier><type>uint16_t</type>
                        <varname>FORMAT_MAJOR</varname><initializer>11</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This is the value that should normally be put in the
                            <varname>s_majorVersion</varname> member of the
                            <type>DataFormat</type> ringitems.
                            At the time of writing the value is as shown above,
                            however check the <filename>DataFormat.h</filename>
                            file you are using in case this has been updated.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint16_t</type>
                            <varname>FORMAT_MINOR</varname><initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This is the value that should normally be put in the
                            <varname>s_majorVersion</varname> member of the
                            <type>DataFormat</type> ringitems.
                            At the time of writing the value is as shown above.
                            Since data format changes require a change in the major
                            version number of NSCLDAQ I would expect this value
                            to be zero.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>BEGIN_RUN</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a state change item
                            that documents the start of a run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>END_RUN</varname><initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a state change item
                            that documents the end of a run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>PAUSE_RUN</varname>
                            <initializer>3</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a state change item
                            that documents a pause in a run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>RESUME_RUN</varname>
                            <initializer>4</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a state change item
                            that documents a resume from a paused run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type> <varname>ABNORMAL_ENDRUN</varname>
                            <initializer>5</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Ring items of this type indcate a run ended abnormally.
                            This should be treated, in  most respects, like the end
                            of run marker.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>PACKET_TYPES</varname>
                            <initializer>10</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a text list ring item
                            that contains information about the types of
                            packets that may appear in events.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>MONITORED_VARIABLES</varname>
                            <initializer>11</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a text list ring item
                            that contains a set of monitored variable values.
                            Each string in items of this type will be a
                            Tcl set command that will recreate the value of
                            the variable at the time the item was created.
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>RING_FORMAT</varname>
                            <initializer>12</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>DataFormat</type> ring item.  These items
                            describe the format of the items in the ring in terms
                            of the first version of NSCLDAQ capable of decoding
                            them.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>PERIODIC_SCALERS</varname>
                            <initializer>20</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>ScalerItem</type> ring item.  These items
                            contain data from periodically read scalers.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>PHYSICS_EVENT</varname>
                            <initializer>30</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>PhysicsEventItem</type> ring item.
                            These items contain physics event data.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type>
                            <varname>PHYSICS_EVENT_COUNT</varname>
                            <initializer>31</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>PhysicsEventCountItem</type> ring item.
                            these items contain information about the number
                            of triggers that have been accepted thus far into
                            the run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type>
                            <varname>EVB_FRAGMENT</varname>
                            <initializer>40</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>EventBuilderFragment</type> ring item.
                            These are used to encapsulate event fragments
                            that have been ordered by the time ordering phase
                            of the event builder pipeline.  Note that
                            These are typically only visible in the
                            order monitoring ring.
                        </para>
                        <para>
                            Items of this type are believed to have
                            payloads that look like ring items.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type>
                            <varname>EVB_UNKNOWN_PAYLOAD</varname>
                            <initializer>41</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>EventBuilderFragment</type> whose payload
                            looks like it probably is not a ring item.
                            Note that form of the payload of
                            an event builder fragment
                            can only be guessed at not known with certainty.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                        <modifier>static const</modifier><type>uint32_t</type>
                        <varname>EVB_GLOM_INFO</varname>
                        <initializer>42</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>GlomParameters</type> ring item.  This type
                            of ring item is used by the <firstterm>glomming</firstterm>
                            phase of the event builder to describe the
                            parameters being used to build events.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                        <modifier>static const</modifier>
                        <type>uint32_t</type><varname>FIRST_USER_ITEM_CODE</varname>
                        <initializer>32768</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            There is nothing sacred about the specifific set of
                            ring items defined by <filename>DataFormat.h</filename>
                            users can define application specific ring items.
                            In order to do so without present and future
                            collisions in ring item types with standardf
                            values, users should allocate ring item types from
                            types that are no less than
                            <varname>FIRST_USER_ITEM_CODE</varname>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint16_t</type><varname>GLOM_TIMESTAMP_FIRST</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            A possible value for the timestamp policy of the
                            glom format ring item.  This value means the
                            output event timestamps are filled  in from the
                            fragment with the smallest timestamp value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint16_t</type><varname>GLOM_TIMESTAMP_LAST</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            A possible value for the timestamp policy of the
                            glom format ring item.  This value means the
                            output event timestamps are filled  in from the
                            fragment with the largest timestamp value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint16_t</type><varname>GLOM_TIMESTAMP_AVERAGE</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            A possible value for the timestamp policy of the
                            glom format ring item.  This value means the
                            output event timestamps are filled  in from the
                            average of all timestamps in fragments in the event.
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry>
                    <term>
                        <literal>#define TITLE_MAXSIZE 80</literal></term>
                    <listitem>
                        <para>
                            Defines the maximum number of characters in a
                            Run State change item's title field.
                        </para>
                    </listitem>
                </varlistentry>
               </variablelist>
            </refsect1>
         </refentry>
        <refentry id="dataformat3-formatfunctions">
          <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
                <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
          <refmeta>
             <refentrytitle>format  Functions</refentrytitle>
             <manvolnum>3dataformat</manvolnum>
             <refmiscinfo class='empty'></refmiscinfo>
          </refmeta>
          <refnamediv>
             <refname>format Functions</refname>
             <refpurpose>Functions to create ring items.</refpurpose>
          </refnamediv>
          
          <refsynopsisdiv>
            <programlisting>
#include &lt;DataFormat.h&gt;
            </programlisting>
            <funcsynopsis>
            <funcprototype><funcdef><type>pPhysicsEventItem</type> <function>formatEventitem</function></funcdef>
            <paramdef>
              <parameter><type>size_t</type> nWords</parameter></paramdef>
            <paramdef>
                <parameter><type>void*</type> pPayload</parameter>
            </paramdef>
            </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
               <funcprototype><funcdef><type>pPhysicsEventCountItem</type> <function>formatTriggerCountItem </function></funcdef>
               <paramdef>
                  <parameter><type>uint32_t </type>runTime</parameter>
               </paramdef>
               <paramdef>
                <parameter><type>time_t</type>timeStamp</parameter>
               </paramdef>
               <paramdef>
                <parameter><type>uint64_t</type>triggerCount</parameter>
               </paramdef>
               </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
            	<funcprototype><funcdef><type>pScalerItem</type> <function>
                    formatScalerItem
                </function></funcdef>
                <paramdef>
                   <parameter><type>unsigned  </type>scalerCount </parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>time_t</type>timestamp</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type> btime</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32</type>etime</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>void*</type> pCounters</parameter>
                </paramdef>
               </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype><funcdef><type>pTextItem</type> <function>formatTextItem </function></funcdef>
                <paramdef>
                   <parameter><type>unsigned  </type>nStrings </parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>time_t</type> stamp</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type> runTime</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>const char**</type> pStrings</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>int</type> type</parameter>
                </paramdef>
               </funcprototype>
            </funcsynopsis> 
            <funcsynopsis>
                <funcprototype><funcdef><type>pStateChangeItem</type>
                <function>formatStateChange </function></funcdef>
                <paramdef>
                   <parameter><type>time_t  </type>stamp </parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type> offset</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t </type> runNumber</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>const char*</type> pTitle</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uin32_t</type> type</parameter>
                </paramdef>
                
                </funcprototype>
            </funcsynopsis>
   
            <!-- added in 11.0 -->
            <funcsynopsis>
                <funcprototype><funcdef><type>pScalerItem</type>
                <function>formatNonIncrTSScalerItem</function></funcdef>
                <paramdef>
                    <parameter><type>unsigned</type> scalerCount</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>time_t</type> timestamp</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type> btime</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type>  etime</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint64_t</type> eventTimestamp</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>void*</type> pCounters</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type> timebaseDivisor</parameter>
                </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                <funcdef><type>pDataFormat</type><function>formatDataFormat</function>
                </funcdef>
                <void />
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef><type>pGlomParameters</type>
                        <function>formatGlomParameters</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> coincidenceWindow</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type>isBuilding</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type>timestampPolicy</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef><type>pEventBuilderFragment</type>
                        <function>formatEVBFragment</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> payloadSize</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const void*</type>
                        pPayload</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef><type>pEventBuilderFragment</type>
                        <function>formatEVBFragmentUnknown</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t timestamp</type></parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> payloadSize</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const void*</type> pPayload</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pPhysicsEventItem</type>
                        <function>formatTimestampedEventItem</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> payloadSize</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const void*</type> pPayload</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pPhysicsEventCountItem</type>
                        <function>formatTimestampedTriggerCountItem</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> runTime</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> offsetDivisor</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>time_t</type> stamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> triggerCount</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pScalerItem</type>
                        <function>formatTimestampedScalerItem</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type>timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type> isIncremental</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> timeIntervalDivisor</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> timeofday</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> btime</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> etime</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> nScalers</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>void*</type> pCounters</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pTextItem</type>
                        <function>formatTimestampedTextItem</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>unsigned</type> nStrings</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>time_t</type> stamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> runTime</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const char**</type>pStrings</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type> type</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> timeIntervalDivisor</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis> 
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pStateChangeItem</type>
                        <function>formatTimestampedStateChange</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>time_t</type> stamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> offset</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> runNumber</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> offsetDivisor</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const char*</type> pTitle</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type> type</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>void*</type> <function>bodyPointer</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>pRingItem</type> pItem</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pAbnormalEndItem</type> <function>formatAbnormalEndItem</function>
                    </funcdef>
                    <void />
                </funcprototype>
            </funcsynopsis>

            <!-- end of 11.0 additions -->
   
            <!-- These functions were added in version 12.0 -->
   
  <funcsynopsis>
      <funcprototype>
          <funcdef>
              <type>int  </type>
              <function>hasBodyHeader</function>

          </funcdef>
          <paramdef>
              <parameter><type>const RingItem* </type> pItem</parameter>
          </paramdef>
      </funcprototype>
  </funcsynopsis>
  <funcsynopsis>
      <funcprototype>
          <funcdef>
              <type>int  </type>
              <function>hasBodyHeader</function>

          </funcdef>
          <paramdef>
              <parameter><type>const RingItem* </type> pItem</parameter>
          </paramdef>
      </funcprototype>
  </funcsynopsis>
  <funcsynopsis>
      <funcprototype>
          <funcdef>
              <type>void* </type>
              <function>bodyHeader</function>
              
          </funcdef>
          <paramdef>
                  <parameter>RingItem* <type></type> pItem</parameter>
          </paramdef>
      </funcprototype>
  </funcsynopsis>
  <funcsynopsis>
      <funcprototype>
          <funcdef>
              <type>uint32_t </type>
              <function>itemSize</function>
          </funcdef>
          <paramdef>
              <parameter><type>const RingItem* </type> pItem</parameter>
          </paramdef>
      </funcprototype>
  </funcsynopsis> 
  <funcsynopsis>
      <funcprototype>
          <funcdef>
              <type>uint16_t </type>
              <function>itemType</function>
          </funcdef>
          <paramdef>
              <parameter><type>const RingItem* </type> pItem</parameter>
          </paramdef>
      </funcprototype>
  </funcsynopsis>
  <funcsynopsis>
      <funcprototype>
          <funcdef>
              <type>int</type>
              <function>mustSwap</function>
          </funcdef>
          <paramdef>
              <parameter><type>const RingItem* </type> pItem</parameter>
          </paramdef>
      </funcprototype>
  </funcsynopsis>
  <funcsynopsis>
      <funcprototype>
          <funcdef>
              <type>void* </type>
              <function>fillRingHeader</function>
          </funcdef>
          <paramdef>
              <parameter><type>pRingItem </type> pItem</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> size</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> type</parameter>
          </paramdef>
      </funcprototype>
      
  </funcsynopsis>
  <funcsynopsis>
      <funcprototype>
          <funcdef>
              <type>void* </type>
              <function>fillBodyHeader</function>
          </funcdef>
          <paramdef>
              <parameter><type>pRingItem pItem</type> </parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint64_t </type> timestamp</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> sourceId</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> barrier</parameter>
          </paramdef>
      </funcprototype>
  </funcsynopsis>
  <funcsynopsis>
      <funcprototype>
          <funcdef>
              <type>void* </type>
              <function>fillEventCountBody</function>
          </funcdef>
          <paramdef>
              <parameter><type>pRingItem </type> pItem</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> offse</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> divisor</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> unixTime</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint64_t </type> count</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> sid</parameter>
          </paramdef>
      </funcprototype>
  </funcsynopsis>
  <funcsynopsis>
      <funcprototype>
          <funcdef>
              <type>void* </type>
              <function>fillScalerBody</function>
          </funcdef>
          <paramdef>
              <parameter><type>pRingItem </type> pItem</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> start</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> end</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> divisor</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> unixTime</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> count</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>int </type> incremental</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t* </type> pScalers</parameter>
          </paramdef>
          <paramdef>
              <parameter><type>uint32_t </type> sid</parameter>
          </paramdef>
      </funcprototype>
      </funcsynopsis>
      <funcsynopsis>
          <funcprototype>
              <funcdef>
                  <type>void* </type>
                  <function>fillTextItemBody</function>
              </funcdef>
              <paramdef>
                  <parameter><type>pRingItem </type> pItem</parameter>
              </paramdef>
              <paramdef>
                  <parameter><type>uint32_t </type> offset</parameter>
              </paramdef>
              <paramdef>
                  <parameter><type>uint32_t </type> divisor</parameter>
              </paramdef>
              <paramdef>
                  <parameter><type>uint32_t </type> unixTime</parameter>
              </paramdef>
              <paramdef>
                  <parameter><type>uint32_t </type> nStrings</parameter>
              </paramdef>
              <paramdef>
                  <parameter><type>const char** </type> ppStrings</parameter>
              </paramdef>
              <paramdef>
                  <parameter><type>int </type> sid</parameter>
              </paramdef>
          </funcprototype>
          
      </funcsynopsis>
      <funcsynopsis>
          <funcprototype>
              <funcdef>
                  <type>void* </type>
                  <function>fillStateChangeBody</function>
              </funcdef>
              <paramdef>
                  <parameter><type>pRingItem </type> pItem</parameter>
              </paramdef>
              <paramdef>
                  <parameter><type>uint32_t </type> run</parameter>
              </paramdef>
              <paramdef>
                  <parameter><type>uint32_t </type> offset</parameter>
              </paramdef>
              <paramdef>
                  <parameter><type>uint32_t </type> divisor</parameter>
              </paramdef>
              <paramdef>
                  <parameter><type>uint32_t </type> unixTime</parameter>
              </paramdef>
              <paramdef>
                  <parameter><type>const char* </type> pTitle</parameter>
              </paramdef>
              <paramdef>
                  <parameter><type>int</type>  sid</parameter>
              </paramdef>
          </funcprototype>
      </funcsynopsis>
  
          </refsynopsisdiv>
          <refsect1>
             <title>
            DESCRIPTION
             </title>
             <para>
                These functions produce dynamically allocated ring items
                that reflect the parameters that have been passed to them.
                All functions that create ring items use
                <literal>malloc(3)</literal> to allocate storage.  When you
                no longer need an item you must <literal>free(3)</literal>
                the item to prevent memory leaks.
             </para>
             <variablelist>
                <varlistentry>
                    <term>
                        <funcsynopsis>
                        <funcprototype><funcdef><type>pPhysicsEventItem</type> <function>formatEventitem</function></funcdef>
                        <paramdef>
                          <parameter><type>size_t</type> nWords</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>void*</type> pPayload</parameter>
                        </paramdef>
                        </funcprototype>
                        </funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a <literal>PHYSICS_EVENT</literal> ring item.
                            <parameter>nWords</parameter> is the number of
                            <type>uint16_t</type> objects that are in the event
                            data pointed to by <parameter>pPayload</parameter>.
                            When the ring item is created, a <type>uint32_t</type>
                            containing <literal>nWords + 2</literal> is inserted
                            prior to the payload to conform to NSCL standards
                            for the payload contents.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <funcsynopsis>
                           <funcprototype><funcdef><type>pPhysicsEventCountItem</type> <function>formatTriggerCountItem </function></funcdef>
                           <paramdef>
                              <parameter><type>uint32_t </type>runTime</parameter>
                           </paramdef>
                           <paramdef>
                            <parameter><type>time_t</type>timeStamp</parameter>
                           </paramdef>
                           <paramdef>
                            <parameter><type>uint64_t</type>triggerCount</parameter>
                           </paramdef>
                           </funcprototype>
                        </funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a <literal>PHYSICS_EVENT_COUNT</literal> ring
                            item.  <parameter>runTime</parameter> should be the
                            number of seconds into the run the items is emitted.
                            <parameter>timeStamp</parameter> should be the unix
                            <function>time(2)</function> at which the event
                            count is being submittted and <parameter>triggerCount</parameter>
                            is the total number of event triggers that have been
                            created by this point in the run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <funcsynopsis>
                            <funcprototype><funcdef><type>pScalerItem</type> <function>
                                formatScalerItem
                            </function></funcdef>
                            <paramdef>
                               <parameter><type>unsigned  </type>scalerCount </parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>time_t</type>timestamp</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>uint32_t</type> btime</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>uint32</type>etime</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>void*</type> pCounters</parameter>
                            </paramdef>
                           </funcprototype>
                        </funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a scaler ring item (<literal>INCREMENTAL_SCALERS</literal>).
                            <parameter>scalerCount</parameter> is the number of
                            scalers read out and <parameter>pCounters</parameter>
                            points to an array of <type>uint32_t</type> scalers.
                            <parameter>btime</parameter> and <parameter>etime</parameter>
                            are respectively the beginning and end run offsets
                            over which the scalers counted.
                        </para>
                        <para>
                            <parameter>timestamp</parameter> is the time at which the
                            scaler data was read.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <funcsynopsis>
                        <funcprototype><funcdef><type>pTextItem</type> <function>formatTextItem </function></funcdef>
                        <paramdef>
                           <parameter><type>unsigned  </type>nStrings </parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>time_t</type> stamp</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>uint32_t</type> runTime</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>const char**</type> pStrings</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>int</type> type</parameter>
                        </paramdef>
                       </funcprototype>
                    </funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a text ring item.  The type of the
                            ring items is provided by the <parameter>type</parameter>
                            argument however this should be one of
                            <literal>PACKET_TYPES</literal> or
                            <literal>MONITORED_VARIABLES</literal>
                            or a user type that is larger than
                            <literal>FIRST_USER_ITEM_CODE</literal>.
                        </para>
                        <para>
                            The number of strings put in the item are
                            <parameter>nStrings</parameter> and
                            <parameter>pStrings</parameter> is a pointer to an
                            array of pointers to the null terminated strings that
                            are put in the <varname>s_strings</varname> storage
                            of the ring item.
                        </para>
                        <para>
                            <parameter>stamp</parameter> is the unix
                            <function>time(2)</function> at which the
                            item was created and <parameter>runTime</parameter>
                            the number of seconds into the run at which this time
                            was created.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <funcsynopsis>
                        <funcprototype><funcdef><type>pStateChangeItem</type>
                        <function>formatStateChange </function></funcdef>
                        <paramdef>
                           <parameter><type>time_t  </type>stamp </parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>uint32_t</type> offset</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>uint32_t </type> runNumber</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>const char*</type> pTitle</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>uin32_t</type> type</parameter>
                        </paramdef>
                        
                        </funcprototype>
                    </funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Formats and returns a state change item.
                            State change items reflect a change in the run state.
                            While the <parameter>type</parameter> parameter
                            provides the item type, this should normally be one of
                            <literal>BEGIN_RUN</literal>,
                            <literal>END_RUN</literal>,
                            <literal>PAUSE_RUN</literal> or
                            <literal>RESUME_RUN</literal>.
                        </para>
                        <para>
                            <parameter>runNumber</parameter> should be a
                            unique run number for the run and
                            <parameter>pTitle</parameter> should point to a
                            null terminated title string.
                        </para>
                        <para>
                            <parameter>offset</parameter> is the time into the
                            run at which the state change took place in seconds.
                            This will be <literal>0</literal> for
                            <literal>BEGIN_RUN</literal> and the number of
                            seconds the run was active for
                            <literal>END_RUN</literal>
                        </para>
                        <para>
                            Finally <parameter>stamp</parameter> is the unix
                            absolute timestamp from <function>time(2)</function>
                            at which the state change occured.
                        </para>
                    </listitem>
                </varlistentry>
                        <!-- added in 11.0 -->
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype><funcdef><type>pScalerItem</type>
                            <function>formatNonIncrTSScalerItem</function></funcdef>
                            <paramdef>
                                <parameter><type>unsigned</type> scalerCount</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>time_t</type> timestamp</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>uint32_t</type> btime</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>uint32_t</type>  etime</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>uint64_t</type> eventTimestamp</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>void*</type> pCounters</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>uint32_t</type> timebaseDivisor</parameter>
                            </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Formats a scaler ring item
                                (<type>ScalerItem</type>) into dynamically
                                allocated data and returns a pointer to the
                                formatted item.  The item will be created with
                                the <varname>s_incremental</varname> flag of
                                the body turned off.  This is intended for
                                compatibility with code written for NSCLDAQ
                                11.1-100.
                                New code should just use
                                <function>formatTimestampedScalerItem</function>
                            </para>
                            <para>
                                The scalers are defined by
                                <parameter>scalerCount</parameter> which
                                provides the number of scalers and
                                <parameter>pCounters</parameter> which is
                                a pointer to an array of scaler values.
                                The <parameter>timestamp</parameter>,
                                <parameter>btime</parameter> and
                                <parameter>etime</parameter> values have
                                the same meaning as for
                                <function>formatScalerItem</function>
                            </para>
                            <para>
                                <parameter>eventTimestamp</parameter>
                                associates an event timestamp value with the
                                scaler item, forcing the creation of a
                                body header.  The source id and barrier type
                                of that header are both set to zero.
                            </para>
                            <para>
                                <parameter>timebaseDivisor</parameter> supports
                                <parameter>btime</parameter> and
                                <parameter>etime</parameter> parameters that have
                                resolutions less than one second.
                                The run time in seconds is gotten by
                                doing a floating point division of either of the
                                time parameters by <parameter>timebaseDivisor</parameter>
                                For example, if <parameter>btime</parameter> is
                                <literal>10</literal> and
                                <parameter>timebaseDivisor</parameter> is 4,
                                the run time is <literal>2.5</literal> seconds>
                            </para>
                            <para>
                                Note that as with all of these functions,
                                the resulting pointer is to dynamically allocated
                                memor that must be released via a call to
                                <literal>free(3)</literal>,
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                            <funcdef><type>pDataFormat</type><function>formatDataFormat</function>
                            </funcdef>
                            <void />
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Formats a <type>DataFormat</type> ring item
                                into dynamically allocated memory. A pointer
                                to the resulting ring item is returned as the
                                function value.  The caller must
                                <literal>free(3)</literal>
                            </para>
                            <para>
                                The function takes the values to put in this
                                data item from the <constant>FORMAT_MAJOR</constant>
                                and <constant>FORMAT_MINOR</constant> constant
                                values defined in <filename>DataFormat.h</filename>
                                at the time it was compiled.
                                </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef><type>pGlomParameters</type>
                                    <function>formatGlomParameters</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> coincidenceWindow</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>int</type>isBuilding</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>int</type> timestampPolicy</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Dynamically creates a <type>GlomParameters</type>
                                ring item and returns a pointer to it.
                                The <parameter>coincidenceWindow</parameter>
                                parameter determines the value of the
                                <varname>s_coincidenceTicks</varname> field
                                and the <parameter>isBuilding</parameter>
                                parameter determiens the value
                                of the <varname>s_isBuilding</varname> field.
                                <parameter>timestampPolicy</parameter> is used to
                                fill in the <varname>s_timestampPolicy</varname> field.
                            </para>
                            <para>
                                The item must be released by the caller
                                via a call to <literal>free(3)</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef><type>pEventBuilderFragment</type>
                                    <function>formatEVBFragment</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> payloadSize</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>const void*</type>
                                    pPayload</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Formats an event builder frragment item with
                                type <constant>EVB_FRAGMENT</constant>.
                                The item is dynamically allocated and must be
                                passed to <literal>free(3)</literal> to be
                                released.
                            </para>
                            <para>
                                The contents of the ring item are as follows:
                                The ring item body header is filled in from
                                <parameter>timestamp</parameter>,
                                <parameter>sourceId</parameter> and
                                <parameter>barrier</parameter>.
                                The event fragment payload size in bytes is
                                <parameter>payloadSize</parameter> and the
                                payload itself is copied in from
                                <parameter>pPayload</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef><type>pEventBuilderFragment</type>
                                    <function>formatEVBFragmentUnknown</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t timestamp</type></parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> payloadSize</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>const void*</type> pPayload</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This performs the same operation as
                                <function>formatEVBFragment</function> however
                                the ring item is given the type
                                <literal>EVB_UNKNOWN_PAYLOAD</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>pPhysicsEventItem</type>
                                    <function>formatTimestampedEventItem</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> payloadSize</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>const void*</type> pPayload</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creates an event ring item that has a full body
                                header.  The body header contents are determined
                                by the <parameter>timestamp</parameter>,
                                <parameter>sourceId</parameter> and
                                <parameter>barrier</parameter> parameters.
                                The contents of the event are <parameter>payloadSize</parameter>
                                words (16 bit words) long and are pointed to by
                                <parameter>pPayload</parameter>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>pPhysicsEventCountItem</type>
                                    <function>formatTimestampedTriggerCountItem</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> runTime</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> offsetDivisor</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>time_t</type> stamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> triggerCount</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creates a trigger count ring item that has a full
                                body header.  The body header allows trigger counts
                                to be accumulated from several event sources.
                                The body header is filled in from
                                <parameter>timestamp</parameter>,
                                <parameter>sourceId</parameter> and
                                <parameter>barrier</parameter>
                            </para>
                            <para>
                                The <parameter>runTime</parameter> and
                                <parameter>offsetDivisor</parameter> provide
                                for sub-second timing information. The
                                offset into the run in floating point seconds
                                is given by the expression
                                <literal>runTime/offsetDivisor</literal>
                            </para>
                            <para>
                                <parameter>stamp</parameter> is the unix
                                <type>time_t</type> that describes the absolute
                                time at which this item was created.  The
                                <parameter>triggerCount</parameter> item is the
                                total number of triggers the <parameter>sourceId</parameter>
                                has responded to since the beginnin of the run
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>pScalerItem</type>
                                    <function>formatTimestampedScalerItem</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type>timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>int</type> isIncremental</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> timeIntervalDivisor</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> timeofday</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> btime</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> etime</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> nScalers</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>void*</type> pCounters</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creates a scaler ring item with a full body header.
                                Scaler readout can be incremental or not and
                                the time offsets for the start and end times
                                (<parameter>btime</parameter>> and <parameter>etime</parameter>)
                                of the counting interval use
                                <parameter>timeIntervalDivisor</parameter> to
                                supply sub-second time resolution.
                            </para>
                            <para>
                                The body header values are determined by
                                <parameter>timestamp</parameter>,
                                <parameter>sourceId</parameter> and
                                <parameter>barrier</parameter>.
                            </para>
                            <para>
                                If <parameter>isIncremental</parameter>
                                is true (nonzero), the scaler values are incremental.
                                Incremental scaler values represent the number
                                of counts during the <parameter>btime</parameter>
                                <parameter>etime</parameter> interval only.
                            </para>
                            <para>
                                If <parameter>isIncremental</parameter>
                                is false (zero), the scaler values are
                                cumulative and represent the total number of
                                counts since the start of the run. 
                            </para>
                            <para>
                                The scalers themselves are pointed to by
                                <parameter>pCounters</parameter> and
                                <parameter>nScalers</parameter> tells you how
                                many there are.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>pTextItem</type>
                                    <function>formatTimestampedTextItem</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>unsigned</type> nStrings</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>time_t</type> stamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> runTime</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>const char**</type>pStrings</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>int</type> type</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> timeIntervalDivisor</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creates a text list item with a full body header.
                                The type of the ring item is determined by
                                <parameter>type</parameter>.  It should be one
                                of <literal>PACKET_TYPES</literal>,
                                <literal>MONITORED_VARIABLES</literal> or a
                                user defined type.
                            </para>
                            <para>
                                The body header contents are determined
                                by
                                <parameter>timestamp</parameter>,
                                <parameter>sourceId</parameter> and
                                <parameter>barrier</parameter>
                            </para>
                            <para>
                                The time into the run at which this item
                                was emitted in in floating point seconds is
                                <parameter>runTime</parameter>/<parameter>timeIntervalDivisor</parameter>.
                                The absolute time at which the item was created
                                is <parameter>stamp</parameter> which is a
                                Unix <type>time_t</type> value.
                            </para>
                            <para>
                                The number of strings is <parameter>nStrings</parameter>.
                                <parameter>pStrings</parameter> is an array
                                of pointers to each string, which must be
                                null terminated like all Unix strings.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>pStateChangeItem</type>
                                    <function>formatTimestampedStateChange</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>time_t</type> stamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> offset</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> runNumber</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> offsetDivisor</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>const char*</type> pTitle</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>int</type> type</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creates a state change item that has a complete
                                body header.  The <parameter>type</parameter>
                                parameter is the ring item type and should be
                                any of <literal>BEGIN_RUN</literal>,
                                <literal>END_RUN</literal>,
                                <literal>PAUSE_RUN</literal> or
                                <literal>RESUME_RUN</literal> or a user
                                defined ring item type if appropriate.
                            </para>
                            <para>
                                The body header is determine by
                                <parameter>timestamp</parameter>,
                                <parameter>sourceId</parameter> and
                                <parameter>barrier</parameter>
                            </para>
                            <para>
                                The Offset into the run at which this item
                                was emitted in seconds is:
                                <parameter>offset/offsetDivisor</parameter>.
                                The <parameter>stamp</parameter> parameter
                                is the Unix <type>time_t</type> that specifies
                                the absolute time at which the item was emitted.
                            </para>
                            <para>
                                Information about the run is also provided.
                                <parameter>runNumber</parameter> is the number
                                of the run and <parameter>pTitle</parameter>
                                points to the null terminated title string.
                            </para>
                            
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis>
                                <funcprototype>
                                    <funcdef>
                                        <type>pAbnormalEndItem</type> <function>formatAbnormalEndItem</function>
                                    </funcdef>
                                    <void />
                                </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Formats an abnormal end item and returns a pointer to the dynamically allocated
                                item. You must at some point call
                                <function>free(3)</function> to
                                release the storage allocated to this ring item.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>void*</type> <function>bodyPointer</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>pRingItem</type> pItem</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The pointer to the actual body of an item
                                depends on whether or not a body header is present
                                in the item.  This function will return a pointer
                                to the body of a ring item <parameter>pItem</parameter>
                                taking this into account.
                            </para>
                        </listitem>
                    </varlistentry>
                        <!-- end of 11.0 additions -->
                        <!-- 12.0 additions -->
                    <varlistentry>
                       <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>int  </type>
                                    <function>hasBodyHeader</function>
                      
                                </funcdef>
                                <paramdef>
                                    <parameter><type>const RingItem* </type> pItem</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns non zero if the ring item pointed to by
                            <parameter>pItem</parameter> contains a body header.
                            Note that this works both with 11.x and 12.x data
                            (e.g. it understands the body header size can be either
                            <literal>0</literal> as it is for 11.x and
                            <literal>sizeof(uint32_t)</literal>) as it is for
                            12.x
                           </para>
                           <para>
                              If there is no body header, zero is returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>void* </type>
                                    <function>bodyHeader</function>
                                    
                                </funcdef>
                                <paramdef>
                                        <parameter>RingItem* <type></type> pItem</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns a pointer to the body header of the
                            ring item pointed at by <parameter>pItem</parameter>.
                            If <parameter>pItem</parameter> has no body header
                            a <literal>nullptr</literal> is returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                          <funcsynopsis>
                              <funcprototype>
                                  <funcdef>
                                      <type>uint32_t </type>
                                      <function>itemSize</function>
                                  </funcdef>
                                  <paramdef>
                                      <parameter><type>const RingItem* </type> pItem</parameter>
                                  </paramdef>
                              </funcprototype>
                          </funcsynopsis> 
                       </term>
                       <listitem>
                           <para>
                            Returns the number of bytes that make up the
                            ring item pointed to by <parameter>pItem</parameter>.
                            This is a short cut for returning
                            <literal>pItem->s_header.s_size</literal> byte swapped
                            if needed.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>uint16_t </type>
                                    <function>itemType</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>const RingItem* </type> pItem</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the item type of the ring item pointed to by
                            <parameter>pItem</parameter>.  If necessary the
                            contents of the 
                            <literal>pItem->s_header.s_type</literal> field
                            are byte swapped before being returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                          <funcsynopsis>
                              <funcprototype>
                                  <funcdef>
                                      <type>int</type>
                                      <function>mustSwap</function>
                                  </funcdef>
                                  <paramdef>
                                      <parameter><type>const RingItem* </type> pItem</parameter>
                                  </paramdef>
                              </funcprototype>
                          </funcsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns non-zero if the ring item pointed to by
                            <parameter>pItem</parameter> was generated on a system
                            with a different byte ordering than the host.
                            Note that the actual method of byte swapping required
                            by the host to recover the original data strongly
                            depends on the data itself.  Therefore, unless otherwise
                            explicitly stated, the user of these methods is responsible
                            for actually performing any byte reordering required
                            to recover the original data in the hosts native
                            byte ordering.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>void* </type>
                                    <function>fillRingHeader</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>pRingItem </type> pItem</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> size</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> type</parameter>
                                </paramdef>
                            </funcprototype>
                            
                        </funcsynopsis>

                       </term>
                       <listitem>
                           <para>
                            Given a pointer to a ring item being formatted;
                            <parameter>pItem</parameter>, fills in the ring item
                            header with the specified <parameter>size</parameter>
                            and <parameter>type</parameter> values.
                            The return value of this function is a pointer to the
                            first byte following the ring item header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>void* </type>
                                    <function>fillBodyHeader</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>pRingItem pItem</type> </parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint64_t </type> timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> barrier</parameter>
                                </paramdef>
                            </funcprototype>
                          </funcsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Fills in the body header of a ring item pointed to
                            by <parameter>pItem</parameter> with
                            <parameter>timestamp</parameter>, <parameter>sourceId</parameter>,
                            and <parameter>barrier</parameter> (as the barrier Id).
                           </para>
                           <para>
                            Naturally it is important that <parameter>pItem</parameter>
                            point to sufficient storage to provide for at least
                            a ring item header and a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>void* </type>
                                    <function>fillEventCountBody</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>pRingItem </type> pItem</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> offset</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> divisor</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> unixTime</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint64_t </type> count</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> sid</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Fills in the ring item body pointed to by
                            <parameter>pRingItem</parameter> as an event count
                            ring item body.  <parameter>offset</parameter> is the
                            time offset into the run of at which this item was emittted,
                            and <parameter>divisor</parameter> is the divisor needed
                            to convert <parameter>offset</parameter> to seconds.
                            <parameter>unixTime</parameter> is a time from e.g.
                            <function>time</function>(2) that specifies the clock
                            time at which the item is emitted.
                           </para>
                           <para>
                            <parameter>sid</parameter> is the id of the data
                            source that is generating this ring item and
                            <parameter>count</parameter> is the number of event
                            triggers that have been honored for the run at this
                            point into the run.
                           </para>
                           <para>
                            Naturally <parameter>pItem</parameter> must point to
                            sufficient storage to hold an event count ring item body.
                            The return value is a pointer to the first byte of
                            storage following the body.
                          </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>void* </type>
                                    <function>fillScalerBody</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>pRingItem </type> pItem</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> start</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> end</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> divisor</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> unixTime</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> count</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>int </type> incremental</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t* </type> pScalers</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> sid</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Fills in the scaler item body pointed to by
                            <parameter>pItem</parameter> with the data
                            in its parameter list.   Naturally,
                            <parameter>pItem</parameter> must point to sufficient
                            storage to hold all of these data.  The return value
                            points just past the scaler item body formatted.
                           </para>
                           <para>
                            <parameter>start</parameter>, <parameter>end</parameter>
                            and <parameter>divisor</parameter> provide the time
                            offset from the beginning of the run over which the
                            scaler items counted.  <parameter>start</parameter>
                            and <parameter>end</parameter> are in arbitrary units
                            that can be converted to seconds by performing a
                            floating point division by <parameter>divisor</parameter>.
                            This provides support for sub second resolution
                           </para>
                           <para>
                            <parameter>unixTime</parameter> provides the clock time
                            (value of <function>time</function>(2)) at which the
                            scaler item was generated.
                           </para>
                           <para>
                            <parameter>count</parameter> is the number of scalers
                            to record and <parameter>pScalers</parameter> points to
                            an array of <parameter>count</parameter> <type>uint32_t</type>
                            values that are the scaler counts themselves.
                           </para>
                           <para>
                            <parameter>sid</parameter> is the id of the data source
                            producing this scaler item.  It is stored in a way
                            that makes it immune to the maniuplations the event
                            builder performs on the body header of the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>void* </type>
                                    <function>fillTextItemBody</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>pRingItem </type> pItem</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> offset</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> divisor</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> unixTime</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t </type> nStrings</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>const char** </type> ppStrings</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>int </type> sid</parameter>
                                </paramdef>
                            </funcprototype>
                            
                        </funcsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Fills in the body of the text ring item where the
                            body is pointed to by <parameter>pItem</parameter>.
                            The storage pointed to by <parameter>pItem</parameter>
                            must be large enough to contain the body, this includes
                            the strings.  The return value of this function
                            is a pointer to the next free byte of storage following
                            the filled in body.
                           </para>
                           <para>
                            <parameter>offset</parameter> and <parameter>divisor</parameter>
                            provide the offset into the run at which the item was
                            emitted and a conversion divisor to turn that
                            value into seconds. <parameter>unixTime</parameter>
                            is the clock time at which the item was created and is
                            a value returned from <function>time</function>(2).
                           </para>
                           <para>
                            The body will be filled in with <parameter>nStrings</parameter>
                            strings and <parameter>ppStrings</parameter> is a pointer
                            to an array of pointers to those strings.
                           </para>
                           <para>
                            Finally <parameter>sid</parameter> is the source id to be
                            saved in the body so that it is immune to manipulations
                            performed by the event builder on the body header of
                            the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                          <funcsynopsis>
                              <funcprototype>
                                  <funcdef>
                                      <type>void* </type>
                                      <function>fillStateChangeBody</function>
                                  </funcdef>
                                  <paramdef>
                                      <parameter><type>pRingItem </type> pItem</parameter>
                                  </paramdef>
                                  <paramdef>
                                      <parameter><type>uint32_t </type> run</parameter>
                                  </paramdef>
                                  <paramdef>
                                      <parameter><type>uint32_t </type> offset</parameter>
                                  </paramdef>
                                  <paramdef>
                                      <parameter><type>uint32_t </type> divisor</parameter>
                                  </paramdef>
                                  <paramdef>
                                      <parameter><type>uint32_t </type> unixTime</parameter>
                                  </paramdef>
                                  <paramdef>
                                      <parameter><type>const char* </type> pTitle</parameter>
                                  </paramdef>
                                  <paramdef>
                                      <parameter><type>int</type>  sid</parameter>
                                  </paramdef>
                              </funcprototype>
                          </funcsynopsis>

                       </term>
                       <listitem>
                           <para>
                            Fills the body of state change ring item.
                            The body is pointed to by <parameter>pItem</parameter>
                            which must point to sufficient storage to
                            hold the data.  The return value of this function
                            is a pointer to the first byte past the filled in
                            body.
                           </para>
                           <para>
                            The run is identified by the run number supplied
                            by <parameter>run</parameter> and a run title
                            string, <parameter>pTitle</parameter>.  The
                            maximum number of characters allowed in a title
                            string, exclusive of the null termination is
                            <literal>TITLE_MAXSIZE</literal>.  If
                            <parameter>pTitle</parameter> points to a string
                            whose length is longer than that, the string will
                            be silently truncated as it is copied into the item
                            body.
                           </para>
                           <para>
                            <parameter>offset</parameter> and <parameter>divisor</parameter>
                            provide the offset time into the run at which this
                            event was logged.  <parameter>offset</parameter>
                            is in arbitrary units which when divided by
                            <parameter>divisor</parameter> produce seconds.
                            <parameter>unixTime</parameter> is the value of
                            <function>time</function>(2), the clock time at which
                            the item is being produced.
                           </para>
                           <para>
                            Finally, <parameter>sid</parameter> is the source id
                            of the data source generating this header.  It is immune
                            from the modifications the event builder performs
                            on body headers.
                           </para>
                        </listitem>
                    </varlistentry>

  
                        <!-- end of 12.0 additions -->
                </variablelist>
          </refsect1>
          <refsect1>
            <title>RETURNS</title>
            <para>
                Pointers to dynamically allocated storage which has been
                filled in with the requested ring item.
                When the caller is done with the item it should pass it to 
                <function>free(3)</function> to release the storage.
            </para>
            <para>
                If storage could not be allocated for the ring  item
                <literal>NULL</literal> is returned instead.
            </para>
          </refsect1>
        </refentry>
	 <refentry id="daq3_cdatasource">
            <refentryinfo>
              <author>
                  <personname>
                      <firstname>Ron</firstname>
                      <surname>Fox</surname>
                  </personname>
                  <personblurb><para></para></personblurb>
              </author>
              <productname>NSCLDAQ</productname>
              <productnumber></productnumber>
            </refentryinfo>
          
       <refmeta>
          <refentrytitle id='daq3_cdatasource_title'>CDataSource</refentrytitle>
          <manvolnum>3daq</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
       </refmeta>
       <refnamediv>
          <refname>CDataSource</refname>
          <refpurpose>Abstract base class of data source for ring items.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
            <programlisting>
#include &lt;CDataSource.h&gt;
            </programlisting>
        <synopsis>
            <ooclass><classname>CDataSource</classname></ooclass>
           <constructorsynopsis>
          <methodname>CDataSource</methodname>
          <void />

           </constructorsynopsis>
           <methodsynopsis>
          <type>CRingItem*</type>
             <methodname>getItem</methodname>
             <void />
           </methodsynopsis>
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            Abstract base class for a data source that returns ring items.
            This class cannot be instantiated because the public method
            <methodname>getItem</methodname> is pure virtual.  Normally
            one gets a pointer to a <classname>CDataSource</classname> object
            when creating a data source via
            <xref endterm='daq3_cdatasourcefactory' linkend='daq3_cdatasourcefactory_title' />.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
            <term>
                <methodsynopsis>
               <type>CRingItem*</type>
                  <methodname>getItem</methodname>
                  <void />
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    This interface method will, for a concrete class, return a
                    pointer to an item received from the data source.  In the event
                    of an error, a <literal>NULL</literal> pointer will be
                    returned or alternatively an integer exception will be thrown.
                    If an integer exception is thrown its value will be a legitimate
                    error number from <literal>&lt;errno.h&gt;</literal>.
                    If a <literal>NULL</literal> is returned, the
                    <varname>errno</varname> variable should be checked to
                    determine if an end of data source condition or some other
                    error occured.  For an end of source condition, the
                    <varname>errno</varname> value will be <literal>ESUCCESS</literal>
                </para>
            </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     

	 <refentry id="daq3_cringdatasource">
            <refentryinfo>
              <author>
                  <personname>
                      <firstname>Ron</firstname>
                      <surname>Fox</surname>
                  </personname>
                  <personblurb><para></para></personblurb>
              </author>
              <productname>NSCLDAQ</productname>
              <productnumber></productnumber>
            </refentryinfo>
          
       <refmeta>
          <refentrytitle id="daq3_cringdatasource_title">CRingDataSource</refentrytitle>
          <manvolnum>3daq</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
       </refmeta>
       <refnamediv>
          <refname>CRingDataSource</refname>
          <refpurpose>Ringbuffer data source for ring items.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
            <programlisting>
#include &lt;CRingDataSource.h&gt;
            </programlisting>
        <synopsis>
            <ooclass><classname>CRingDataSource</classname></ooclass>
           <constructorsynopsis>
          <methodname>CRingDataSource</methodname>
          <methodparam>
            <type>URL&amp;</type> <parameter>url</parameter>
          </methodparam>
          <methodparam>
            <type>std::vector&lt;uint16_t&gt;</type>
            <parameter>exclusionList</parameter>
          </methodparam>
          <methodparam>
            <type>std::vector&lt;uint16_t&gt;</type>
            <parameter>sampleList</parameter>
          </methodparam>
           </constructorsynopsis>
           <methodsynopsis>
          <type>CRingItem*</type>
             <methodname>getItem</methodname>
             <void />
           </methodsynopsis>
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            Concrete <classname>CDataSource</classname> class that implements
            a source of ring items from a live ring.  See the <literal>METHODS</literal>
            section below for more information about how to create and use
            this data source directly.  Note that a more convenient mechanism
            for generating these data sources is via the
            <classname>CDataSourceFactory</classname> class.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                   <methodname>CRingDataSource</methodname>
                   <methodparam>
                     <type>URL&amp;</type> <parameter>url</parameter>
                   </methodparam>
                   <methodparam>
                     <type>std::vector&lt;uint16_t&gt;</type>
                     <parameter>exclusionList</parameter>
                   </methodparam>
                   <methodparam>
                     <type>std::vector&lt;uint16_t&gt;</type>
                     <parameter>sampleList</parameter>
                   </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a <classname>CRingDataSource</classname> object.
                        <parameter>url</parameter> specifies the ring from which
                        data is desired.  This can be a local or remote ring.
                        The url protocol must be a <literal>tcp:</literal>.
                    </para>
                    <para>
                        <parameter>exclusionList</parameter> specifies a
                        list of ring item types that will not be passed to the
                        client via <methodname>getItem</methodname>
                    </para>
                    <para>
                        <parameter>sampleList</parameter> speicfies a list
                        of ring item types that will be sampled from the ring.
                        Item types in this vector may be skipped if the client
                        application falls behind in processing the ring buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                   <type>CRingItem*</type>
                      <methodname>getItem</methodname>
                      <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the next suitable item from the ring.  This method
                        will block until a suitable item is available.  Suitability
                        is defined by the <parameter>exclusionList</parameter>
                        and <parameter>sampleList</parameter> of item types
                        provided whent he data source was constructed taken with
                        the ring backlog.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     

      <refentry id="daq3_cfiledatasource">
          <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
                <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
        
       <refmeta>
          <refentrytitle id="daq3_cfiledatasource_title">CFileDataSource</refentrytitle>
          <manvolnum>3daq</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
       </refmeta>
       <refnamediv>
          <refname>CFileDataSource</refname>
          <refpurpose>Ring item data source from a file</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <classsynopsis>
            <ooclass><classname>CFileDataSource</classname></ooclass>
           <constructorsynopsis>
          <methodname>CFileDataSource</methodname>
          <methodparam>
            <type>URL&amp;</type> <parameter>url</parameter>
          </methodparam>
          <methodparam>
            <type>std::vector&lt;uint16_t&gt;</type> <parameter>exclusionList</parameter>
          </methodparam>
          
           </constructorsynopsis>
           <methodsynopsis>
          <type>CRingItem*</type>
             <methodname>getItem</methodname>
             <void />
           </methodsynopsis>
        </classsynopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            Provides a source of ring items from a file.  For information about
            how to directly create and use this object see <literal>METHODS</literal>
            below.  The normal way to create a data source object, however is to
            use <classname>CDataSourceFactory</classname> to create the correct
            type of data source from a URI
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                      <methodname>CFileDataSource</methodname>
                      <methodparam>
                        <type>URL&amp;</type> <parameter>url</parameter>
                      </methodparam>
                      <methodparam>
                        <type>std::vector&lt;uint16_t&gt;</type> <parameter>exclusionList</parameter>
                      </methodparam>                    
                     </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a file data source.
                        <parameter>url</parameter> determines which file data
                        will be read from.  The url must have a
                        <literal>file:</literal> protocol specified.
                    </para>
                    <para>
                        <parameter>exclusionList</parameter> is a list of data
                        item types that will not be passed to the caller
                        by <methodname>getItem</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                    <type>CRingItem*</type>
                       <methodname>getItem</methodname>
                       <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Gets the next ring item from the file whose type is not
                        a type in the constructor's <parameter>exclusionList</parameter>.
                    </para>
                </listitem>
            </varlistentry>             
          </variablelist>
       </refsect1>
     </refentry>
      
     <refentry id="daq3_cdatasourcefactory">
        <refentryinfo>
          <author>
              <personname>
                  <firstname>Ron</firstname>
                  <surname>Fox</surname>
              </personname>
              <personblurb><para></para></personblurb>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
      
       <refmeta>
          <refentrytitle id="daq3_cdatasourcefactory_title">CDataSourceFactory"</refentrytitle>
          <manvolnum>3daq</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
       </refmeta>
       <refnamediv>
          <refname>CDataSourceFactory</refname>
          <refpurpose>Create data sources given a URI</refpurpose>
       </refnamediv>
       <refsynopsisdiv>
            <programlisting>
#include &lt;CDataSourceFactory&gt;
            </programlisting>
        <synopsis>
            <ooclass><classname>CDataSourceFactory</classname></ooclass>
           <methodsynopsis>
            <modifier>static</modifier>
            <type>CDataSource*</type>
             <methodname>makeSource</methodname>
             <methodparam>
                <type>std::string</type>
                <parameter>uri</parameter>
             </methodparam>
             <methodparam>
                <type>std::vector&lt;uint16_t&gt;</type>
                <parameter>sample</parameter>
             </methodparam>
             <methodparam>
                <type>std::vector&lt;uint16_t&gt;</type>
                <parameter>exclude</parameter>
             </methodparam>
           </methodsynopsis>
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This factory class contains a static method to create a ring item
            data source given a URI.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <modifier>static</modifier>
                     <type>CDataSource*</type>
                      <methodname>makeSource</methodname>
                      <methodparam>
                         <type>std::string</type>
                         <parameter>uri</parameter>
                      </methodparam>
                      <methodparam>
                         <type>std::vector&lt;uint16_t&gt;</type>
                         <parameter>sample</parameter>
                      </methodparam>
                      <methodparam>
                         <type>std::vector&lt;uint16_t&gt;</type>
                         <parameter>exclude</parameter>
                      </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new data source object and returns a pointer
                        to it.  The <classname>CDataSource</classname> object
                        created is dynamically allocated and needs to be
                        deleted by the caller.
                    </para>
                    <para>
                        <literal>uri</literal> describes the data source.
                        For a live ring this should be of the form
                        <literal>tcp://hostname/ringname</literal>
                        For a file ring this shouild be of the form
                        <literal>file:///path/to/the/file</literal>.
                    </para>
                    <para>
                        <parameter>sample</parameter> is a vector of ring item
                        types.  Ring data sources are free to skip items of this
                        type depending on circumstances.
                    </para>
                    <para>
                        <parameter>exclde</parameter> is a vector of
                        ring item types the caller does not want to get from the
                        data source.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>
    <refentry id="daq3_cringitemfactory">
        <refentryinfo>
          <author>
              <personname>
                  <firstname>Ron</firstname>
                  <surname>Fox</surname>
              </personname>
              <personblurb><para></para></personblurb>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
      
       <refmeta>
          <refentrytitle id="daq3_cringitemfactory_title">CRingItemFactory</refentrytitle>
          <manvolnum>3daq</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
       </refmeta>
       <refnamediv>
          <refname>CRingItemFactory</refname>
          <refpurpose>Upcast ring items to specific ring item objects.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
            <programlisting>
#include &lt;CRingItemFactory.h&gt;
            </programlisting>
        <synopsis>
            <ooclass><classname>CRingItemFactory</classname></ooclass>
           <methodsynopsis>
            <modifier>static</modifier>
            <type>CRingItem*</type>
             <methodname>createRingItem</methodname>
             <methodparam>
                <modifier>const</modifier><type>CRingItem&amp;</type>
                <parameter>item</parameter>
              </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>CRingItem*</type>
                <methodname>createRingItem</methodname>
                <methodparam>
                    <modifier>static</modifier><type>void*</type>
                    <parameter>pItem</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type>
                <methodname>
                    isKnownItemType
                </methodname>
                <methodparam>
                   <modifier>const</modifier>
                   <type>void*</type>
                   <parameter>pItem</parameter>
                </methodparam>
             </methodsynopsis>
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
             <classname>CRingItem</classname>
             provides a set of static methods that
             allow you to upcast ring items to actual
             underlying ring item types.  In general you
             will validate the item type via
             <methodname>isKnownItemType</methodname>
             and then invoke one o f the 
             <methodname>createRingItem</methodname>
             methods.   Finally if you need to
             use an item specific methods, you would do a
             <literal>reinterpret_cast</literal> to 
             the correct subclass of <classname>CRingItem</classname>.
          </para>
          <para>
             See <literal>METHODS</literal> below for more
             information about these functions.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
             <varlistentry>
                <term>
           <methodsynopsis>
            <modifier>static</modifier>
            <type>CRingItem*</type>
             <methodname>createRingItem</methodname>
             <methodparam>
                <modifier>const</modifier><type>CRingItem&amp;</type>
                <parameter>item</parameter>
             </methodparam>
            </methodsynopsis>
                 </term>
                 <listitem>
                    <para>
                       Creates the appropriate ring item
                       given a reference to a base class
                       ring item.  A pointer is returned
                       to the resulting object.  The
                       object is dynamically allocated
                       and therefore must be 
                       deleted by the caller.
                    </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>CRingItem*</type>
                <methodname>createRingItem</methodname>
                <methodparam>
                    <modifier>static</modifier><type>void*</type>
                    <parameter>pItem</parameter>
                </methodparam>
            </methodsynopsis>
                   </term>
                   <listitem>
                      <para>
                          Creates the appropriet ring item
                          given a pointer to storage that
                          is believed to contain a 
                          <type>RingItem</type> struct
                          as defined in 
                          <filename>DataFormat.h</filename>
                      </para>
                      <para>
                          The only difference between this
                          and the previous method is the
                          parameter type.
                      </para>
                   </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type>
                <methodname>
                    isKnownItemType
                </methodname>
                <methodparam>
                   <modifier>const</modifier>
                   <type>void*</type>
                   <parameter>pItem</parameter>
                </methodparam>
             </methodsynopsis>
                    </term>
                    <listitem>
                       <para>
                           If <parameter>pItem</parameter>
                           points to a 
                           <type>RingItem</type>
                           of a type known to the factory,
                           this method returns
                           <literal>true</literal>,
                           otherwise, <literal>false</literal>
                        </para>
                        <para>
                           The creational methods of the
                           factory will return a generic
                           ring item if they don't recognize
                           the ring type.
                        </para>
                      </listitem>
                  </varlistentry>
          </variablelist>
       </refsect1>

     </refentry>        
<refentry id="daq3_cdatasink">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
        <personblurb><para></para></personblurb>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cdatasink_title'>CDataSink</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CDataSink</refname>
     <refpurpose>Abstract base class for data sinks.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
    #include &lt;CDataSink.h&gt;
       <ooclass><classname>CDataSink</classname></ooclass> {
      <methodsynopsis>
        <modifier>virtual</modifier><type>void</type>
        <methodname>putItem</methodname>
        <methodparam>
            <modifier>const</modifier><type>CRingItem&amp;</type>
            <parameter>item</parameter>
        </methodparam>
        <modifier>=0</modifier>
      </methodsynopsis>
      <methodsynopsis>
          <modifier>virtual</modifier>
          <type>void</type>
          <methodname>put</methodname>
          <methodparam>
            <modifier>const</modifier><type>void*</type>
            <parameter>pData</parameter>
          </methodparam>
          <methodparam>
            <type>size_t</type> <parameter>nBytes</parameter>
          </methodparam>
          <modifier>=0</modifier>
      </methodsynopsis>  
};    
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        Abstract base class for data sinks.  Data sinks are objects to which
        data (usually ring items) can be sent.
     </para>
     <para>
        By deriving concrete data types
        from <classname>CDataSink</classname>, and using the
        <link linkend='daq3_cdatasinkfactory' endterm='daq3_cdatasinkfactory_title' />
        to create sinks based on a URI description of the sink, a program
        can be written that produces data for a sink without having any
        knoweldge of the details of the sink.  This allows those programs to function
        equally well regardless of the sink for which they are producing data.
     </para>
     <para>
         The base class is abstract.  See <literal>METHODS</literal> below
         for a desription of the methods a data sink must provide and
         the expectations for each method.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <methodsynopsis>
                  <modifier>virtual</modifier><type>void</type>
                  <methodname>putItem</methodname>
                  <methodparam>
                      <modifier>const</modifier><type>CRingItem&amp;</type>
                      <parameter>item</parameter>
                  </methodparam>
                  <modifier>=0</modifier>
                </methodsynopsis>
                
            </term>
            <listitem>
                <para>
                    Concrete implementations are supposed to provide strategy
                    code that writes an entire ring item to the sink.
                    <parameter>item</parameter> is a reference to the item
                    to write.  All errors should be reported by throwing a
                    <classname>CErrnoException</classname> with the
                    <varname>errno</varname> global set to a value that describes
                    the error.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual</modifier>
                    <type>void</type>
                    <methodname>put</methodname>
                    <methodparam>
                      <modifier>const</modifier><type>void*</type>
                      <parameter>pData</parameter>
                    </methodparam>
                    <methodparam>
                      <type>size_t</type> <parameter>nBytes</parameter>
                    </methodparam>
                    <modifier>=0</modifier>
                </methodsynopsis>  

            </term>
            <listitem>
                <para>
                    Concrete implementations are supposed to provide
                    stratey code that writes an arbitrary chunk of data to the sink.
                    <parameter>pData</parameter> points at the data to write
                    and <parameter>nBytes</parameter> is the number of bytes
                    to write starting at <parameter>pData</parameter>
                </para>
                <para>
                    Errors should be reported by throwing a
                    <classname>CErrnoException</classname> with
                    the global
                    <varname>errno</varname> set to a value that describes
                    the error.
                </para>
            </listitem>
        </varlistentry>
        
          
        
     </variablelist>
  </refsect1>
</refentry>
<refentry id="daq3_cfiledatasink">
    <refentryinfo>
      <author>
          <personname>
              <firstname>Ron</firstname>
              <surname>Fox</surname>
          </personname>
          <personblurb><para></para></personblurb>
      </author>
      <productname>NSCLDAQ</productname>
      <productnumber></productnumber>
    </refentryinfo>
  
  <refmeta>
     <refentrytitle id='daq3_cfiledatasink_title'>CFileDataSink</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CFileDataSink</refname>
     <refpurpose>Data sink to a disk file.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CFileDataSink&gt;
       <ooclass><classname>CFileDataSink : public CDataSink</classname></ooclass> {
      <constructorsynopsis>
        <methodname>CFileDataSink</methodname>
        <methodparam>
           <type>int</type> <parameter>fd</parameter>
        </methodparam>
     </constructorsynopsis>
    <constructorsynopsis>
           <methodname>CFileDataSink</methodname>
           <methodparam>
               <type>std::string</type> <parameter>path</parameter>
           </methodparam>
      </constructorsynopsis>
      <methodsynopsis>
          <modifier>virtual </modifier>
          <type>void </type>
          <methodname>putItem</methodname>
          <methodparam>
            <modifier>const </modifier><type>CRingItem&amp; </type>
            <parameter>item</parameter>
          </methodparam>
      </methodsynopsis>  
      <methodsynopsis>
          <modifier>virtual </modifier>
          <type>void </type>
          <methodname>put</methodname>
          <methodparam>
            <modifier>const</modifier><type> void*</type>
            <parameter>pData</parameter>
          </methodparam>
          <methodparam>
            <type> size_t</type><parameter>nBytes</parameter> 
          </methodparam>
          <modifier></modifier>
      </methodsynopsis>  
      <methodsynopsis>
          <modifier></modifier>
          <type>void </type>
          <methodname>flush</methodname>
          <void />
          <modifier></modifier>
      </methodsynopsis>  


};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        A <classname>CDataSink</classname> that writes data to a disk file.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <constructorsynopsis>
                  <methodname>CFileDataSink</methodname>
                  <methodparam>
                     <type>int</type> <parameter>fd</parameter>
                  </methodparam>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Constructs a file data sink using a file descriptor
                    <parameter>fd</parameter>.  The
                    file descriptor is something that must have come from
                    functions like <function>open</function>,
                    <function>dup</function>, <function>socket</function> etc.
                    Note that this implies that <classname>CFileDataSink</classname>
                    can actually send data to anything that can be
                    represented by a file descriptor.
                </para>
                <para>
                    If <parameter>fd</parameter> is not writable (e.g. was opened
                    as <literal>O_RDONLY</literal>) an
                    <classname>std::string</classname> exception is thrown
                    with text indicating this fact
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <constructorsynopsis>
                     <methodname>CFileDataSink</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>path</parameter>
                     </methodparam>
                </constructorsynopsis>

            </term>
            <listitem>
                <para>
                    Creates a file data sink that sinks to the
                    <parameter>path</parameter> in the filesystem.
                    <parameter>path</parameter> must be able to be created
                    and written to once created.  If <parameter>path</parameter>
                    already exists, all data are overwritten.
                </para>
                <para>
                    If the file could not be opened for write, an
                    <classname>std::string</classname> exceptionis
                    thrown indicating this fact.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>putItem</methodname>
                    <methodparam>
                      <modifier>const </modifier><type>CRingItem&amp; </type>
                      <parameter>item</parameter>
                    </methodparam>
                </methodsynopsis>  

            </term>
            <listitem>
                <para>
                    Puts a ring item (<parameter>item</parameter>), to file.
                    Any failure is signalled by a <classname>CErrnoException</classname>
                    whose <methodname>ReasonCode</methodname> reflects the
                    <varname>errno</varname> at the time of the failing function
                    call.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>put</methodname>
                    <methodparam>
                      <modifier>const</modifier><type> void*</type>
                      <parameter>pData</parameter>
                    </methodparam>
                    <methodparam>
                      <type> size_t</type><parameter>nBytes</parameter> 
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>                  
            </term>
            <listitem>
                <para>
                    Writes <parameter>nBytes</parameter> of arbitraty data
                    pointed to by <parameter>pData</parameter> to the file.
                    Errors are signalled via <classname>CErrnoException</classname>
                    exceptions.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>flush</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Ensures that any data buffered by the operating system
                    is actually written to the objet identified by the
                    sink file descriptor.
                    <methodname>flush</methodname> will block until this has
                    happened.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
</refentry>     
<refentry id="daq3_cringdatasink">
    <refentryinfo>
      <author>
          <personname>
              <firstname>Ron</firstname>
              <surname>Fox</surname>
          </personname>
          <personblurb><para></para></personblurb>
      </author>
      <productname>NSCLDAQ</productname>
      <productnumber></productnumber>
    </refentryinfo>
  
  <refmeta>
     <refentrytitle id="daq3_cringdatasink_title">CRingDataSink</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CRingDataSink</refname>
     <refpurpose>Data sink that writes to a <classname>CRingBuffer</classname>
     </refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CRingDataSink.h&gt;    
       <ooclass><classname>CRingDataSink : public CDataSink</classname></ooclass> {
      <constructorsynopsis>
     <methodname>CRingDataSink</methodname>
     <methodparam>
        <type>std::string</type> <parameter>ringName</parameter>
     </methodparam>
    </constructorsynopsis>
    <methodsynopsis>
        <modifier>virtual</modifier>
        <type>void</type>
           <methodname>putItem</methodname>
           <methodparam>
            <modifier>const</modifier> <type>CRingItem&amp;</type>
            <parameter>item</parameter>
           </methodparam>
           <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>virtual</modifier>
        <type>void</type>
        <methodname>put</methodname>
        <methodparam>
            <modifier>const</modifier><type>void*</type>
            <parameter>pData</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>nBytes</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        Provides a <classname>CDataSink</classname> that puts data into a
        <classname>CRingBuffer</classname> as with all ring buffer producers,
        the ring buffer must be local to the system on which the program runs.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                 <constructorsynopsis>
               <methodname>CRingDataSink</methodname>
               <methodparam>
                  <type>std::string</type> <parameter>ringName</parameter>
               </methodparam>
              </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Creates a ring data sink object using the
                    <parameter>ringName</parameter> as the destination for data.
                    If <parameter>ringName</parameter> does not yet exist it is
                    created.  If the ring exists and already has a producer,
                    an <classname>CErrnoException</classname> is thrown with the
                    <literal>EACCES</literal> errno value.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                  <modifier>virtual</modifier>
                  <type>void</type>
                     <methodname>putItem</methodname>
                     <methodparam>
                      <modifier>const</modifier> <type>CRingItem&amp;</type>
                      <parameter>item</parameter>
                     </methodparam>
                     <modifier></modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Inserts the ring item <parameter>item</parameter> into the
                    underlying ring buffer.  If necessary, this method will
                    block until sufficient free put space is available in the ring
                    buffer.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                  <modifier>virtual</modifier>
                  <type>void</type>
                  <methodname>put</methodname>
                  <methodparam>
                      <modifier>const</modifier><type>void*</type>
                      <parameter>pData</parameter>
                  </methodparam>
                  <methodparam>
                      <type>size_t</type><parameter>nBytes</parameter>
                  </methodparam>
                  <modifier></modifier>
              </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Inserts <parameter>nBytes</parameter> of arbitraty data
                    to the underlying ring.  The data inserted are pointed to
                    by <parameter>pData</parameter>.  If necessary this method
                    blocks untile sufficient free put space is available.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
</refentry>
<refentry id="daq3_cdatasinkfactory">
    <refentryinfo>
      <author>
          <personname>
              <firstname>Ron</firstname>
              <surname>Fox</surname>
          </personname>
          <personblurb><para></para></personblurb>
      </author>
      <productname>NSCLDAQ</productname>
      <productnumber></productnumber>
    </refentryinfo>
  
  <refmeta>
     <refentrytitle id="daq3_cdatasinkfactory_title">CDataSinkFactory</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CDataSinkFactory</refname>
     <refpurpose>Create an appropriate CDataSink object</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
       <ooclass><classname>CDataSinkFactory</classname></ooclass> {
      <methodsynopsis>
        <modifier>virtual</modifier><type>CDataSink(</type>
        <methodname>makeSink</methodname>
        <methodparam>
            <type>std::string</type> <parameter>uri</parameter>
        </methodparam>

        <modifier></modifier>
      </methodsynopsis>
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        Factory for data sinks.  Note that if you define your own type of data
        sink you can extend this factory by deriving and overriding
        <methodname>makeSink</methodname>.  Just be sure to pass any
        unrecognized uri protocols to the base class
        <methodname>makeSink</methodname>.
     </para>
     <para>
        
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <para>
        The factory only has a single public method: <methodname>makeSink</methodname>.
        This method takes a single <type>std::string</type> parameter; a URI
        that describes the sink to create.  On success, this factory method
        returns
        a pointer to a dynamically allocated <classname>CDataSink</classname>.
        It is the caller's responsibility to <function>delete</function>
        this object.
     </para>
     <para>
        To understand how this function works, we need to first look at the
        structure of a URI (Uniform Resource Identifier).  The generic
        form of a URI is:
     </para>
     <informalexample>
        <cmdsynopsis>
            <command>
<replaceable>protocol:</replaceable>//<replaceable>host</replaceable><optional>:port</optional>/<replaceable>path</replaceable>
            </command>
        </cmdsynopsis>
     </informalexample>
     <para>
        The protocol part of the URI identifies the type of sink to create.
     </para>
     <para>
        <literal>file</literal> protocols create <classname>CFileDataSink</classname>
        objects.  For those the <replaceable>host</replaceable> and <replaceable>port</replaceable>
        are ignored and the <replaceable>path</replaceable> identifies the file
        system path at which the sink file is created.
    </para>
     <para>
        <literal>ring</literal> or <literal>tcp</literal> protocols will create
         a ring data source.  The <replaceable>path</replaceable> is the ring name.
         <replaceable>host</replaceable> must either be empty or be
          <literal>localhost</literal> or an error is thrown.
     </para>
     <para>
        The special value of <literal>-</literal> for the URI will create
        a <classname>CFileDataSink</classname> open on the program's
        standard output.  This facilitates opening sinks for programs used
        in filter pipelines.
     </para>
  </refsect1>
</refentry>

<!-- 11.4 additions -->

<refentry>
    <refmeta>
        <refentrytitle>CRingBufferChunkAccess</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingBufferChunkAccess</refname>
        <refpurpose>Provides zero copy, low level consumer access to ring buffers</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
class CRingBufferChunkAccess {
public:
    class Chunk {
    public:
        class iterator {
        public:
            iterator(void* pStorage, size_t bytes);
            iterator(const iterator&amp; rhs);
            iterator&amp; operator=(const iterator&amp; rhs);
            bool operator==(const iterator&amp; rhs) const;
            
            pRingItemHeader operator-&gt;();
            RingItemHeader&amp; operator*();
            iterator&amp; operator++();         
            iterator  operator++(int);      
        };
        Chunk();
        void setChunk(size_t bytesInChunk, void* pStorage);
    
        void* getStorage();
        size_t size() const;
        iterator begin();
        iterator end();
    };

public:
    CRingBufferChunkAccess(CRingBuffer* pRingBuffer);
    size_t waitChunk(size_t maxChunk, int polls = 0, int usecPoll = 0);
    Chunk nextChunk();
    
};

      </synopsis>
        
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
          The <classname>CRingItem</classname> class provides a convenient
          method to create and commit ring items to a ring buffer as well
          as to consumer ring items from a ring buffer.  The downside of this
          convenience is that data must be copied, sometimes several times.
          This class provides consumers with zero copy access to ring items
          in a ring buffer.
        </para>
        <para>
          The model is that the user asks for, and eventually gets,
          a <firstterm>chunk</firstterm> of items.  For the most part
          chunks represent a contiguous block of items in the ring buffer
          shared memory that have been produced but not yet consumed
          by this consumer.  The user can then create an iterator which
          allows them to obtain individual items from the chunk.
        </para>
        <para>
          The class handles the (rare for ring item sizes &gt;&gt; than the
          typical ring item) case where a ring item wraps by creating
          a single item chunk that's been copied from the ring buffer into
          a contiguous block of local memory.
        </para>
        <para>
          Each invocation of <methodname>nextChunk</methodname>
          releases the ring items the previous chunk contains allowing that
          storage in the ring buffer to be re-used by the producer.
        </para>
    </refsect1>
    <refsect1>
      <title>METHODS of CRingBufferChunkAccess</title>
      <variablelist>
        <varlistentry>
            <term>
              <constructorsynopsis>
                  <methodname>CRingBufferChunkAccess</methodname>
                <methodparam>
                    <type>CRingBuffer* </type><parameter>pRingBuffer</parameter>
                </methodparam>
              </constructorsynopsis>
            </term>
            <listitem>
                <para>
                  Constructs a zero copy ring item accessor.
                  <parameter>pRingBuffer</parameter> is a pointer to a
                  <classname>CRingBuffer</classname> object that must have been
                  created as a consumer.  If this pointer does not represent
                  a current consumer to the ring buffer, a
                  <classname>std::logic_error</classname> exception is thrown.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type>size_t </type>
                <methodname>waitChunk</methodname>
                <methodparam>
                    <type>size_t </type><parameter>maxChunk</parameter>
                </methodparam>
                
                <methodparam>
                    <type> int </type><parameter>polls </parameter>
                    <initializer>= 0</initializer>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter>usecPoll</parameter>
                    <initializer> = 0</initializer>
                </methodparam>
                <modifier></modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Blocks the caller until the appropriate condition is met.
                  The block ends when there's at least
                  <parameter>maxChunk</parameter> bytes of data waiting to
                  be consumed by the client.
                  While blocking the client blocks for <parameter>usecPoll</parameter>
                  microseconds between each check of the number of bytes available.
                  If <parameter>polls</parameter> checks have been done,
                  blocking ends.
                </para>
                <para>
                  Regardless of why or how this method returns, the return value
                  is the number of bytes of data available for consumption.
                  Note that this may, in fact be zero.  NSCLDAQ ring items
                  are inserted by our software atomically, which implies that if
                  the return value is nonzero there will be at least one ring item
                  available for consumption.
                </para>
                <para>
                  The defaults for <parameter>polls</parameter> means the
                  method  will return immediately.  The default for
                  <parameter>usecPoll</parameter> mean that the program will
                  spin wait.  For true blocking, both should be non-zero, where
                  <parameter>usecPoll</parameter>*<parameter>polls</parameter>
                  determines the maximum wait time and
                  <parameter>usecPoll</parameter> the desired maximum latency for
                  ending the block.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type>CRingBufferChunkAccess::Chunk </type>
                <methodname>nextChunk</methodname>
                <void />
                <modifier></modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the next chunk as a
                  <classname>CRingBufferChunkAccess::Chunk</classname> object.
                  This chunk is only valid until the next call to
                  <methodname>nextChunk</methodname>.  The size of the chunk
                  depends on ow much data is available at the time of the call
                  and where the top of the ring buffer is relative to the
                  get pointer for this client.
                </para>
                <para>
                  See
                  <literal>CRingBufferChunkAccess::Chunk METHODS</literal> below
                  for the methods defined on a chunk.
                </para>
            </listitem>
        </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>CRingBufferChunkAccess::Chunk METHODS</title>
      <variablelist>
        <varlistentry>
            <term>
              <constructorsynopsis>
                  <methodname>Chunk</methodname>
                <void />
              </constructorsynopsis>
            </term>
            <listitem>
                <para>
                  Constructs an empty chunk.  Note that user code does not need
                  to call this, only the
                  <classname>CRingBufferChunkAccess</classname>::<methodname>nextChunk</methodname>
                  method.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type>void </type>
                <methodname>setChunk</methodname>
                <methodparam>
                    <type>size_t</type><parameter> bytesInChunk</parameter>
                </methodparam>
                <methodparam>
                    <type>void* </type><parameter>pStorage</parameter>
                </methodparam>
                <modifier></modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Sets the pointer and size of the storage associated with a chunk
                  Again, this normally does not have to be called by user level
                  code,
                  <classname>CRingBufferChunkAccess</classname>::<methodname>nextChunk</methodname>
                  will invoke this to initialize the chunk it hands back to the
                  user.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type>void*</type>
                <methodname>getStorage</methodname>
                <void />
                <modifier></modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the pointer to the chunk's data.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type>size_t </type>
                <methodname>size</methodname>
                <void />
                <modifier> const</modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the number of bytes in the chunk.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type>CRingBufferChunkAccess::Chunk::iterator </type>
                <methodname>begin</methodname>
                <void />
                <modifier></modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns an iterator to the first item in the chunk.
                  See
                  <literal>CRingBufferChunkAccess::Chunk::iterator METHODS</literal>
                  below for the things you can do with an iterator.
                </para>
                <para>
                  Suffice to say that iterators behave like STL forward iterators.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type>CRingBufferChunkAccess::Chunk::iterator</type>
                <methodname> end</methodname>
                <void />
                <modifier></modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns an end of iteration iterator.  This iterator can be
                  though of as pointing just off the end of the chunk.
                </para>
            </listitem>
        </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>CRingBufferChunkAccess::Chunk::iterator METHODS</title>
      <para>
        Normally your code does not explicitly construct an iterator.
        Instead, the <classname>CRingBufferChunkAccess::Chunk</classname>
        you got from the ring buffer will be used to construct
        iterators that allow you to iterate over the ring items in
        that chunk.
      </para>
      <variablelist>
        <varlistentry>
            <term>
              <constructorsynopsis>
                  <methodname>
                    iterator
                  </methodname>
                <methodparam>
                    <type>void*</type><parameter> pStorage</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t </type><parameter>bytes</parameter>
                </methodparam>
              </constructorsynopsis>
            </term>
            <listitem>
                <para>
                  Constructs an iterator of ring items on an arbitrary
                  chunk of storage.  Normally the
                  <classname>CRingBufferChunkAccess::Chunk</classname>::<methodname>begin</methodname>
                  method uses this.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <constructorsynopsis>
                  <methodname>iterator</methodname>
                <methodparam>
                    <modifier>const </modifier>
                    <type>iterator&amp; </type><parameter>rhs</parameter>
                </methodparam>
              </constructorsynopsis>
            </term>
            <listitem>
                <para>
                  Copy constructor for iterators.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type>iterator&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const </modifier>
                    <type>iterator&amp; </type><parameter>rhs</parameter>
                </methodparam>
                <modifier></modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Supports assignment of iterators.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type> bool </type>
                <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const </modifier>
                    <type>iterator&amp;</type><parameter> rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Supports comparison of two iterators for equality.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type>pRingItemHeader </type>
                <methodname>operator-&gt;</methodname>
                <void />
                <modifier></modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Supports field dereferincing an iterator as if it were a pointer
                  to a Ring item header e.g. given an iterator p,
                  <literal>p->s_type</literal> is the ring item type.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type>RingItemHeader&amp; </type>
                <methodname>operator*</methodname>
                <void />
                <modifier></modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Supports dereferencing an iterator as if it were a pointer
                  to a ring item header.  For example, given an iterator p,
                  <literal>reinterpret_cast&lt;pRingItem&gt;(&amp;(*p))</literal>
                  produces a pointer to the ring item as a whole.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type>iterator&amp;</type>
                <methodname>operator++</methodname>
                <void />
                <modifier></modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Pre increments an iterator.  That is the iterator is incremnted
                  and a reference to the resulting incremented iterator
                  is returned.  This is the most efficient increment.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
              <methodsynopsis>
                <modifier></modifier>
                <type>iterator  </type>
                <methodname>operator++</methodname>
                <methodparam>
                    <type>int</type><parameter></parameter>
                </methodparam>
                <modifier></modifier>
              </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Supports post incrementing an iterator. A copy of the iterator
                  is produced, the iterator is incremented and a copy of the
                  iterator prior to the increment is returned.  In general,
                  this requires two copies of the iterator.
                </para>
            </listitem>
        </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>Public Data and Types</title>
      <variablelist>
        <varlistentry>
            <term>
              <type>size_t</type> <classname>CRingBufferChunkAccess</classname>::<varname>m_RingBufferBytes</varname>
            </term>
            <listitem>
                <para>
                  Contains the number of bytes in the underlying ring buffer.
                  This should be treated as readonly but for implementation
                  reasons cannot  be declared const.
                </para>
            </listitem>
        </varlistentry>
      </variablelist>
    </refsect1>
</refentry>

<!-- /manpage  -->
