<!-- manpage 3vmusb -->
            <!--  adc command reference -->
            
<refentry id="vmusb3-adc">
     <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
	    <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle>adc</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
     <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>adc</refname>
     <refpurpose>Create/configure CAEN V775, V785, V792, V862 modules.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
adc create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
	<command>
caenv965 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
adc config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
caenv956 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
adc cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
caenv956 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>

  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	This command creates, configures and retrieves the configuration of
        CAEN V775, V785, V792, and V862, V965 digitizer modules.
     </para>
     <para>
         Use the <command>create</command> subcommand to create a new adc
         providing it with a unique <parameter>name</parameter> that will
         be used to identify it in future commands.  The <parameter>base</parameter>
         parameter is the base address of the module as set in the module rotary
         switches.
     </para>
      <para>
         Use the <command>config</command> subcommand to configure
         a module named <parameter>name</parameter>  the <parameter>option</parameter>
         options and legal values are described in the section OPTIONS below.
      </para>
      <para>
         The <command>cget</command> subcommand returns as its value the configuration
         of the module <parameter>name</parameter>.  The configuration is
         returned as a list of two element sublists where each sublist
         contains, in order, an option from OPTIONS below, and its value.
         Note that some values may themselves be lists.
      </para>
      <para>
        When used with the CAEN V965 or other dual range digitizers via the
	caenv956 command, each parameter specified in the <varname>adcChannels</varname>
	array will result in two SpecTcl channels and corresponding raw spectra.
	The first will have
	<literal>.h</literal> appended to the name and will be the high range
	conversion while the second will have <literal>.l</literal> appended to the
	name and will be the low range value.
      </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	<varlistentry>
	    <term><command>-base</command> <replaceable>value</replaceable></term>
	    <listitem>
		<para>
                  Allows you to reconfigure the base address of a module.
		  This defaults to <literal>0</literal>.  The required
		  <parameter>base</parameter> parameter of the create
		  command for this device overrides the default value.
		</para>
	    </listitem>
	 </varlistentry>
         <varlistentry>
            <term><command>-commonstop</command> <replaceable>value</replaceable></term>
            <listitem>
                <para>
                    This is only usable with a V775.  <parameter>value</parameter>
                    is a boolean value which, if true runs the module in common
                    stop mode.  If false (the default), the module is run in common
                    start mode.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>-inputs</command> <replaceable>ribbon | nim</replaceable>
            </term>
            <listitem><para>
                This is interpreted by SpecTcl 7.0-001 and later.  It allows it to 
                distinguish between the N series (NIM Inputs) of digitizer and the others
                (Ribbon cable inputs).  The channel number decoding differs between these module types.
                Prior to the addition of this option, users of the N series digitizers (e.g. 785N)
                had to specify only every other channel name for the decode to work correctly.
                If one configures the module instead with <literal>-inputs nim</literal>
                SpecTcl 7.0-001 and later can handle tight packed parameter definitions.
            </para><para>
                If not specified this defaults to <literal>ribbon</literal> with the
                behavior before the addition of this option.
            </para></listitem>
        </varlistentry>
         <varlistentry>
            <term><command>-thresholds</command> <replaceable>values</replaceable></term>
            <listitem>
               <para>
                  The value is a list of 32 values that are the module 
                  thresholds.  Unless <option>-smallthresholds</option> has been
                  configured to be <literal>true</literal>, these values
                  are multiplied by 16 before being applied as the channel
                  threshold values.
               </para>
	       <para>
		    The value defaults to a list of 32 zeros.
	       </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-smallthresholds</command> <replaceable>bool</replaceable></term>
            <listitem>
               <para>
                  The value is a boolean (e.g. <emphasis>on</emphasis> or
                  <emphasis>off</emphasis>).
                  A true boolean means that the threshold is applied as is
                  a false boolean means the threshold value is multiplied by 16
                  and then applied.
               </para>
	       <para>
		    This parameter defaults to <literal>false</literal>.
	       </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-ipl</command> <replaceable>0-7</replaceable></term>
            <listitem>
               <para>
                  The interrupt priority level the module should use to request
                  a VME bus interrupt.  This defaults to 6 and should be set to
                  zero to disable interrupts.  Normally interrupts will be used
                  to trigger an interrupt triggered stack.  The default of 6
                  is historical in nature, in most cases for,
                  the default should be overridden to zero.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-vector</command> <replaceable>0-255</replaceable></term>
            <listitem>
               <para>
                  The interrupt vector the module should use. This is an integer
                  and defaults to 0x80.  The vector value is ignored if the
                  module interrupts are disabled.
               </para>
	       <para>
		    Note that the VMUSB processes 16 bit vectors, but the
		    vector produced by this series of modules is 8 bits wide.
		    The VME standard is ambiguous about how such modules
		    produce the top eight bits of the vector under these
		    circumstances.  These modules set those top bits
		    to zero.  E.g. <option>-vector </option> <literal>0x80</literal>
		    produces a vector, as see by the VMUSB of <literal>0x0080</literal>
	       </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-highwater</command> <replaceable>0-31</replaceable></term>
            <listitem>
               <para>
                  Defines how many events the module should accumulate before
                  it interrutps.  A value of zero also disables interrupts.
                  The default value is 24 events (75% full).  This is best suited for
                  singles applications where allowing the module to accumulate
                  a few events before being read is a good thing.
                  This value will be ignored if the <option>-ipl</option> option
                  has been configured to zero as that also disables module interrupts.
               </para>
	       <para>
		    If you want to use interrupts but in single event mode,
		    you should set this to <literal>1</literal>.  If you don't
		    want to use interrupts you should set at least set one of
		    <option>-highwater</option>, <option>-vector</option>
		    or <option>-ipl</option> to zero as any of those actions
		    disables interrupts.
	       </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-geo</command> <replaceable>0-31</replaceable></term>
            <listitem>
               <para>
                  Defines the geographical address that will be set in the module.
                  If the module has a PAUX connector, this must be set to be
                  the module's physical location in the crate.  This option must
                  be correctly programmed in order to help SpecTcl form a mapping
                  between data values and parameter names.
               </para>
	       <para>
		    The default for this value is an empty string which is
		    not legal.  Therefore it is mandatory that you configure
		    this option.
	       </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-fastclear</command> <replaceable>value</replaceable></term>
            <listitem>
               <para>
                  Defines the fast clear window for the module.  This defaults to
		  <literal>0</literal> and therefore must be configured if you
		  will use the fast clear capability of the module.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-supressrange</command> <replaceable>bool</replaceable></term>
            <listitem>
               <para>
                  If <literal>true</literal> the module will supress overflows
                  and under threshold conversions.  If not all channels will
                  supply data for an event.  In most cases, this should be set to
                  <literal>false</literal>.  This defaults to <literal>true</literal>
               </para>
	       <para>
		    Often when setting up the module it is a good idea to
		    take data with <option>-supressrange</option> set to
		    <literal>false</literal> to get an idea of where
		    the thresholds are.
	       </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-timescale</command> <replaceable>ns</replaceable></term>
            <listitem>
               <para>
                  Sets the full scale range of the module if it is a V775.
                  If the module is not a V775 TDC, this configuration parameter
                  is silently ignored (the hardware allows the software to
                  determine the module type).  <parameter>ns</parameter> is the
                  range of the TDC in nanoseconds and must be between
                  <literal>140</literal> and <literal>1200</literal>.
               </para>
	       <para>
		    This value defaults to <literal>600</literal>
	       </para>
            </listitem>
         </varlistentry>
	 <varlistentry>
	   <term><command>-iped</command> <replaceable>value</replaceable></term>
	   <listitem>
	      <para>
                 Sets the Iped register.  See section 4.34 of e.g. the
		 CAEN V965 manual.   This register controls the amount of charge
		 initially injected into the conversion circuit and is used to
		 compensate for leakage current that may lower the conversion of
		 a signal during the gate.  The default value is
		 <literal>180</literal>.  Valid values
		 are <literal>0 - 255</literal>, however see the description of
		 the Iped register and pedestal injections in the manual.
	      </para>
            </listitem>
         </varlistentry>
	 <varlistentry>
	      <term><option>-requiredata</option> <replaceable>yes | no</replaceable></term>
	      <listitem>
		  <para>
		    This boolean parameter (actually any value Tcl accepts
		    as a boolean is valid) defaults to <literal>false</literal>.
		    When <literal>true</literal>, the module is required to
		    provide at least a header and a trailer when read as long
		    as there was a pulse in the <literal>gate</literal>
		    input.   Headers and trailers will be output even if none
		    of the channels satisfied the over and under range values
		    with <option>-suppressrange</option> <literal>true</literal>.
		  </para>
	      </listitem>
	  </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Sample ADC commands</title>
         <programlisting>
adc create adc1    0x04000000
adc config adc1    -geo 12 -supressrange off  -ipl 0 -vector 0
         </programlisting>
      </example>
      <para>
         Defines a module with base address 0x04000000 to be in geographical
         address 12.  Range supression and interrupts are disabled.
      </para>
  </refsect1>
  <refsect1>
      <title>NOTES</title>
      <para>
         This command can actually initialize/configure V775 TDCs and
         V792, V862 QDCs in addition to the V785 ADC.
      </para>
  </refsect1>
</refentry>
   <!-- caenchain command - aggregate 785's into CBLT chains -->
            
   <refentry id="vmusb3-caenchain">
     <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
	    <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
     <refmeta>
        <refentrytitle>caenchain</refentrytitle>
        <manvolnum>3vmusb</manvolnum>
        <refmiscinfo class='empty'></refmiscinfo>
     </refmeta>
     <refnamediv>
        <refname>caenchain</refname>
        <refpurpose>Aggregate adc modules into CBLT readout chains.</refpurpose>
     </refnamediv>
     
     <refsynopsisdiv>
       <cmdsynopsis>
   	<command>
caenchain create <replaceable>name</replaceable>
   	</command>
       </cmdsynopsis>
           <cmdsynopsis>
               <command>
caenchain config <replaceable>name option value...</replaceable>
               </command>
         </cmdsynopsis>
             <cmdsynopsis>
                 <command>
caenchain cget <replaceable>name</replaceable>
                 </command>
             </cmdsynopsis>
         
     </refsynopsisdiv>
     <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The CAEN family of 32 channel digitizers (V775, V785, V792, V862)
            can be aggreaged into CBLT readout chains.  A CBLT readout chain can
            then be read at high performance using a single block read operation.
        </para>
        <para>
            A CBLT chain consists of a set of at least two modules in consecutive
            VME bus slots.  From the point of view of defining the crate the
            left most and right most modules are special.  (See OPTIONS below,
            the <option>-module</option> option). 
        </para>
        <para>
            CBLT chains require an additional base address that is used to read
            the modules.  This address is also used as a multicast address to
            do a simultaneous clear of all modules in the chain as the readout
            is initialized (at the beginning of a run). 
        </para>
     </refsect1>
     <refsect1>
        <title>
   	OPTIONS
        </title>
        <variablelist>
   	<varlistentry>
   	    <term><option>-base</option> <replaceable>integer</replaceable></term>
   	    <listitem>
   		<para>
                  Provides the base address to be used to program the CBLT and
		  multicast
                  address of the module.  Only the top two hexadecimal digits
                  of an 8 digit hexadecimal address should be non zero. e.g.
                  <literal>0x12000000</literal> is ok, but
                  <literal>0x12340000</literal> is not.
   		</para>
		<para>
		    The default for ths value is <literal>0</literal>.
		</para>
   	    </listitem>
   	</varlistentry>
        <varlistentry>
            <term><option>-modules</option> <replaceable>module-names</replaceable></term>
            <listitem>
            <para>
               Supplies the list of modules that should make up the chain. The
               firs module must be the left most in the chain, the last module the
               right most.  Other than that order is unimportant, however note that
               CBLT readouts always will go from left to right in VME crate. I therefore
               suggest that you supply the modules in left to right order.
               The modules must be a valid TCL list, e.g.:
               <literal>-modules [list adc1 adc2 adc3]</literal> is ok,
               <literal>-modules adc1 adc2 adc3</literal> is not.
            </para>
	    <para>
	       The default for this value is an empty list.  Note that at least
	       a first and last module must be defined for this to work
	       properly.
	    </para>
            </listitem>
         </varlistentry>
        </variablelist>
     </refsect1>

     <refsect1>
        <title>EXAMPLES</title>
        <para>
            The example below takes three ADC modules and aggregates them
            into a chain for readout.
            <example>
               <title>Using the <command>caenchain</command> command.</title>
               <programlisting>
adc create adc1    0x04000000
adc config adc1    -geo 12 -supressrange off  -ipl 0 -vector 0

adc create adc2    0x05000000
adc config adc2    -geo 13 -supressrange off  -ipl 0 -vector 0

adc create adc3    0x06000000
adc config adc3    -geo 14 -supressrange off -ipl 0 -vector 0


caenchain create chain

caenchain config chain -base 0x10000000 -modules [list adc1 adc2 adc3]
               </programlisting>
            </example>
        </para>
     </refsect1>

   </refentry>
   <!-- VM USB control and scaler readout -->
   
         <refentry id="vmusb3_vmusb">
            <refentryinfo>
                <author>
                    <personname>
                        <firstname>Ron</firstname>
                        <surname>Fox</surname>
                    </personname>
		    <personblurb><para></para></personblurb>
                </author>
                <productname>NSCLDAQ</productname>
                <productnumber></productnumber>
              </refentryinfo>
           <refmeta>
              <refentrytitle id='vmusb3_vmusb_title'>vmusb</refentrytitle>
              <manvolnum>3vmusb</manvolnum>
              <refmiscinfo class='empty'></refmiscinfo>
           </refmeta>
           <refnamediv>
              <refname>vmusb</refname>
              <refpurpose>Control VM-USB resources and read internal scalers</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
             <cmdsynopsis>
                <command>
vmusb create name ?options?
                </command>
             </cmdsynopsis>
            <cmdsynopsis>
                <command>
vmusb config name ?options?
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
vmusb cget name
                </command>
            </cmdsynopsis>

           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
                The <command>vmusb</command> command can be used in the
                <filename>daqconfig</filename> configuration file to control
                the internal reasources of the VM-USB as well as to enable
                the readout of its pair of scalers.  The VM-USB provides two outputs
                named O1 and O2 as well as a pair of gate and delay generators
                (DGGA and DGGB), and scalers A and B. Four LEDs round out the
                resources controlled by this command.
              </para>
              <para>
                In order to use a vmusb module to configure the controller, you
                must include it in a stack, even if you are not using reading the
                scalers in the VM-USB.  This is because it is the inclusion of
                a module in a stack that causes its initialization methods to
                be invoked, and it is there that teh vmusb module configures
                its resources.
              </para>
              <para>
                More information about the VM-USB and its resources can be found
                in sections 3.4.4 through 3.4.8 and section 1 of the VM-USB manual.
              </para>
              <para>
                The configuration options are described in the OPTIONS section
                below.
              </para>
           </refsect1>
           <refsect1>
              <title>
                 OPTIONS
              </title>
              <variablelist>
                <!-- NIM output configuration  -->
                <varlistentry>
                    <term><option>-nimo1</option></term>
                    <listitem>
                        <para>
                            Determines, along with the options
                            <option>-inverto1</option> and
                            <option>-latcho1</option> the behavior of NIM
                            output O1.  This can be any of the following values:
                            <literal>busy, trigger, busrequest, eventdatatobuvffer,
                            dgga, endevent</literal> or <literal>usbtrigger</literal>.
                        </para>
			<para>
			 If not explicitly programmed, this defaults to
			 <literal>busy</literal>.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-inverto1</option></term>
                    <listitem>
                        <para>
                            Inverts the sense of the O1 nim output.  By default
			    this is <literal>false</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latcho1</option></term>
                    <listitem>
                        <para>
                            Latches the O1 asserted when the condition that asserts
                            it is met.  By default this is <literal>false</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-nimo2</option></term>
                    <listitem>
                        <para>
                            Along with the options
                            <option>-inverto2</option> and
                            <option>-latcho2</option>, controls when the NIM
                            O2 output is asserted.  This can be any of:
                            <literal>usbtrigger, vmecommand, vmeas,
                            eventdataobuffer, dgga, dggb,</literal> or
                            <literal>endevent</literal>.
                        </para>
			<para>
			 By default this is <literal>vmeas</literal> which reflects
			 the VME address strobe line. 
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-inverto2</option></term>
                    <listitem>
                        <para>
                            Inverts the sense of the NIM O2 output.  This is
			    <literal>false</literal> by default.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latcho2</option></term>
                    <listitem>
                        <para>
                            Latches the state of the O2 NIM output when the
                            condition that would assert it is met.  This
			    is <literal>false</literal> if not explicitly
			    programmed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-topyellow</option></term>
                    <listitem>
                        <para>
                            Together with <option>-inverttopyellow</option>
                            and <option>-latchtopyellow</option> determines
                            when the top Yellow LED of the VM-USB is lit.
                            This can be any of the following values:
                            <literal>ofifonotempty, infifonotempy, scaler
                            infifofull, berr, vmebr,</literal> or
                            <literal>vmebg</literal>.
                        </para>
			<para>
			 If not explicitly programmed, this will default to
			 <literal>ofifonotempty</literal>, that is lit when there
			 is data in the output fifo.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-inverttopyellow</option></term>
                    <listitem>
                        <para>
                            Inverts the sense of the top yellow LED.
			    Defaults to <literal>false</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latchtopyellow</option></term>
                    <listitem>
                        <para>
                            Latches the top yellow LED in the on state when the
                            condition is met that would light it.  Defaults to
			    <literal>false</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-red</option></term>
                    <listitem>
                        <para>
                            Together with the <option>-invertred</option> and
                            <option>-latchred</option> options controls the
                            when the red LED on the VM-USB front panel is lit.
                            This can be one of the following value:
                            <literal>trigger, nimi1, nimi2, busy, dtack, berr, vmebr</literal>
                            or <literal>vmebg</literal>.
                        </para>
			<para>
			 If not explicitly programmed, this defaults to
			 <literal>busy</literal>, and is therefore lit
			 when the VMUSB is busy.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-invertred</option></term>
                    <listitem>
                        <para>
                            Inverts the state of the red LED.
			    Defaults to <literal>false</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latchred</option></term>
                    <listitem>
                        <para>
                            Latches the red led on when the condition to light
                            it has been met.
			    Default value is <literal>false</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-green</option></term>
                    <listitem>
                        <para>
                            Together with the <option>-invertgreen</option>
                            and <option>-latchgreen</option>, determines when
                            the green LED is lit.  This can be one of the following
                            values:
                            <literal>acquire, stacknotempty, eventready,
                            trigger, dtack, berr, vmebr</literal> or
                            <literal>vmebg</literal>.
                        </para>
			<para>
			 If not explicitly configured, this defaults to
			 <literal>acquire</literal>.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-invertgreen</option></term>
                    <listitem>
                        <para>
                            Inverts the condition that lights the green LED.
			    Defaults to <literal>false</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latchgreen</option></term>
                    <listitem>
                        <para>
                            If true, the green LED is latched in the on state
                            once the condition that would light it is met.
			    If not configured defaults to <literal>false</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-bottomyellow</option></term>
                    <listitem>
                        <para>
                            Together with <option>-invertbottomyellow</option>
                            and <option>-latchbottomyellow</option> determines
                            when the bottom yellow LED is lit.  The value of this
                            option can be any of the following values:
                            <literal>notslot1, usbtrigger, usbreset, berr, dtack, vmebr</literal>
                            or <literal>vmebg</literal>.
                        </para>
			<para>
			 If not explicitly configured, defaults to <literal>dtack</literal>.
			 This is the VME bus Data Transfer Acknowledge signal
			 that target modules use to indicate that a transfer
			 operation is complete.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-invertbottomyellow</option></term>
                    <listitem>
                        <para>
                            Inverts the condition that lights the bottom yellow
                            LED.  Defaults to <literal>false</literal> if
			    ot explicitly configured.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latchbottomyellow</option></term>
                    <listitem>
                        <para>
                            Latches the bottom yellow LED in the lit state
                            once the condition is met to light it.
			    Defaults to <literal>false</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-readscalers</option></term>
                    <listitem>
                        <para>
                            If this is true the two scalers A and B will
                            be read by the stack in which the vmusb is
                            module is put.  The A scaler is read first followed
                            by the B scaler.  See <option>-scalera</option>
                            and <option>-scalerb</option> below which define
                            when each scaler increments.
                        </para>
			<para>
			 By default, the value of this option is
			 <literal>false</literal>, meaning the scalers will
			 not be read.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-incremental</option></term>
                    <listitem>
                        <para>
                            This option is ignored unless <option>-readscalers</option>
                            is true.  If <option>-incremental</option> is true,
                            scalers are cleared after they are read.
                            Note that since the VM-USB has no mechanism to
                            atomically read and clear scalers, counts can be lost
                            between the read and clear.
                        </para>
			<para>
			 By default this is <literal>true</literal>.  If you plan
			 to use the VMUSB scaler(s) as a timestamp, you must
			 set this to <literal>false</literal>.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-scalera</option></term>
                    <listitem>
                        <para>
                            Determines the condition that increments scaler A.
                            This can be one of the following values:
                            <literal>dgga, nimi1, nimi2</literal> or <literal>event</literal>.
                        </para>
			<para>
			 By default, this value is <literal>nimi2</literal>, causing
			 this scaler to be incremented on an external pulse
			 plugged into the IN2 input.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-scalerb</option></term>
                    <listitem>
                        <para>
                            Determines the condition that increments scaler B.
                            This can be one of the following values:
                            <literal>carry,, nimi1, nimi2</literal> or
                            <literal>event</literal>.
                            The <literal>carry</literal> value means that
                            scaler B is incremented when scaler A overflows.
                            This allows both scalers to be combined into a single
                            64 bit scaler that is incremented by the condition
                            defined in the <option>-scalera</option> option.
                        </para>
			<para>
			 By default this option is <literal>carry</literal>
			 making Scaler B the high order bits of a 64 bit scaler
			 with Scaler A the low order bits.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-dgga</option></term>
                    <listitem>
                        <para>
                            Determines the condition that causes the signal to be
                            generated by the DGGA device. Options are:
                            <literal>off</literal>, <literal>nimi1</literal>,
                            <literal>nimi2</literal>,<literal>trigger</literal>,
                            <literal>endofevent</literal>,<literal>usbtrigger</literal>, 
                            and <literal>pulser</literal>. The default option is <literal>pulser</literal>.
                        </para>
			<para>
			 By default, the value of this option is
			 <literal>pulser</literal>, starting DGGA on the
			 internal pulser.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-dggb</option></term>
                    <listitem>
                        <para>
                            Determines the condition that causes the signal to be
                            generated by the DGGB device. Options are:
                            <literal>off</literal>, <literal>nimi1</literal>,
                            <literal>nimi2</literal>,<literal>trigger</literal>,
                            <literal>endofevent</literal>,<literal>usbtrigger</literal>, 
                            and <literal>pulser</literal>. The default option is <literal>nimi2</literal>.
                        </para>
			<para>
			 By default, this option is <literal>nimi2</literal>
			 starting DGGB when an input pulse is received on the
			 IN2 input.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-widtha</option></term>
                    <listitem>
                        <para>
                            Determines the width of the gate produced by dgga in units of 12.5 ns.
			    This defaults to <literal>1</literal> giving a
			    <literal>12.5</literal>ns gate width.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-delaya</option></term>
                    <listitem>
                        <para>
                            Determines the amount of time in units of 12.5 ns to delay the gate
                            output of dgga once it has been triggered.
			    Defaults to <literal>0</literal>, no delay between
			    the start and the gate output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-widthb</option></term>
                    <listitem>
                        <para>
                            Determines the width of the gate produced by dggb in units of 12.5 ns.
			    This defaults to <literal>1</literal> resulting
			    in a <literal>12.5</literal>ns output pulse.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-delayb</option></term>
                    <listitem>
                        <para>
                            Determines the amount of time in units of 12.5 ns to delay the gate
                            output of dggb once it has been triggered.
			    By default this is <literal>0</literal>; no delay
			    between start and gate output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-mixedbuffers</option></term>
                    <listitem>
                        <para>
                            Sets whether scaler and event data can coexist in the same buffer.
                            The default is false.
                        </para>
			<para>
			 <literal>false</literal> by default.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-spanbuffers</option></term>
                    <listitem>
                        <para>
                            Sets whether event data can span buffer boundaries. Default is false. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-forcescalerdump</option></term>
                    <listitem>
                        <para>
                            If set to true, the VM-USB will immediately output scaler data 
                            once a scaler stack is executed. Default is false.
			    By default this is <literal>false</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-busreqlevel</option></term>
                    <listitem>
                        <para>
                            Determines the bus request level that the VMUSB will use for itself
                            when it requests ownership of the bus. The valid values are any in
                            the range [0,7] and the default value is 4.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-optionalheader</option></term>
                    <listitem>
                        <para>
                            Determines whether a second optional header word will follow the first
                            buffer header word. When present, this extra header specifies the number
                            of words in the buffer. The default value is false.
			    This is <literal>false</literal> by default.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-bufferlength</option></term>
                    <listitem>
                        <para>
                            Determines size of the internal buffer used by the VMUSB in units of 
                            words. The VMUSB fills the buffer before outputting data on a 
                            usb_bulk_read so a smaller buffer size is useful for low data rates. 
                            The optional values are: 13k, 8k, 4k, 2k, 1k, 512, 256, 128, 64, and evtcount.  
                            The evtcount option depends on the value of the -eventsperbuffer option.
                            The default value is 13k.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-eventsperbuffer</option></term>
                    <listitem>
                        <para>
                          If the -bufferlength option is set to evtcount, this determines how many
                          events must occur before transferring data to the FIFO for readout. The values
                          can be any in the range [1,4095]. The default value is 1.
                        </para>
                    </listitem>
                </varlistentry>
                
   
              </variablelist>
           </refsect1>
   
         </refentry>
   
   <!-- SIS 3300 simplified driver. -->
      <refentry id="vmusb3-sis3300">
	<refentryinfo>
	  <author>
		  <personname>
			  <firstname>Ron</firstname>
			  <surname>Fox</surname>
		  </personname>
		  <personblurb><para></para></personblurb>
	  </author>
	  <productname>NSCLDAQ</productname>
	  <productnumber></productnumber>
	</refentryinfo>
	<refmeta>
	   <refentrytitle id='vmusb3-sis3300-title'>sis3300</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
	   <refmiscinfo class='empty'></refmiscinfo>
	</refmeta>
	<refnamediv>
	   <refname>sis3300</refname>
	   <refpurpose>Simplified sis3300 support.</refpurpose>
	</refnamediv>
	
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>
package require sis330x
	   </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	       <command>
sis330x <replaceable>name ?options...?</replaceable>
	       </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	       <command>
<replaceable>name</replaceable> configure <replaceable>option value ?...?</replaceable>
	       </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	       <command>
addtcldriver <replaceable>name</replaceable>
	       </command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	   <title>DESCRIPTION</title>
	   <para>
	       This driver provides a simplified driver for the SIS 3300/3301
	       FADC family.  The driver provides three modes of operation for
	       the device:
	   </para>
	   <variablelist>
	       <varlistentry>
		   <term>start</term>
		   <listitem>
		       <para>
			 In start mode an external start input is required to start
			 digitization.  Digitization stops either when the desired
			 number of samples have been acquired or when an external
			 stop input is provided. 
		       </para>
		       <para>
			 The start input is the second from the top (input 3).
			 The stop input is the third from the top (input 2).
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>stop</term>
		   <listitem>
		       <para>
			 In stop mode, the digitizer is continuously digitizing.
			 Digitization then stops  when an NIM pulse is presented
			 to input 2 (third from the top).
		       </para>
		       <para>
			 Note that in stop mode, the actual acquired data my
			 not be at the beginning of the digitizer data.
			 See <literal>OUPUT DATA FORMAT</literal> below for
			 more information.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>gate</term>
		   <listitem>
		       <para>
			 In gate mode, a gate signal is presented to
			 the start input (input 3 second from the top).
			 digitization begins on the falling edge of the gate
			 and ends on the rising edge of the gate, or when the
			 maximum number of samples has been acquired (if
			 the gate is wider than the time required to digitize
			 the maximum number of samples).
		       </para>
		   </listitem>
	       </varlistentry>
	   </variablelist>
	</refsect1>
	<refsect1>
	   <title>
	      OPTIONS
	   </title>
	   <variablelist>
	       <varlistentry>
		   <term><option>-base</option> <replaceable>base-address</replaceable></term>
		   <listitem>
		       <para>
			 Sets the VME base address of the module.  For the 3300,
			 this is set via jumpers that control the top four bits
			 of VME address.  For the 3301, this is set via a pair
			 of rotary switches that allow the top eight bits
			 of the VME address to be set.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-clock</option> <replaceable>source-spec</replaceable></term>
		   <listitem>
		       <para>
			 Sets the digitizer clock source.  This can be one of
			 several internal clock frequencies available or
			 one the external clock modes.
			 The default clock source is <literal>100Mhz</literal>
			 The valid clock
			 sources are:
		       </para>
		       <variablelist>
			 <varlistentry>
			     <term>100Mhz, 50Mhz, 25Mhz, 12.5Mhz, 6.25Mhz or 3.125Mhz</term>
			     <listitem>
				 <para>
				   Selects an internal clock source at the
				   specified frequency.  The default value is
				 </para>
			     </listitem>
			 </varlistentry>
			 <varlistentry>
			     <term><literal>external</literal></term>
			     <listitem>
				 <para>
				   The clock is provided as an external symmetric
				   pulse train on input 4 (top input).  See
				   section 2.5.2 of the SIS330x manual
				   for information about the signal
				   requriements for this clock.
				 </para>
			     </listitem>
			 </varlistentry>
			 <varlistentry>
			     <term><literal>random</literal></term>
			     <listitem>
				 <para>
				   Allows arbitray clock trains or slow clocks.
				   The internal logic runs at 100Mhz.  On each
				   falling edge of the external clock, data
				   are digitized by the next falling edge of the
				   internal clock and transferred to the buffer
				   memory 10 interal clocks later.
				 </para>
			     </listitem>
			 </varlistentry>
			 <varlistentry>
			     <term>hira</term>
			     <listitem>
				 <para>
				   Runs in HiRa random clock mode.  This is suitable
				   for use with the Wash-U multiplexing front end boards.
				   Note that new applications should make use
				   of XLM boards with integrated digitizers
				   rather than the XLM + SIS3301
				   pair.
				 </para>
			     </listitem>
			 </varlistentry>
		       </variablelist>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-mode</option> <literal>start | stop | gate</literal></term>
		   <listitem>
		       <para>
			 Selects the mode of the digitizer.  Defaults to <literal>start</literal> mode.
			 See <literal>DESCRIPTION</literal> above for a summary of the modes.
			 Note that <literal>start</literal> and <literal>stop</literal>
			 modes represent special use cases of the digitizers's
			 start/stop trigger mode while <literal>gate</literal>
			 is the digitizer's gate trigger mode.
		       </para>
		       <para>
			 The <option>-mode</option> selected can affect the
			 way you need to decode the data from each event.
			 See <literal>OUTPUT DATA FORMAT</literal> below
			 for more information.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-startdelay</option> <literal>disabled | value</literal></term>
		   <listitem>
		       <para>
			 If the value of this option is <literal>disabled</literal>,
			 the start delay is not enabled.  Otherwise, the value
			 must be a positive integer in the range <literal>[0,65535]</literal>
			 and is the number of clock ticks the digitizer start is
			 delayed before actually being applied.
		       </para>
		       <para>
			 This option defaults to <literal>disabled.</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-stopdelay</option> <literal>disabled | value</literal></term>
		   <listitem>
		       <para>
			 Same as <option>-startdelay</option> above, however
			 the delay, if enabled, applies to the stop time.
		       </para>
		       <para>
			 Defaults to <literal>disabled</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-samples</option> <replaceable>value</replaceable></term>
		   <listitem>
		       <para>
			 Selects the maximum number of sample that will be
			 acquired.  This defaults to <literal>128K</literal>.
			 The following values are allowed:
			 <literal>128K, 16K, 4K, 2K, 1K, 512, 256, 128</literal>.
			 Note that the <literal>K</literal> multiplier in the
			 list above means <literal>1024</literal>.
		       </para>
		       <para>
			 It is possible that fewer than <option>-samples</option>
			 will be acquired.  This can happen in:
		       </para>
		       <itemizedlist>
			 <listitem><para>
			      In <literal>start</literal> mode if there is a
			      stop input that fires to the time required
			      to digitize all samples.
			 </para></listitem>
			 <listitem><para>
			      In <literal>stop</literal> mode if the stop
			      comes soon enough after the digitizer is started
			      by the VMUSB that not all the samples have
			      been digitized.
			 </para></listitem>
			 <listitem><para>
			      In <literal>gate</literal> mode if the gate is
			      narrower than the time required to digitize
			      all samples.
			 </para></listitem>
		       </itemizedlist>
		       <para>
			 The data structure allows you to determine if this is
			 the case.  See <literal>OUTPUT DATA FORMAT</literal>
			 for information about this.
		       </para>
		       <para>
			 This option defaults to <literal>128K</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-thresholdslt</option> <replaceable>list</replaceable></term>
		   <listitem>
		       <para>
			 A list of 8 booleans, one per digitizer channel.  If
			 a list element is
			 <literal>true</literal>, the channel threshold
			 is applied for a crossing from above to below the
			 threshold.  If <literal>false</literal>, the
			 channel threshold is applied to a crossing from
			 below the threshold to above it.
		       </para>
		       <para>
			 See <option>-thresholds</option> below for more information.
			 Defaults to an 8 element list of <literal>false</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-thresholds</option> <replaceable>list</replaceable></term>
		   <listitem>
		       <para>
			 A list of 8 integer in the range <literal>[0,4096)</literal>
			 for the SIS 3300 and <literal>[0,16384)</literal> for
			 the SIS3301.  If the input signal crosses this value
			 in the direction specified by the corresponding
			 <option>-thresholdslt</option> value,
			 a pulse is sent on the trigger output (bottom lemo).
		       </para>
		       <para>
			 This pulse can be cabled to the <literal>start</literal>
			 or <literal>stop</literal> input to directly trigger
			 the digitizer or sent to external trigger logic
			 as a term in a more complex trigger scheme.
		       </para>
		       <para>
			 The default value is a list of 8 <literal>16383</literal>
			 values.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-minletime</option> <replaceable>list</replaceable></term>
		   <listitem>
		       <para>
			 This parameter is a list of four integers, one per channel
			 group that
			 specifies the minimum number of clock ticks the trace
			 in a group must
			 be below the threshold to result in a trigger when a channel's
			 <option>thresholdslt</option> value is <literal>true</literal>.
			 This defaults to a list of 4<literal>0</literal> which disables the
			 use of this parameter.  The value must be in the range
			 <literal>[0, 16)</literal>.  A value of <literal>0</literal>
			 disables the enforcement of this parameter.
		       </para>
		       <para>Defaults to a list of four <literal>0</literal> values</para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-mingttime</option> <replaceable>list</replaceable></term>
		   <listitem>
		       <para>
			  Same as <option>-minletime</option> except that
			  this specifies the number of consecutive clock ticks a
			  channel must be above the threshold value when
			  <option>-thresholdslt</option> for the channels
			  is <literal>false.</literal>.
		       </para>
		       <para>
			 As with <option>-minletime</option>, this defaults to
			 a list of four <literal>0</literal> values.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-trigwidth</option> <replaceable>list</replaceable></term>
		   <listitem>
		       <para>
			 List of four integers in the range <literal>[0,16)</literal>,
			 one for each group of two channels.  If the value for
			 a group is <literal>0</literal> (the default), the
			 settable output gate width feature is disabled.  Otherwise,
			 this value represents the desired output width of the
			 trigger in clock ticks.
		       </para>
		       <para>a list of four <literal>0</literal> values</para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-groupenables <replaceable>list</replaceable></option></term>
		   <listitem>
		       <para>
			 List of four booleans (defaults to all <literal>true</literal>),
			 one for each ADC channel group.  If a group's flag is
			 <literal>true</literal> it is read out, if not it
			 is not read out.
		       </para>
		       <para>
			 Defaults to a group of four <literal>false</literal> valsuss.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-header</option> <replaceable>value</replaceable></term>
		   <listitem>
		       <para>
			 This 16 bit value is inserted into the data from the
			 module prior to the data from each group.
			 See <literal>OUTPUT DATA FORMAT</literal> below
			 for more information about where this appears.
		       </para>
		       <para>
			 This defaults to <literal>0xfadc</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-trailer</option> <replaceable>value</replaceable></term>
		   <listitem>
		       <para>
			 This 16 bit value is inserted into the data from the
			 module after the data from each group.  See
			 <literal>OUTPUT DATA FORMAT</literal> below for
			 more information.  Defaults to <literal>0xffff</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	   </variablelist>
	</refsect1>
        <refsect1>
	  <title>OUTPUT DATA FORMAT</title>
	
	<para>
	  The output format for this module does not depend on mode.  The
	  interpretation of some of the data is, however mode dependent.
	  The overal format of the data is shown below:
	</para>
	<informalexample>
	  <programlisting>
+----------------------------------------+
|  Mask of group enables (16 bit)        |
+----------------------------------------+
| DAQ Control register value (32 bits)   |
+----------------------------------------+
|  Data from the lowest set bit in       |
|  group enables                         |
              ...
+----------------------------------------+
              ...
	  </programlisting>
	</informalexample>
	<para>
	  The DAQ control register value provides two bits of useful
	  information:
	</para>
	<orderedlist>
	  <listitem><para>
	       If its bottom bit (bit 0) is set you need to delay more
	       prior to reading the module as this bit means the module
	       is still digitizing at the time of readout.
	  </para></listitem>
	  <listitem><para>
	       If bit number 10 is set, the module is being used in gate mode.
	       If not it is being used in either start or stop mode (there
	       is no hardware way to determine the difference).  
	  </para></listitem>
	  <listitem><para>
	       Bits 12-14 define the clock source according to the table in section
	       4.5.  Note that there is no way from this register alone to
	       distinguish between the various external clock modes.
	  </para></listitem>
	</orderedlist>
	<para>
	  Other bits may be set but they are not relevant to this discussion.
	</para>
	<para>
	  Data from each enabled group is provided from lowest to highest
	  group number.  No data is provided for disabled groups.
	</para>
	<para>
	  The data from each group is:
	</para>
	<informalexample>
	  <programlisting>
+-----------------------------------------------+
| header (16 bits)                              |
+-----------------------------------------------+
| Group trigger event directory (32 bits)       |
+-----------------------------------------------+
| Size of data from group                       |
+-----------------------------------------------+
|  Data from group                              |
             ...
+-----------------------------------------------+
| trailer  (16 bits)                            |
+-----------------------------------------------+

	  </programlisting>
	</informalexample>
	<para>
	  In the data format shown above;
	</para>
	<variablelist>
	  <varlistentry>
	      <term>header</term>
	      <listitem>
		  <para>
		    Is the value of the <option>-header</option> option.  If not
		    configured by you this defaults to <literal>0xfadc</literal>
		  </para>
	      </listitem>
	  </varlistentry>
	  <varlistentry>
	      <term>trailer</term>
	      <listitem>
		  <para>
		    Is the value of the <option>-trailer</option> option
		  </para>
	      </listitem>
	  </varlistentry>
	  <varlistentry>
	      <term>Group trigger event directory</term>
	      <listitem>
	          <para>
		    See section 4.25 of the SIS3300/3301 manual for the
		    detailed format of these 32 bits.
		  </para>
		  <para>
		    The bottom 17 bits of this value modula the number of samples
		    you have selected are sample in the data from the group after
		    which the data have ended.   In the  start and gate
		    mode the trace always begins at the first data item and this
		    value indicates the sample after which data end.  In start mode,
		    and gate mode, this may indicate fewer samples have been
		    digitized than were acquired if, for example there is an
		    external stop in start mode or, in gate mode, if
		    the gate is short relative to the selected sample size.
		  </para>
		  <para>
		    In
		    stop mode, the digitizer treats the data buffer as a circular
		    buffer into which it is continously digitizing the input.
		    The stop signal then indicates when digitization ends (
		    the actual stop may
		    be delayed by the <option>-stopdelay</option>).
		    Therefore in stop mode the bottom 17 bits modula the
		    <option>-samples</option> together with bit 19 (the wrap bit)
		    indicate at which sample the trace starts.
		  </para>
		  <para>
		    If the wrap bit is not set, then trace begins at the first
		    sample in the buffer and ends at the sample just prior to
		    the value in the bottom 17 bits.  If the wrap bit is set,
		    data begins at the sample number in the data indicated
		    by the bottom 17 bits and wraps circulalry to the beginnning
		    of the data before ending in the sample just prior to the
		    first sample.
		  </para>
		  <para>
		    If you are using the internal thresholds, bits 24-31 indicate
		    which, if any, channels satisfied their threshold conditions.
		    Bit 31 represents the state of the channel 1 trigger and
		    bit 24 the state of the channel 8 trigger.
		  </para>
	      </listitem>
	  </varlistentry>
	  <varlistentry>
	      <term>Size of data from group</term>
	      <listitem>
		  <para>
		    This is the actual number of samples that will appear
		    in the data buffer.  At present, (this may change), in start
		    and in stop mode, this is the number of samples selected
		    by <option>-samples</option>.  In gate mode, this value
		    repeats the trigger event directory and the bottom 17 bits
		    indicate the number of samples acquired.
		  </para>
	      </listitem>
	  </varlistentry>
	  <varlistentry>
	      <term>Data from the group.</term>
	      <listitem>
		  <para>
		    This is the raw sample data, 32 bits per sample containing
		    a sample from each ADC in the group of two samples as shown
		    in section 4.33 of the SIS3300/3301 manual.  Note that to
		    decode the data you will need to know if the digitizer
		    is an SIS3300 (12 bits of data over range flag in bit 12)
		    or an SIS3301 (14 bits of data over range flag in bit 14).
		  </para>
	      </listitem>
	  </varlistentry>
	  <varlistentry>
	      <term>trailer</term>
	      <listitem>
		  <para>
		    These 16 bits are the value of the <option>-trailer</option>
		    option.  If not configured by you, this defaults to
		    <literal>0xffff</literal>.  Note that since bit 15 is set,
		    this is not a legal conversion value from the AD and therefore
		    is distinguishable from real data.   I recommend that if you
		    choose a different <option>-trailer</option> from the
		    default value, that you select one that has the top bit
		    set.
		  </para>
	      </listitem>
	  </varlistentry>
	</variablelist>
	</refsect1>	
      </refentry>

   <!-- SIS 330x FADC driver -->
   
         <refentry id="vmusb3-sis330x">
           <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
		<personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo> 
           <refmeta>
              <refentrytitle>sis330x</refentrytitle>
              <manvolnum>3vmusb</manvolnum>
              <refmiscinfo class='empty'></refmiscinfo>
           </refmeta>
           <refnamediv>
              <refname>sis330x</refname>
              <refpurpose>Driver for SIS3300/1 FADC</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require SIS330XDriver
                </command>
            </cmdsynopsis>
             <cmdsynopsis>
                 <command>
sis3300 <replaceable>name ?options?</replaceable>   
                </command>
             </cmdsynopsis>
             <cmdsynopsis>
                <command>
<replaceable>name</replaceable> configure <replaceable>options</replaceable>
                </command>
            </cmdsynopsis>
             <cmdsynopsis>
                <command>
<replaceable>name</replaceable> cget <replaceable>option</replaceable>
                </command>
             </cmdsynopsis>
             <cmdsynopsis>
                <command>
addtcldriver <replaceable>name</replaceable>
                </command>
             </cmdsynopsis>
           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
                Provides support for the SIS 3300/3301 flash adc module.
                This is a Tcl driver, hence the need for a
                <command>package require</command> command to load the driver
                and a <command>addtcldriver</command> command to connect
                a driver instance with the framework.
              </para>
              <para>
                The driver support restricting the readout to a subset of the
                channels. See  the <option>-groupsread</option> option for
                more information in OPTIONS below.
              </para>
              <para>
                The structure of data read from the SIS3300/3301 is shown
                below (all elements are 32 bit integers unless otherwise
                indicated):
              </para>
	      <para>
	       This driver is known to work properly for HiRA for a simpler
	       driver, known to work in all use cases, see
	       <link linkend='vmusb3-sis3300' endterm='vmusb3-sis3300-title' />
	      </para>
              <informalexample>
                <programlisting>
+-------------------------------+
|  Group Mask                   | (16 bits)  <co id="sis3300_data_gmask" />
+-------------------------------+
|  Group size                   |            <co id="sis3300_data_gsize" />
+-------------------------------+
| Group data                    |
|          ...                  |            <co id="sis3300_data_group" />
+-------------------------------+
                </programlisting>
              </informalexample>
            <calloutlist>
                <callout arearefs="sis3300_data_gmask">
                    <para>
                        The low order four bits of this 16 bit data word
                        describe which ADC groups are present.  If bit 0
                        is set, group 1 is present, if bit 1 is set group 2
                        and so on.
                    </para>
                    <para>
                        Group data that follow are in order of low numbered
                        group to high numbered group for each group whose bit
                        is set in this group mask.
                    </para>
                </callout>
                <callout arearefs="sis3300_data_gsize" >
                    <para>
                        The group mask is followed by group data for each bit
                        set in the mask.  This field contains the number of
                        longwords of group data that follows.  The size
                        is not self-inclusive.
                    </para>
                </callout>
                <callout arearefs="sis3300_data_group">
                    <para>
                        Group data is the raw ADC trace data from the data
                        buffer.  The format of these longwords
                        is shown in section 4.34 of the SIS manual.
                    </para>
                </callout>
            </calloutlist>
           </refsect1>
           <refsect1>
              <title>
                 OPTIONS
              </title>
              <variablelist>
                <varlistentry>
                    <term><option>-base</option> <replaceable>base-address</replaceable></term>
                    <listitem>
                        <para>Module base address in VME.</para>
			<para>This defaults to <literal>0</literal></para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-clocksource</option> <replaceable>clocksource</replaceable></term>
                    <listitem>
                        <para>
                            Module clock source.  This must be a value chosen
                            from one of the following strings:
                            <literal>100Mhz, 50Mhz, 25Mhz, 12.5Mhz, 6.25Mhz,
                            3.125Mhz FrontPanel P2Connector</literal>.
                            The clock source determines the sampling rate of the
                            ADC (or when data are clocked in in the case of
                            HiRA Mode.
                        </para>
			<para>Defaults to 100Mhz</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-startdelay</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                            If true the start delay is enabled and.  See
                            <option>-startdelayticks</option> to see how this delay
                            is controlled.  Note that the start delay determines when
                            the first sample is saved relative to the start.
                        </para>
			<para>
			 Defaults to <literal>off</literal>
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-startdelayticks</option> <replaceable>integer</replaceable></term>
                    <listitem>
                        <para>Number of samples in the start delay.   If
                            <option>-startdelay</option> is <literal>
                            false</literal>, this parameter is not used.
                        </para>
			<para>
			 Defaults to <literal>0</literal>
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-stopdelay</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                             If true, the stop delay is enabled. See
                             <option>-stopdelayticks</option> to set the actual
                             stop delay.  Defaults to
			     <literal>off</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-stopdelayticks</option></term>
                    <listitem>
                        <para>
                            This is the number of samples in the stop delay.
                            If <option>-stopdelay</option> is <literal>true</literal>,
                            when a stop occurs, data will be taken for this
                            number of samples more.  Note that this value is
                            completely ignored if <option>-stopdelay</option>
                            is <literal>false</literal>.
                        </para>
			<para>Defaults to <literal>0</literal></para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-stoptrigger</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                            If <literal>true</literal> the module stop is the trigger.
                            This pretty much has to be used with
                            <option>-stopdelay</option> and
                            <option>-stopdelayticks</option>
                        </para>
			<para>
			 Implies that the module start will be via the VME.
			 Defaults to <literal>off</literal>
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-gatemode</option>  <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                            Module is or is not in gate mode.  In gate mode
                            the module is started from the falling edge of the
                            gate input and stopped by the rising edge of that signal.
                        </para>
			<para>Defaults to <literal>off</literal></para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-lemostartstop</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                            Start/Stop come from lemo inputs.  This is enabled by
                            default.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-p2startstop</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                                Backplane signals on the p2 connector
                                provide start/stop.  Note that this and
                                <option>lemostartstop</option> are not
                                mutually exlusive.  Defaults to
				<literal>off</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-hirarandomclock</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>If true, HiRA random clock mode is enabled.
                            HiRA Random clock is normally used with the
                            Washington University Chip board readouts when
                            the readout is done with an XLM other than the
                            XLM-VV when the analog information is collected
                            by an SIS 3301 board.
                        </para>
			<para>
			 Defaults to <literal>off</literal>. If true, the
			 <literal>-clocksource</literal> must be set to
			 <literal>FrontPanel</literal> e.g.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-randomclock</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>If true front panel provides a random clock with
                             a symmetric pulse shape
                             See section2.5.3 of the module documentation.
                        </para>
			<para>
			 Defaults to <literal>off</literal>.  If enabled,
			 the <option>-clocksource</option> must be
			 set to e.g. <literal>FrontPanel</literal>.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-samplesize</option> <replaceable>enum value</replaceable></term>
                    <listitem>
                        <para>Size of sample buffers.  This is one of the
                            following text strings:
                            <literal>128K, 16K, 4K, 2K, 1K, 512, 256 128</literal>.
                        </para>
			<para>
			 Defaults to <literal>128K</literal>
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-wrap</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>Buffers are  in wrap mode (normally used if
                            start/stop is longer than the samplesize.  Once
                            sampling runs off the end of the buffer sampling
                            continues writing at the low memory location
                            (wraps).  Please note that at present, the
                            readout method used does not support this.
                            If you have a need to use this mode, please
                            contact the NSCL software development group to
                            arrange further development.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-thresholdslt</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>If true, channel thresholds represent a  level
                            _below_ which the conversion must fall. This is normally
                            used with negative going pulses since the data are
                            represented as half-scale offset unsigned integers.
                        </para>
			<para>
			 Defaults to <literal>false</literal>.  Note that
			 while the SIS3300/1 supports, different values
			 for this parameter for each group (of two) ADCs,
			 this driver only supports a common value.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-thresholds</option> <replaceable>8 element int list</replaceable></term>
                    <listitem>
                        <para>Threshold values for all 8 channels.  This parameter,
                              if provided is an 8 element integer list of
                              threshold values.  See as well
                              <option>thresholdslt</option> which can modify
                              how this value is interpreted.
                        </para>
			<para>
			 Defaults to a list of eight <literal>0x3fff</literal>
			 values.
			</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-groupsread</option> <replaceable>4 element bool list</replaceable></term>
                    <listitem>
                        <para>List of flags indicating which groups of ADCs will
                            be read. The module is organized into 4 groups of 2 ADCs each).
                            The manual refers to them as groups 1,2,3,4.  The first
                            list element allows or disables the readout of group 1
                            and so on.
                        </para>
			<para>
			 Defaults to a list of four <literal>true</literal>
			 values.
			</para>
                    </listitem>
                </varlistentry>

              </variablelist>
           </refsect1>
   
         </refentry>
   
   <!-- SIS 3820 scaler command  -->
            
      <refentry id="vmusb3-sis3820">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
		<personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
         <refmeta>
           <refentrytitle>sis3820</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
         </refmeta>
         <refnamediv>
           <refname>sis3820</refname>
           <refpurpose>Create and configure SIS 3820 scaler modules</refpurpose>
         </refnamediv>
        
         <refsynopsisdiv>
           <cmdsynopsis>
      	 <command>
sis3820 create <replaceable>name base ?option value...?</replaceable>
      	 </command>
          </cmdsynopsis>
             <cmdsynopsis>
                 <command>
sis3820 config <replaceable>name option value ...</replaceable>
                 </command>
             </cmdsynopsis>
                <cmdsynopsis>
                    <command>
sis3820 cget <replaceable>name</replaceable>
                    </command>
                </cmdsynopsis>
            
         </refsynopsisdiv>
         <refsect1>
           <title>DESCRIPTION</title>
           <para>
               Creates and configures the SIS3820 32 channel scaler for use in
               a stack.   The <command>create</command> subcommand creates a new
               module with a base address of <parameter>base</parameter>, and
               a name <parameter>name</parameter> which will be used to refer
               to this module in later configuration commands.
           </para>
            <para>
               The scaler readout will result in an array of 32 channels
               of scaler data placed in the buffer.  The first longword of this
               data is channel 0, the last, channel 1, unless the scaler in in
               <option>-timestamp</option> mode in which case the data are three
               longwords that consist of channel 0, channel 16 and the high bits
               register that has the top 16 bits of each of those channels as
               a 48 bit scaler. In the timestamp mode, the scaler values are 
               latched when a logic signal arrives on control input 1, because
               the module is configured for control input mode 1.
            </para>
            <para>
               The <command>config</command> sub-command configures the options
               for the scaler <parameter>name</parameter>.  The configuration
               is expressed as a series of one or more
               <parameter>option value</parameter> pairs.  Options may have
               default values and are validity checked to ensure that
               valid values are supplied.  See OPTIONS below for more information
               about the option keywords that are supported and their legal values.
            </para>
            <para>
               The <command>cget</command> sub-command returns the current module
               configuration.  The configuration is returned as a Tcl list of
               <parameter>option value</parameter> pairs.  See
               OPTIONS below for a description of the options ans values
               that are returned.  You should not rely on the list being in any
               specific order.  While the list will have a deterministic order,
               if additional option keywords are added later on, this order may
               change.
            </para>
         </refsect1>
         <refsect1>
           <title>
      	OPTIONS
           </title>
           <variablelist>
      	 <varlistentry>
      	    <term><option>-base</option> <parameter>value</parameter></term>
      	    <listitem>
      		<para>
                  Allows you to override the initial base address of the module,
                  specified when the module was created.
      		</para>
      	    </listitem>
      	 </varlistentry>
         <varlistentry>
            <term><option>-timestamp</option> <parameter>on | off</parameter></term>
            <listitem>
                <para>
                    If this option is true, the scaler is read in timestamp mode as
                    2 48 bit scalers.  If false (the default), 32 bits are read for
                    each channel.  This defaults to <literal>off</literal>.
		    Note that normally if <option>-timestamp </option> is on,
		    this module will be put in the event stack.
                </para>
            </listitem>
		</varlistentry>
			<varlistentry>
                <term><option>-inputmode</option> <parameter>mode</parameter></term>
                <listitem>
                    <para>
					Sets the input mode for the module.  The input mode
					determines the meaning of the NIM inputs on the
					module.  Note that the default value for this depends
					on the value of <option>-timestamp</option>.
					Valid values for <parameter>mode</parameter> are:
                    </para>
				<variablelist>
					<varlistentry>
						<term><literal>default</literal></term>
						<listitem>
						    <para>
							 Choose the  appropriate default value for the
							 the input mode depending on the value of
							 <option>-timestamp</option>.  See the discussion
							 of the default value below.
						    </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><literal>None</literal></term>
						<listitem>
						    <para>
							 Selects input mode 0.  None of the inputs have
							 any meaning.
						    </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><literal>LNEInhLNE</literal></term>
						<listitem>
						    <para>
							Selects input mode 1.  In this input mode,
							input 1 latches the scaler value and
							input 4 inhibits that signal.  The other
							inputs are connected to external user bit 1
							and 2 and are irrelevant because this driver
							does not provide access to those bits..
						    </para>
						</listitem>
					 </varlistentry>
					 <varlistentry>
						<term><literal>LNEInhboth</literal></term>
						<listitem>
						    <para>
							Selects input mode 2.  This mode is identical
							to <literal>LNEInhLNE</literal> except that
							input 3 additionaly inhibits all scaler
							channels from counting.
						    </para>
						</listitem>
					  </varlistentry>
						<varlistentry>
							<term><literal>LNEInhCount</literal></term>
							<listitem>
							    <para>
								Selects input mode 3. In this mode,
								input 1 is the latch input and input
								4 inhibits all scaler channels from
								counting
							    </para>
							</listitem>
						 </varlistentry>
						<varlistentry>
                            <term><literal>Inh4s</literal></term>
                            <listitem>
                                <para>
							The inputs inhibit 4 banks of 8 scalers
							(Mode 4).  As there is no input dedicated
							to LNE (latch) using this mode in timestamp
							mode will result in a warning.  Input 1
							inhibits channels 0-7, Input 2 8-15 and so on.
                                </para>
                            </listitem>
                        </varlistentry>
					<varlistentry>
                        <term><literal>LNEHiScal</literal></term>
                        <listitem>
                            <para>
						Mode 5.  Input 1 is a latch input, input 1
						starts the module Hiscal count.  This mode is
						not supported by NSCLDAQ at present.
                            </para>
                        </listitem>
                    </varlistentry>
					<varlistentry>
                        <term><literal>LNEInhClr</literal></term>
                        <listitem>
                            <para>
						Mode 6.  Input 1 is a latch pulse, Input
						2 inhibits counting in all channels
						Input 3 clears all scalers.
                            </para>
                        </listitem>
                    </varlistentry>
				</variablelist>
				<para>
					The default value for this parameter depends on the
					value of <option>-timestamp</option> and is computed
					at the start of each run, if necessary.
					In timestamp mode the default value is
					<literal>LNEInhLNE</literal>.  If not timestamp mode,
					the default is <literal>Inh4s</literal>.
				</para>
                </listitem>
            </varlistentry>
			<varlistentry>
                <term><option>-outputmode</option> <parameter>mode</parameter></term>
                <listitem>
                    <para>
					Configures the module's oputput mode; The meaning
					of the outputs.  If not configured
					<literal>clock50Mhz</literal> (mode 1) is used
					by default.  Legal values for the
					<parameter>mode</parameter> are:
                    </para>
				<variablelist>
					<varlistentry>
                        <term><literal>clock50Mhz</literal></term>
                        <listitem>
                            <para>
						Mode 1 (default), Output 5 echoes the LNE.
						Outupt 7 is a 50MHz clock. 
                            </para>
                        </listitem>
                    </varlistentry>
				<varlistentry>
                    <term><literal>LNEAndLed</literal></term>
                    <listitem>
                        <para>
					Mode 0 - Output 5 echoes the LNE and
					output 8 is the user output (not used by this
					software).
                        </para>
                    </listitem>
                </varlistentry>
			<varlistentry>
                <term><literal>clock2x10Mhz</literal></term>
                <listitem>
                    <para>
					Mode 2 - Output 5 is the LNE.  Output 6,7 are both
					10MHz clocks.   Output 8 is the user LED (not
					used by this software).
                    </para>
                </listitem>
            </varlistentry>
			<varlistentry>
                <term><literal>clock1x10Mhz</literal></term>
                <listitem>
                    <para>
					Mode3 - Output 5 is the LNE, output 6 a
					10MHz clock.  Output 7,8 are not usable by this
					software.
                    </para>
                </listitem>
            </varlistentry>
				</variablelist>
                </listitem>
            </varlistentry>
           </variablelist>
         </refsect1>
         <refsect1>
           <title>EXAMPLES</title>
           <para>
               The example below configures an SIS 3820 scaler to have a base
               address of 0x38000000
           </para>
            <example>
               <title>Configuring an SIS3820 scaler module</title>
               <programlisting>
sis3820 create scaler1 0x38000000
               </programlisting>
            </example>
            <example>
               <title>Configuring an SIS3820 module as a timestamper</title>
               <programlisting>
sis3820 create timestamper 0x38000000
sis3820 config timestamper -timestamp on
               </programlisting>
               <para>
                 By configuring with -timestamp on, SIS3820 module is by
                 default set to input mode <literal>LNEInhLNE</literal>
                 and only accepts 2 inputs at channels 1 and 17
                 to achieve 2 48-bit-wide counters.
               </para>
               <para> 
                 Channel(s) 1 and/or 17 needs to have a clock signal.
                 Whenever LEMO1 receives signal (LNE), both counter
                 values are read and stored into the shadow registers
                 independent to the actual trigger signal VME controller
                 receives which reads out the recorded values.
               </para>
               <para>
                 In most cases, LNE signal should be the same as VME
                 controller trigger signal.
               </para>
               <para>
                 Then, make sure to add the module as the first stack item,
                 which adds 6 words item (96 bits) after the total data size
                 item with format that can be extracted using the following
                 timestamp extraction library:
               </para>
               <programlisting>
#include &lt;stdint.h&gt;
#include &lt;DataFormat.h&gt;
#include &lt;iostream&gt;

extern "C" {
  uint64_t getEventTimestamp(void* item) {
    uint16_t *body = reinterpret_cast&lt;uint16_t*&gt;(item);

    body++; // Skipping size item

    uint64_t tstamp1 = 0, tstamp2 = 0;

    // Timestamp item format
    // LOW1 MID1 LOW2 MID2 HIGH1 HIGH2
    // tstamp1 for Channel 1 and tstamp2 for Channel 17
    tstamp1 |= *body++;
    tstamp1 |= static_cast&lt;uint64_t&gt;(*body++) &lt;&lt; 16;

    tstamp2 |= *body++;
    tstamp2 |= static_cast&lt;uint64_t&gt;(*body++) &lt;&lt; 16;

    tstamp1 |= static_cast&lt;uint64_t&gt;(*body++) &lt;&lt; 32;
    tstamp2 |= static_cast&lt;uint64_t&gt;(*body++) &lt;&lt; 32;

    return tstamp1; // or tstamp2
  }

  uint64_t getScalerTimestamp(void *pBuffer) {
    return 0xffffffffffffffff;
  }
}
               </programlisting>
               <para>
                 Compile with the command below:
               </para>
               <programlisting>
g++ -std=c++11 -fPIC -shared -I$DAQROOT/include -o libtstamp.so timestamp.cpp
               </programlisting>
            </example>
         </refsect1>
      </refentry>
           
      <!-- v830 command - configure CAEN V830 32 channel latching scalers -->
            
      <refentry id="vmusb3-v830">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
		<personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
        <refmeta>
           <refentrytitle>v830</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>v830</refname>
           <refpurpose>Create and configure CAEN V830 32 channel scalers.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
      	<command>
v830 create <replaceable>name base</replaceable>
      	</command>
          </cmdsynopsis>
             <cmdsynopsis>
                 <command>
v830 config <replaceable>name option value...</replaceable>
                 </command>
             </cmdsynopsis>
             <cmdsynopsis>
                 <command>
v830 cget <replaceable>name</replaceable>
                 </command>
             </cmdsynopsis>
         
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
               This command creates, configures and queries the configuration of
               CAEN V830 scaler modules.  This is a latching scaler module.
               At present, not all functionality has been enabled. Specifically,
               the module code is now tailored to the typical use case of a
               run-time scaler module in the scaler stack.
           </para>

           <para>
               The <command>create</command> subcommand creates a new module.
               The <parameter>base</parameter> address should be the VME base
               address of the module, as configured in the module's
               rotary switches.  The <parameter>name</parameter> parameter is
               a name that you assign to the module, and will be used to
               refer to the module in future <command>config</command> or
               <command>cget</command> commands.
            </para>
            <para>
               The <command>config</command> subcommand configures the module
               <parameter>name</parameter>.  The configuration is supplied as a
               set of <parameter>option value</parameter> pairs.  More than one
               pair can appear on the same line, any number of <command>config</command>
               commands can be used and those that execute later can override
               those that execute earlier.
            </para>
            <para>
               The <command>cget</command> subcommand returns the configuration
               of the module <parameter>name</parameter> as a list of
               <parameter>option value</parameter> pairs.  You should not
               rely on the list being in any specific order.  While the list
               order is determinstic within a version of the program it is possible
               that later versions will return the list in a different order.
            </para>
        </refsect1>
        <refsect1>
           <title>
      	OPTIONS
           </title>
           <variablelist>
      	<varlistentry>
      	    <term><option>-base</option> <replaceable>address</replaceable></term>
      	    <listitem>
      		<para>
                  Allows you to override the base address of the module set at
                  creation time with a new base <parameter>address</parameter>.
      		</para>
      	    </listitem>
      	</varlistentry>
         <varlistentry>
            <term><option>-channels</option> <replaceable>mask</replaceable></term>
            <listitem>
               <para>
                  Provides a mask of enabled channels.  The low order bit represents
                  channel zero the high order bit, channel 31.  Each channel for which
                  a bit is present is enabled to count.  The default value for this
                  mask is <literal>0xffffffff</literal> which enables all channels.
               </para>
            </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-dwelltime</option> <replaceable>value</replaceable></term>
               <listitem>
                  <para>
                     This is used only if the <option>-trigger</option> is set
                     to <literal>periodic</literal> and is the time between
                     triggers in 400ns units.  Each trigger will latch the
                     current counter values into the MEB and, if
                     <option>-autoreset</option> is true, clear them.
                     If the <option>-ipl</option> and <option>-vector</option>
                     are set, this can produce a backplane interrupt which, in turn,
                     can trigger execution of a stack. The default value is zero
                     which disables the periodic trigger.
                  </para>
		  <para>
		    Defaults to <literal>0</literal>
		  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-header</option> <replaceable>bool</replaceable></term>
               <listitem>
                  <para>
                     Enables or disables the inclusion of a header on data read from
                     the MEB.  For the format of the header, see figure 3.1 of the
                     CAEN V820/V830 manual.  Note that this header will only be present
                     if the MEB is read out.  A value of <literal>true</literal>
                     enables the header while a value of <literal>false</literal> disables it.
                     The default value is <literal>false</literal> which is appropriate
                     for the case where this module will be used in a scaler stack.
                  </para>
		  <para>
		    Defaults to <literal>false</literal>
		  </para>
               </listitem>
            </varlistentry>
	    
            <varlistentry>
               <term><option>-trigger</option> <replaceable>random | periodic | vme</replaceable></term>
               <listitem>
                  <para>
                     Determines the source the latch trigger.  The values are
                     as follows:
                     <variablelist>
                        <varlistentry>
                           <term><literal>random</literal></term>
                           <listitem>
                              <para>The external trigger input is used to
                                 trigger the latch.
                              </para>
                           </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>periodic</literal></term>
                           <listitem>
                              <para>The module will have a periodic trigger that
                                 is governed by the value of the <option>-dwelltime</option>
                                 option.
                              </para>
                           </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>vme</literal> (default)</term>
                           <listitem>
                              <para>Triggers will be supplied by the stack that'
                                 reads the module out.
                              </para>
                           </listitem>
                        </varlistentry>
                     </variablelist>
                  </para>
		  <para>
		    Defaults to <literal>vme</literal>.  this means triggers
		    will come via VME bus cycles.
		  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-wide</option>  <replaceable>bool</replaceable></term>
               <listitem>
                  <para>
                     Determines if, when the MEB is read, the scalers will be
                     wide (32 bit counters) or narrow (24 bit counters tagged
                     with the channel number).  See figures 3.2 and 3.3 in
                     the CAEN V820/830 manual for the data forma in both
                     cases.
                  </para>
                  <para>
                     A value of <literal>true</literal> enables wide
                     (32 bit) mode. A value of <literal>false</literal> requests
                     narrow (24 bit) mode.  This only affects data read from the
                     MEB.  The counter data are always wide.
                     The default value is <literal>true</literal>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-autoreset</option>  <replaceable>bool</replaceable></term>
               <listitem>
                  <para>
                     Configures the scaler to reset its counters after storing the data in the
                     MEB or not.  If <literal>true</literal> the counters are
                     cleared after latching the data.  If <literal>false</literal> not.
                     The defeault value is <literal>true</literal>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-geo</option>  <replaceable>slot</replaceable></term>
               <listitem>
                  <para>
                     Programs the module geographical address.  This value is only
                     relevant if <option>-header</option> is <literal>true</literal>
                     or <option>-wide</option> is <literal>false</literal>.
                     The value can only be programmed for modules that do not have
                     the PAUX connector.  Modules with the PAUX connector read their
                     geographical address from the backplane, and this value,
                     if used in other places, must be set to the physical slot number
                     the scaler is using (not a bad idea in any event).
                  </para>
		  <para>
		    The default value is <literal>0</literal>
		  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-setgeo</option> <replaceable>bool</replaceable></term>
               <listitem>
                  <para>
                     If <literal>true</literal> the configuration code attempts
                     to set the module's GEO value from the <option>-geo</option>
                     parameter.  If not, the <option>-geo</option> value is
                     simply assumed to document the position of the module to other
                     software, and is ignored.  The default value is <literal>false</literal>
                     which is suitable for modules without a PAUX connector and
                     for the normal use case of a module in the scaler stack where
                     the GEO address is not relevant.
                  </para>
		  <para>
		    The default value of this option is <literal>false</literal>
		  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-ipl</option>  <replaceable>priority</replaceable></term>
               <listitem>
                  <para>
                     Provides the interrupt priority level for the module's
                     VME interrupt.  The V830 can interrupt when it has at least
                     <option>-highwatermark</option> events in its MEB.
                     This interrupt can be used to trigger a VM-USB stack.
                  </para>
                  <para>
                     VME bus interrupts are prioritized with the priority value
                     ranging from <literal>1</literal> through <literal>7</literal>.
                     This priority determines the service order of simultaneous interrupts.
                     Larger numbers are higher priorities.   A value of
                     <literal>0</literal> disables module interrupts.  The
                     default value is <literal>0</literal>
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-vector</option>  <replaceable>statusid</replaceable></term>
               <listitem>
                  <para>
                     VME interrupts are identified via a <firstterm>status-id</firstterm>
                     value presented by the interrupting device when the interrupt is
                     acknowledged by the <firstterm>interrupt responder</firstterm>
                     (VM-USB).  In the case of the CAEN V830, this is a value
                     from <literal>0</literal> through <literal>255</literal>.
                  </para>
                  <para>
                     For historical reasons, this status-id value is also called the
                     <firstterm>interrupt vector</firstterm>.  The <option>-vector</option>
                     option sets the value of the interrupt vector presented by the
                     CAEN V830 when it interrupts.  To interrupt, the module must also
                     be configured with a nonzero <option>-ipl</option> and
                     nonzero <option>-highwatermark</option> value.
                  </para>
                  <para>
                     Module interrupts can be used to triggers VM-USB stack
                     execution. 
                  </para>
		  <para>
		    Default value is <literal>0</literal>, which disables
		    interrupts.
		  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-highwatermark</option> <replaceable>value</replaceable></term>
               <listitem>
                  <para>
                     Configures the value of the V830 <firstterm>Almost Full Level</firstterm>
                     register.  When non zero, if <option>-ipl</option> is also non-zero,
                     and <option>-vector</option> is also non zero, when there is at least
                     <parameter>value</parameter> events in the MEB, the module
                     will initiate a VME bus interrupt.  VME interrupts can be
                     used to trigger VM-USB stacks.  The default value is 1.
                  </para>
               </listitem>
            </varlistentry>
            </variablelist>
        </refsect1>

        <refsect1>
           <title>EXAMPLES</title>
           <para>
               The following example shows how to set up a CAEN V830 scaler
               for inclusion in the scaler stack.  The base address of the
               scaler is <literal>0x80000000</literal>.  The default configuration
               values are suitable for the scaler stack.
           </para>
           <example>
            <title>Configuring a CAEN V830 scaler</title>
               <programlisting>
v830 create scaler 0x80000000
               </programlisting>
           </example>
        </refsect1>

      </refentry>
      <refentry id="vmusb3-v977">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
		<personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
	<refmeta>
	   <refentrytitle>v977</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
	</refmeta>
	<refnamediv>
	   <refname>v977</refname>
	   <refpurpose>Create and configure CAEN V977 Input registers</refpurpose>
	</refnamediv>
	
	<refsynopsisdiv>
	  <cmdsynopsis>
	  <command>
v977 create <replaceable>name ?option value...?</replaceable>
	  </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	  <command>
v977 config <replaceable>name option value ?...?</replaceable>	  
	  </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	  <command>
v977 cget <replaceable>name</replaceable>	  
	  </command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	   <title>DESCRIPTION</title>
	   <para>
This command supports the CAEN V977 I/O register.  At this time support is only
provided to read the module's input register.  Other than setup modes that
echo the inputs to the outputs in some way, output is not supported.
	   </para>
	   <para>
The <command>create</command> subcommand creates a new module.  The <parameter>name</parameter>
parameter supplies a unique name by which that module will be known throughout the
rest of the configuration file.  The optional <parameter>option value</parameter>
pairs provide additional configuration options and can be selected from the
set of configuration options described in OPTIONS below.
	   </para>
	   <para>
The <command>config</command> subcommand allows you to further configure an
existing module.  The <parameter>name</parameter> parameter is the name
you assigned to the module in the <parameter>create</parameter> operation.
The <parameter>option value</parameter> pairs configure the module and can
be selecte from the configuration options described in OPTIONS below.
	   </para>
	   <para>
The <command>cget</command> allows you to retrieve the current configuration of
the module.  The <parameter>name</parameter> parameter provides the name of the module
as defined by the <command>create</command> subcommand.  The result is a
well formed Tcl list that consists of option name value pairs.
	   </para>
	</refsect1>
	<refsect1>
	   <title>OPTIONS</title>
	   <para>
          Configuration options provide a mechanism to define where a module
			 is located in the VME space as well as how the moduile should be
			 prepared for data taking.  A module is configured via the
			 <command>config</command> subcommand.  That command identifies
			 the module via the name assigned to it in the <command>create</command>
			 operation and provides configuration information in the form of
			 a set of name value pairs.  
	   </para>
		<para>
          Each name selects what is to be configured and each value provides
          the new value for that item.
          The configuration keywords supported and the meanings of their values
          are described below.
      </para>
      <variablelist>
          <varlistentry>
               <term><option>-base</option> <replaceable>base-address</replaceable></term>
               <listitem>
                  <para>
                     Defines the base address of the module.
                     <parameter>base-address</parameter> must match the base address
                     set in the module's rotary switches.  This address is used
                     to determine how to access the module in VME address space.
                  </para>
               </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-inputmask</option>  <replaceable>mask</replaceable></term>
             <listitem>
                <para>
                   Provides the value of the module's input mask register.
                   The value of <parameter>mask</parameter> is programmed into
                   the module's input mask register at initialization time.
                   Each bit set in the register prevents the corresponding
                   front panel input from being seen by the module.
               </para>
		<para>
		    This defaults to <literal>0</literal>
		</para>
             </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-readmode</option>  <replaceable>mode</replaceable></term>
             <listitem>
                <para>
                   Together with the <option>-readandclear</option>, determines
                   which register is actually read by the stack.  Legal values
                   are <literal>singlehit</literal> and <literal>multihit</literal>.
                   If <literal>singlehit</literal> is selected (the default) is
                   provided the module will read either the Single hit read
                   register or the Singlehit read-clear register depending on the
                   value of the <option>-readandclear</option>.  <literal>multihit</literal>
                   is selected, the module's multihit read or multihit read-clear
                   register will be read.
                   </para>
               <para>
                   See the table at the end of this section for a complete
                   listing of the combinations of read modes and read and clear
                   settings and their implications for how the module is read.
                   </para>
	       <para>
		    Defaults to <literal>singlehit</literal>
	       </para>
              </listitem>
          </varlistentry>
          <varlistentry>
              <term><option>-outputmask</option>  <replaceable>mask</replaceable></term>
              <listitem>
                 <para>
                    Provides a value for the output mask register.
                    This defaults to zero.
                    </para>
                 </listitem>
          </varlistentry>
          <varlistentry>
              <term><option>-interruptmask</option> <replaceable>mask</replaceable></term>
              <listitem>
                 <para>
                    Provides a value that will be programmed into the
                    output mask regiseter.  The module can produce an interrupt
                    if bits that are not masked off in this register are set
                    in the pattern gated into the module.  See also the
                    <option>-ipl</option> and <option>-vetor</option> if
                    you intend to use the module with interrupts.
                    </para>
		 <para>
		    Defaults to <literal>0</literal>
		 </para>
                 </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-readandclear</option> <replaceable>true|false</replaceable></term>
             <listitem>
                <para>
                   Determines whether the module will be atomically cleared
                   as it is read.  This option together with the
                   <option>-readmode</option> determines which module register
                   read is added to the readout stack.  For more information,
                   see the table at the end of this section.
                </para>
		<para>
		    Defaults to <literal>true</literal>
		</para>
             </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-ipl</option> <replaceable>interrupt-level</replaceable></term>
             <listitem>
                <para>
                   Determines the interrupt priority level used by the module
                   when creating interrupt requests on the VME dataway.  If
                   <parameter>interrupt-level</parameter> is <literal>0</literal>
                   (the default), interrupts will not be used.
                </para>
		<para>
		    Defaults to <literal>0</literal>
		</para>
             </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-vector</option> <replaceable>status-id</replaceable></term>
             <listitem>
                <para>
                   When the module creates a VME dataway interrupt it provides the
                   <parameter>status-id</parameter> as the interrupt vector
                   when requested to by the interrupt handler module (VM-USB normally).
                   If the <parameter>status-id</parameter> is <literal>0</literal>
                   (default), interrupts are not generated on the dataway.
                </para>
		<para>
		    Defaults to <literal>0</literal>
		</para>
             </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-pattern</option> <replaceable>true|false</replaceable></term>
             <listitem>
                <para>
                   If this is <literal>true</literal>, the pattern bit is set
                   int he control register, and the module operates in pattern
                   mode.  If not, the module operates in I/O register mode.
                </para>
		<para>Defaults to false</para>
             </listitem>
          </varlistentry>
          <varlistentry>
	      <term><option>-gate</option> <replaceable>true | false</replaceable></term>
	      <listitem>
		  <para>
		    If true the module is in gate mode.  This default to
		    <literal>trueSS</literal>
		  </para>
	      </listitem>
	  </varlistentry>
	  <varlistentry>
	      <term><option>ormask</option> <replaceable>true | false</replaceable></term>
	      <listitem>
		  <para>
		    If true, sets the ORmask bit in the CSR.  Defaults to
		    <literal>false</literal>.
		  </para>
	      </listitem>
	  </varlistentry>
      </variablelist>
      <table frame='all'>
	  <title>Readmode and Read and clear implications</title>
	  <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	       <thead>
		    <row>
			 <entry>Read mode</entry>
			 <entry>Read and clear</entry>
			 <entry>Readout meaning</entry>
		    </row>
	       </thead>
	       <tbody>
		    <row>
			 <entry>singlehit</entry>
			 <entry>false</entry>
			 <entry>The SingleHitRead register (0x0006) will be read.
			 </entry>
		    </row>
		    <row>
			 <entry>singlehit</entry>			 
			 <entry>false</entry>
			 <entry>The SingleHitRdClear register (0x0016)
			      will be read.
			 </entry>
		    </row>
		    <row>
			 <entry>multihit</entry>
			 <entry>true</entry>
			 <entry>
			      The MultiHitRdClear register (0x0018) will be read.
			 </entry>
		    </row>
		    <row>
			 <entry>multhit</entry>
			 <entry>false</entry>
			 <entry>
			      The MultiHitRead register (0x0008) will be read.
			 </entry>
		    </row>
	       </tbody>
	  </tgroup>
	  
      </table>
	</refsect1>
      
      </refentry>
      <refentry id="vmusb3-sis3804">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
		<personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
        <refmeta>
           <refentrytitle>sis3804</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>sis3804</refname>
           <refpurpose>Create and configure SIS 3804 scalers</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
sis3804 create <replaceable>name ?options...?</replaceable>
              </command>
          </cmdsynopsis>
    <cmdsynopsis>
        <command>
sis3804 config <replaceable>name options...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
      <command>
sis3804 cget <replaceable>name option</replaceable>
      </command>
    </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
              This command creats and manipulates SIS3804 objects.  The SIS3804
              is an 8 channel latching scaler manufactured by Struck.  The
              SIS3804 objects can configure and add readout instructions for this
              hardware to VM-USB stacks.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
              <varlistentry>
                  <term><option>-base</option> <replaceable>base-address</replaceable></term>
                  <listitem>
                      <para>
                        Sets the base address of the module. This must match the
                        value selected by  the rotary switches on the module.
                        The default for this option is 0, which is typically not
                        what you want.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
               <term><option>-refpulser</option> <replaceable>boolean</replaceable></term>
               <listitem>
                  <para>
                     Enables or disables the reference pulser.  When enabled,
                     the reference pulser disables the input to channel 1 and
                     supplies a 25Mhz pulse frequency to that channel.
                  </para>
                  <para>
                     A value of <literal>true</literal> enables the pulser while
                     <literal>false</literal> (the default) disables the reference
                     pulser.
                  </para>
               </listitem>
              </varlistentry>
              <varlistentry>
                  <term><option>-disables</option> <replaceable>mask</replaceable></term>
                  <listitem>
                     <para>
                        Allows you to disable specific channels from counting.
                        The bottom 8 bits if set disable the corresponding channel
                        of the pulse.  For example if mask &amp; 1 is nonzero,
                        channel 1 (numbered from 1) is disabled, while if
                        mask &amp; 0x10 is nonzero, channel 8 is disasbled.
                     </para>
                     <para>
                        The default value is zero which enables all channels.
                     </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
               <term><option>-autoclear</option> <replaceable>boolean</replaceable></term>
               <listitem>
                  <para>
                     If this option is <literal>true</literal> (the default),
                     scalers are cleared atomically after being latched for readout.
                     The NSCL data acquisition system scaler display program
                     expects the scaler counters to be incremental values  with
                     the sums computed in software (so that overflows can be
                     explicitly managed).  If you have a special application for this
                     scaler, e.g. to provide timestamps in an event, for which you
                     do not want this behavior, you can set this option to <literal>false</literal>
                  </para>
               </listitem>
              </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
           <title>EXAMPLES</title>
           <para>
            The example below creatse a scaler at the manufacturer's setting
            for the base address and configures it to have the 25Mhz
            reference pulser in channel 1:
           </para>
           <example>
            <title>Configuring the SIS 3804 scaler</title>
            <programlisting>
sis3804 create scaler1 -base 0x38383800
sis3804 config scaler1 -refpulser true
            </programlisting>
           </example>
        </refsect1>
      
      </refentry>
      <refentry id="vmusb3-hira">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
		<personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
        <refmeta>
           <refentrytitle>hira</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>hira</refname>
           <refpurpose>Pair up to 2 XLMs and FADC for HiRA</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
hira create <replaceable>name ?options?</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
hira config <replaceable>name options</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
hira cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            In situations where an XLM-XXV is not available, Wash-U chip boards
            can be read out using an XLM and an SIS3300/SIS3301 FADC module.
            This command allows you to combine these into a single module.
            from the point of view of a stack.
           </para>
           <note>
               <title>Note:</title>
               <para>
                  Normally the XLM modules used are either a hinp or psd
                  module.  As the code for these is maintained by Washington
                  Univ,  Those drivers are not documented here.
               </para>
           </note>
           <para>
            The command produces the following data format:
           </para>
           <informalexample>
            <programlisting>
+------------------------------------+
|   id (16) bits                     |
+------------------------------------+
| tag data from the xlm  1 srama     |
...
| tag data from xlm1 sram b          |
../
+------------------------------------+
| 0xfadc                             |
+------------------------------------+
| Mask of read groups                |
+------------------------------------+
| Data from the FADC module group1   |
+------------------------------------+
| 0xaaa                              |
+------------------------------------+
...
| Data from the FADC module group2   |
...
+y------------------------------------+
            </programlisting>
           </informalexample>
           <para>
            Note that the configuration parameters of the XLM's determine whether
            or not both SRAM banks are read, the configuration of the FADC determines
            which FADC groups are read, and the <option>-xlm</option> option value
            determines whether one or two XLM modules are associated witht this
            HiRA module.
          </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-id</option> <replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        Provides the id tag that precedes the data from the
                        two actual modules.  This defaults to
			<literal>0x618a</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-xlm</option> <replaceable>module-name</replaceable></term>
                <listitem>
                    <para>
                        This parameter is a list of one or two XLM modules assoiated
                        with this HiRA. This has no default.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-fadc</option> <replaceable>module-name</replaceable></term>
                <listitem>
                    <para>
                        This parameter is the name of the sis330x module that
                        gets the analog data.  This has no default.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
           <note>
            <title>Note:</title>
            <para>
                The software does not check that the XLM is an XLM or that the
                fadc is an SIS 330x module.
            </para>
           </note>
        </refsect1>

      </refentry>

      <refentry id="vmusb3-hytec">
        <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
	    <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
        <refmeta>
           <refentrytitle>hytec</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>hytec</refname>
           <refpurpose>Support the Hytec NADC 2530 adc module.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
hytec create <replaceable>name ?options?</replaceable>
              </command>
          </cmdsynopsis>
<cmdsynopsis>
    <command>
hytec <replaceable>config name ?options?</replaceable>
    </command>
</cmdsynopsis>
<cmdsynopsis>
    <command>
hytec cget <replaceable>name</replaceable>
    </command>
</cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
              This command provides support for the Hytec NADC2530.  The NADC2530
              is an 8 channel multi-event peak sensing adc.  While the module
              is capable of autonomously creating histograms, this software does
              not support that capability as it's much easier to treat that
              module differently if used in that way.
           </para>
	   <para>
	    Beginning with the VM-USB readout program verssion 3.2-001, the
	    software tags the ADC data with a user defined virtual slot number,
	    and the module provides a 48 bit timetamp with each event if
	    its firmware revision is 2530V305 or later.
	   </para>	
           <para>
               As for all VM-USB module support commands, <command>hytec</command>
               is a command ensemble with the subcommands
               <variablelist>
                  <varlistentry>
                     <term><command>create</command></term>
                     <listitem>
                        <para>Which creates an object for an NADC2530 adc
                           which can be referred to by the name <parameter>name</parameter>.
                           Additional options can provide device configuration.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><command>config</command></term>
                     <listitem>
                        <para>
                           Which configures the existing device object
                           <parameter>name</parameter>
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><command>cget</command></term>
                     <listitem>
                        <para>
                           Which returns the module <parameter>name</parameter>'s
                           configuration as an item list of name value pairs.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
                                                                
           </para>
            <para>
               Configuration options are described in the OPTIONS section below.
            </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
              <varlistentry>
                  <term><option>-csr</option> <replaceable>address</replaceable></term>
                  <listitem>
                      <para>
                           This option must appear somewhere in the module configuration.
                           It establishes the base address of the module's
                           register space.  The NADC 2530 has two address spaces,
                           register space, used to configure and control the module,
                           and memory space where events get stored.
                      </para>
                      <para>
                        The <parameter>address</parameter> is an A24 address.
                        this means it must be in the range
                        <literal>0x000000</literal> through <literal>0xffffff</literal>.
                        Each module must have a unique base address, and the address
                        configured in the software must match the address configured
                        in the module's address jumpers.
                      </para>
		      <para>
			 The default for this parameter is <literal>0</literal>
		      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
               <term><option>-memory</option> <replaceable>address</replaceable></term>
               <listitem>
                  <para>
                     This option must appear somewhere in the module configuration.
                     It establishes the base address of the module's event buffer
                     memory. Each module's event memory must carve out a unique
                     slice of A32 address space (values between
                     <literal>0x00000000</literal> and <literal>0xffffffff</literal>).
                  </para>
                  <para>
                     The buffer memory address space is software programmable.
                     See the NADC2530 manual for the size of this address space
                     as any overlap can cause corrupted data to be read from the
                     modules.
                  </para>
		  <para>
		    The default for this parameter is <literal>0</literal>
		  </para>
               </listitem>
              </varlistentry>
               <varlistentry>
                  <term><option>-ipl</option> <replaceable>irqlevel</replaceable></term>
                  <listitem>
                     <para>
                        If you are using the module's interrupt to trigger
                        a stack execution, <parameter>irqlevel</parameter> must
                        be a nonzero value between <literal>1</literal> and
                        <literal>7</literal>, and will be the interrupt priority
                        level on which the module will generate an iterrupt request.
                     </para>
                     <para>
                        The value of this parameter defaults to <literal>0</literal>
                        which disables module interrupts.  See also the
                        <option>-vector</option> option below.
                     </para>
		     <para>
			 Defaults to <literal>0</literal> which disables interrupts.
		     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-vector</option> <replaceable>statusid</replaceable></term>
                  <listitem>
                     <para>
                        If the module is being used to trigger a stack,
                        <parameter>statusid</parameter> should be the value the
                        module will use to reply to the interrupt acknowledge cycle's
                        request for a status/id from the module.
                     </para>
                     <para>
                        The NADC2530 has a status/id 16 bits wide
                        (between <literal>1</literal> and <literal>65535</literal>
                        where zero disables the interrupt).  The VM-USB, however
                        only triggers on the bottom 8 bits of the status id field.
                        therefore you should use values between
                        <literal>1</literal> and <literal>255</literal> unless
                        you are directing the interrupt at other modules in the VME
                        crate.
                     </para>
		     <para>
			 Defaults to <literal>0</literal> wich disables the interrutps.
		     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-lld</option> <replaceable>millivolts</replaceable></term>
                  <listitem>
                     <para>
                        Provides the low level threshold value in <parameter>millivolts</parameter>.
                        Due to the resolution of the threshold DAQ, the actual threshold
                        value programmed may be slightly different than the one requested.
                        See the manual for the relationship between
                        <parameter>millivolts</parameter> and threshold DAC values.
                     </para>
		     <para>
			 Defaults to <literal>0.0</literal> millivolts.
		     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-hld</option> <replaceable>volts</replaceable></term>
                  <listitem>
                     <para>
                        Provides the high level discriminator value in floating
                        point <parameter>volts</parameter>.  Due to the
                        Due to the resolution of the threshold DAQ, the actual threshold
                        value programmed may be slightly different than the one requested.
                        See the manual for the relationship between
                        <parameter>volts</parameter> and threshold DAC values.
                     </para>
		     <para>
			 Default is <literal>8.191</literal> which is the full
			 scale range of the ADC.
		     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-events</option> <parameter>count</parameter></term>
                  <listitem>
                     <para>
                        Indicates that <parameter>count</parameter> events must
                        be in the event buffer before an interrupt will be
                        signalled on the VME backplane.  This item also configures
                        how many events are required for the module to indicate
                        that it has data.  Therefore, if not being used with interrupts,
                        this value should be programmed to its default value of
                        <literal>1</literal>
                     </para>
                  </listitem>
               </varlistentry>
	       <varlistentry>
		  <term><option>-id</option> <parameter>value</parameter></term>
		  <listitem>
		     <para>
			Provides a 16 bit id (virtual slot number) that will be
			used to tag the data.  The NADC2530 is not capable
			of providing a hardware virtual slot number as of firmware
			2530V305, therefore the <parameter>value</parameter> is
			inserted as a marker word prior to the data from the ADC.
		     </para>
		     <para>
			 Defaults to 0
		     </para>
		     </listitem>
		  </varlistentry>
	       <varlistentry>
		  <term><option>-zerosuppress</option> <parameter>on|off</parameter></term>
		  <listitem>
		     <para>
			If the value of this parameter is a true boolean, the
			channels that are outside the high and low level
			discriminators are not present in the data from the
			device.  If the value is a boolean true, all 8 channels
			are present in the data.
		     </para>
		     <para>
			 Defaults to <literal>on</literal>
		     </para>
		  </listitem>
	       </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
           <title>EXAMPLES</title>
           <para>
               The example below configures an NADC 2530 with a register base
               address of <literal>0x400000</literal>, and a buffer address
               of <literal>0x10000000</literal>.  It leaves the thresholds
               wide open and does not enable module interrupts.  A marker
	       word 0xadc1 is inserted prior to the data, and, if the
	       discriminator levels are later set, data outside of them
	       will be supressed from the data stream.:
           </para>
           <example>
            <title>Sample Hytec 2530 configuration</title>
            <programlisting>
hytec create adc
hytec config adc  -csr 0x400000 -memory 0x10000000 
hytec config adc -lld 0.0 -hld 8.191 -events 1 -id 0xadc1 -zerosuppress on
            </programlisting>
           </example>
        </refsect1>
	<refsect1>
	    <title>DATA FORMAT</title>
	    <para>
	       Readout prepends the data from the ADC with three additional
	       data words.  This section describes what to expect in the
	       event file for this module.
	    </para>
	    <para>
	       The first word of data from this module will be the value of
	       the <option>-id</option> optin.  This defaults to zero if
	       not supplied.  This is followed by a mask word, and then a
	       count word.  These two words allow you to determine the number
	       of longwords of ADC data that follow.
	       </para>
	    <para>
	       Suppose the mask word is <literal>mask</literal> and the
	       count word is <literal>count</literal>.
	       <literal>mask &amp; count</literal> computes the number of longwords
	       of ADC data that follow in the data packet from this module.
	       </para>
	    <para>
	       Following these three words, the data from the ADC as shown in
	       section 4.3.1 of the manual is inserted in the event. Note that:
	    </para>
	    <orderedlist>
	       <listitem>
		  <para>
		     The ADC may convert serveral times for a single channel
		     if multiple signal peaks are detected within the gate
		     time.  SpecTcl will only pay attention to the largest of these
		     conversions for a specific channel.
		     </para>
	       </listitem>
	       <listitem>
		  <para>
		     When the system starts up, or if the busy lock out logic
		     is not perfect, and allows gates to go to the ADC when
		     the system is busy, you may see additional events or event
		     fragments.  SpecTcl will only pay attention to the data from
		     the first event (it will stop processing channels after the first)
		     trailer word or after the longword count described above is
		     exhausted.
		  </para>
		  </listitem>
	       <listitem>
		  <para>
		     When the system initially starts, there may be a large number
		     of gates prior to the VM-USB completing intialization...
		     depending on when it actually asserts busy.  Once more SpecTcl
		     will only histogram the first of these events from the ADC.
		     As subsequent data from the ADC should be synchronized to the
		     IN1 trigger, this should at most affect the first event.
		  </para>
	       </listitem>
	       <listitem>
		  <para>
		     When setting up the SpecTcl parameters for this module,
		     remember that the module provides 9 parameters. The first
		     of these is a 48 bit timestamp.  The remaining 8 are the
		     adc parameters.  SpecTcl is not able to guess how you want to
		     set up the timestamp spectrum.  In general this is not a problem
		     as usuall you will be using the timestamp to generate rate
		     stripchart spectra rather than looking at the timestamp
		     itself.
		     </para>
	       </listitem>
	       <listitem>
		  <para>
		     When looking at SpecTcl timestamp based spectra you may see
		     significant gaps in the time online. This happens because of
		     the way data are sampled to SpecTcl from the online system.
		     SpecTcl may miss complete buffers of data online if it is not
		     able to keep up with the data rate.  If you process the
		     event file for that run offline, these gaps disappear.
		     </para>
	       </listitem>
	    </orderedlist>
	</refsect1>
      </refentry>
      <refentry id="vmusb3-tcldriversupport">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
		<personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
        <refmeta>
           <refentrytitle>tcl driver support</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>tcl driver support</refname>
           <refpurpose>tcl driver support functions.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require VMUSBDriverSupport
            </command>
          </cmdsynopsis>
        <cmdsynopsis>
            <command>
::VMUSBDriverSupport::convertVmUSB <replaceable>name</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::VMUSBDriverSupport::convertVmUSBReadoutList <replaceable>name</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validInt <replaceable>value ?low ?high??</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validReal <replaceable>value ?low ?high??</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::valideEnum <replaceable>value set</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validBool <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validList <replaceable>value ?fewest ?most ?checker ?args????</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validIntList <replaceable>value ?fewest ?most ?low ?high????</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validBoolList <replaceable>value ?fewest ?most???</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides utiltities that are of use/interest to
            Tcl device driver modules for the VM-USB readout framework.
            The attempt is to centralize/factor common code out of driver
            modules that is commonly used.  
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
           <variablelist>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::convertVmUSB <replaceable>name</replaceable>
                </command></term>
                <listitem>
                    <para>
                        Converts a swig CVMUSB object identifier into a usable
                        CVMUSB object.  Once converted the driver can invoke
                        methods on that object.  <parameter>name</parameter>
                        is the object passed in to the driver.  The return
                        value will be the  name of the new object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::convertVmUSBReadoutList <replaceable>name</replaceable></command></term>
                <listitem>
                    <para>
                        Converts a CVMUSBReadoutList swig object identifier into
                        an object.  Once converted, the object methods can
                        be directl invoked.
                        <parameter>name</parameter> is the name passed in to the
                        method by the framework.  the return value is the
                        name of the object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validInt <replaceable>value ?low ?high??</replaceable></command></term>
                <listitem>
                    <para>
                        Provides type checking and optional range checking for
                        integer data. This is most often called to validate
                        an integer driver option.
                    </para>
                    <para>
                        Throws an error if <parameter>value</parameter> is not
                        a valid integer.  Additionally, if <parameter>low</parameter>
                        is not empty, an error is thrown if
                        <literal>$value &lt; $low</literal>.  Similarly if
                        <parameter>high</parameter> is not empty an error
                        is thrown if <literal>$value &gt; $high</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validReal <replaceable>value ?low ?high??</replaceable></command></term>
                <listitem>
                    <para>
                        Provides type and optional range checking for
                        real parameters.
                    </para>
                    <para>
                        If <parameter>value</parameter> is not valid real number
                        this proc throws an error.  Furthermore if <parameter>low</parameter>
                        is not blank, an error is thrown if <literal>$value &lt; $low</literal>.
                        Similarly if <parameter>high</parameter> is not blank,
                        an error is thrown if <literal>$value &gt; $high</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::valideEnum <replaceable>value set</replaceable></command></term>
                <listitem>
                    <para>
                        Throw an error if <parameter>value</parameter> is not
                        one of the strings  in the Tcl list <parameter>set</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validBool <replaceable>value</replaceable></command></term>
                <listitem>
                    <para>
                        Throws an error if <parameter>value</parameter> is not
                        recognizable as a boolean by Tcl.
                        <ulink url='http://www.tcl.tk/man/tcl8.5/TclLib/GetInt.htm'>
                            http://www.tcl.tk/man/tcl8.5/TclLib/GetInt.htm</ulink>
                        describes the set of <parameter>value</parameter>s that are
                        recognized as valid booleans.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validList <replaceable>value ?fewest ?most ?checker ?args????</replaceable>
                </command></term>
                <listitem>
                    <para>
                        Throws an error if <parameter>value</parameter> is not
                        a valid Tcl list.  Futhermore if <parameter>fewest</parameter>
                        is not blank, an error is thrown if
                        <literal>[llength $value] &lt; $fewest</literal>.
                        Similarly, if <parameter>most</parameter> is not blank,
                        an error is thrown if
                        <literal>[llength $value] &gt; $most</literal>.
                    </para>
                    <para>
                        <parameter>checker</parameter> is a script which if
                        not blank is called for each element of
                        <parameter>value</parameter>. <parameter>checker</parameter> is
                        called as follows: <literal>$checker $element {*}$args</literal>
                        where <parameter>element</parameter> is an element of the
                        list.  The intent of this is to provide support for
                        type/range checking each element of the list.
                    </para>
                    <para>
                        One sample use of this proc is:
                        <literal>::::VMUSBDriverSupport::validList $value 32 32 ::::VMUSBDriverSupport::validInt 0 4095</literal>
                        which ensures that <parameter>value</parameter> is a valid
                        list that contains exactly 32 integer elements in the range
                        <literal>[0..4095]</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validIntList <replaceable>value ?fewest ?most ?low ?high????</replaceable>
                </command></term>
                <listitem>
                    <para>
                        This is a convenience procedure that uses <function>validList</function>
                        and <function>validInt</function> to determine if
                        <parameter>value</parameter> is a valid list of
                        integer values with optional range constraints.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validBoolList <replaceable>value ?fewest ?most???</replaceable>
                </command></term>
                <listitem>
                    <para>
                        This is a convenience procedure that uses <function>validList</function>
                        and <function>validBool</function> to determine if
                        <parameter>value</parameter> is a valid list of
                        boolean values.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>

      <refentry id="vmusb3-madc">
        <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
	    <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
        <refmeta>
           <refentrytitle>madc</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>madc</refname>
           <refpurpose>Acquire events from Mesytec MADC32 ADC.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
madc create <replaceable>name ?options?</replaceable>              
              </command>
          </cmdsynopsis>
         <cmdsynopsis>
             <command>
madc config <replaceable>name ?options?</replaceable>
             </command>
         </cmdsynopsis>
         <cmdsynopsis>
             <command>
madc cget <replaceable>name</replaceable>         
             </command>
         </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
         
           <title>DESCRIPTION</title>
           <para>
              The <command>madc</command> command provides scripted support
               for the Mesytec 32 channel peak sensing adc module.  For scaler
               support for this module's dead time counters, see the
               <link linkend="vmusb3-madcscaler">madcscaler</link> command.
           </para>
           <para>
               As with all VM-USB module support commands, <command>madc</command>
               is a command ensemble with subcommands that
               <command>create</command> and
               <command>config</command>ure modules as well as
               <command>cget</command> which introspects a module configuration.
           </para>
           <para>
               <command>create</command> creates an object with the specified
               <parameter>name</parameter>. Additional options are treated like
               configuration options.  <command>config</command> configures
               an existing module, and <command>cget</command> returns a list of
               configuration name/value pairs that describe the configuration of
               the module.
           </para>
            <para>
               It is important to note that the module configuration does not
               actually get loaded until the run is initialized.  The order in
               which configuration parameter are supplied is therefore unimportant.
               Think of the configuration options as being accumulated and then
               applied as the run starts.  Only modules that are in
               <command>stack</command> are configured.
            </para>
          </refsect1>
          <refsect1>
            <title>
              OPTIONS
            </title>
            <variablelist>
              <varlistentry>
                <term><option>-base</option> <replaceable>address</replaceable></term>
                <listitem>
                  <para>
                    <parameter>address</parameter> must be the module base
                    address as configured in its rotary switches.
                    This base address is used to access the module's register
                    and event memory.
                  </para>
                  <para>
                    Each module must be programmed and hardware configured
                    with a different base address. The address used will be
                    an A32 VME address.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-id</option> <replaceable>vsn</replaceable></term>
                <listitem>
                  <para>
                    <parameter>vsn</parameter> will be used as the module's
                    identifier or <firstterm>virtual slot number</firstterm>.
                    The <parameter>vsn</parameter> will be encoded into the
                    event data that is returned by the module.  This, in turn
                    is normally used by event decoders to determine which parameters
                    the channels of the module should be unpacked into.
                  </para>
                  <para>
                    Each module should be given a unique <parameter>vsn</parameter>.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-ipl</option> <replaceable>irqlevel</replaceable></term>
                <listitem>
                  <para>
                    If the module will be used to trigger an interrupt driven
                    stack, the <parameter>irqlevel</parameter> parameter must
                    be programmed to a valid non zero interrupt priority level
                    (<literal>1</literal> through <literal>7</literal>).
                    This must match the interrupt priority level used to trigger
                    the stack.
                  </para>
                  <para>
                    The default value of <literal>0</literal> disables module
                    interrupts.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-vector</option> <replaceable>statusId</replaceable></term>
                <listitem>
                  <para>
                    If the module will be used to trigger an interrupt driven
                    stack, the <parameter>statusId</parameter> must be programmed
                    to a non zero 8 bit status id, or <firstterm>vector</firstterm>
                    (between <literal>1</literal> and <literal>255</literal>
                  </para>
                  <para>
                    The value used must match the value of the
                    <option>-vector</option> configuration parameter used to
                    trigger the stack.  
                  </para>
		  <para>
		    The default value for this parameter is <literal>0</literal>
		  </para>
		  <para>
		    Note that the VMUSB uses a 16 bit status/ID cycle to
		    read the interrupt vector from the module, while the
		    actual status id is 8 bits wide.  The VME standard
		    is ambiguous about how the top bits of this 16 bit value
		    are set.  The MADC32 sets those top bits to 0xff.  Therefore
		    a <option>-vector</option> <literal>0x80</literal> produces
		    a vector, as seen by the VMUSB of <literal>0xff80</literal>.
		  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-timestamp</option>  <replaceable>onoff</replaceable></term>
                <listitem>
                  <para>
                    This option controls whether or not the
                    module tags each event with a trigger number or with a
                    timestamp (see also the
                    <option>-timingsource</option> and
                    <option>-timingdivisor</option> options).
                  </para>
                  <para>
                    The <replaceable>onoff</replaceable> is a boolean value.
                    If true, the module tags events with a timestamp.  If
                    false, with a trigger number.
                  </para>
		  <para>
		    The default value for this parameter is <literal>false</literal>
		  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-gatemode</option>  <replaceable>mode</replaceable></term>
                <listitem>
                  <para>
                    The MADC32 has a pair of gate inputs.  The inputs may
                    be used either as <literal>separate</literal> gates,
                    where each gate controlls 16 of the 32 channels, or
                    as <literal>common</literal> where either input will
                    gate all 32 channels.
                  </para>
                  <para>
                    The value <parameter>mode</parameter> should be either
                    <literal>separate</literal> or <literal>common</literal>.
                  </para>
		  <para>
		    Note that if you use <literal>separate</literal>, you will get
		    data from the modules as if there were two independent
		    16 channel adc modules with the same virtual slot number.
		    You may get zero, one or two packets of data from this module
		    for each VMUSB Stack trigger.  One packet will contain any
		    converting channels for channels <literal>0-15</literal>,
		    the other for channels <literal>16-31</literal>.
		  </para>
		  <para>
		    The default value of this parameter is <literal>common</literal>
		  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-gategenerator</option> <replaceable>onoff</replaceable></term>
                <listitem>
                  <para>
                    The module can either use the gates as provided or can
                    insert a gate and delay generator between the gate inputs
                    and the actual gates seen by the ADCs.  Since in most cases,
                    gate must be stretched and timed to match the ADC inputs,
                    this feature can reduce the external electronics needed to
                    properly gate the adc.
                  </para>
                  <para>
                    The <parameter>onoff</parameter> is a boolean that if
                    true enables this gate generator, if false, disables it.
                    See also the <option>-holddelays</option> and
                    <option>-holdwidths</option> configuration parameters
                    that control the gate and delay parameters for each of these
                    resources.
                  </para>
		  <para>
		    By default, the value of this parameters is <literal>false</literal>.
		  </para>
		  <para>
			Beginning with 11.2-006, a new set of values has been added, in
			addition to the valid booleans.  The full list of values and
			behaviors is as follows:
		  </para>
		  <variablelist>
			<varlistentry>
                <term><literal>on, true, yes, 1, enabled</literal></term>
                <listitem>
                    <para>
					If <option>-gatemode</option> is <literal>common</literal>,
					gate generator 0 only is enabled, otherwise, both
					gate generators are enabled.  Note in this and
					the following discussions, gate generator 1 can only be
					enabled if <option>-gatemode</option> is
					<literal>separate</literal>.  This is stated in the
					MADC32 manual.
                    </para>
                </listitem>
            </varlistentry>
		  <varlistentry>
            <term><literal>off, false, no, 0, disabled</literal></term>
            <listitem>
                <para>
				Neither gate generator is enabled, regardless of
				<option>-gatemode</option>
                </para>
            </listitem>
          </varlistentry>
		  <varlistentry>
            <term><literal>gdg0</literal></term>
            <listitem>
                <para>
				Regardless of <option>-gatemode</option>, gate generator 0
				is enabled.  Gate generator 1 is not enabled.
                </para>
            </listitem>
          </varlistentry>
		  <varlistentry>
            <term><literal>gdg1</literal></term>
            <listitem>
                <para>
				If <option>-gatemode</option> is separate, gate generator
				 1 is enabled.  If <option>-gatemode</option> is
				 <literal>common</literal>, an error is thrown when you
				 try to start the run. 
                </para>
			 <para>
				The error is thrown then because there's no other time that
				drivers can perform validations across more than one
				option.
			 </para>
            </listitem>
          </varlistentry>
		  </variablelist>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-holddelays</option> <replaceable>delayList</replaceable></term>
                <listitem>
                  <para>
                    If the gate generators are enabled (see
                    <option>-gategenerator</option> above), the
                    <parameter>delayList</parameter> is a Tcl list consisting of
                    the two delay parameters, one for each of the gate and
                    delay generators. See the MADC32 manual for a description of
                    the meaning of these values, which are just the values
                    programmed into the module registers.
                  </para>
		  <para>
		    By default, the value of this parameter is a list of two
		    <literal>15</literal> values.
		  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-holdwidths</option> <replaceable>widthList</replaceable></term>
                <listitem>
                  <para>
                    If the gate generators are enabled (see
                    <option>-gategenerator</option> above), the
                    <parameter>widthList</parameter> is a Tcl l ilst
                    consisting of the two gate and delay generator width
                    parameters.  See the MADC32 manual for a description
                    of the meaning of these values, which are just the
                    values programmed into the module registers.
                  </para>
		  <para>
		    By default the value of this parameter is a list of two
		    <literal>20</literal> values.
		  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-inputrange</option> <replaceable>rangeSelector</replaceable></term>
                <listitem>
                  <para>
                    Programs the input range for the module.
                    The <parameter>rangeSelector</parameter> must
                    <literal>4v</literal>, <literal>8v</literal>,
                    or <literal>10v</literal>.  Where the selector
                        represents the input range in volts.
                  </para>
		  <para>
		    The default value of this parameter is <literal>4v</literal>.
		  </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-ecltermination</option> <replaceable>onoff</replaceable></term>
                  <listitem>
                     <para>
                        This parameter when true enables the ECL input termination.
                        If disabled (Tcl false), the termination is off.  If you are bussing
                        the ECL inputs, only the final module in the bus should
                        have terminatinon enabled, all other modules, should
                        have termination turned off.
                     </para>
		     <para>
			 The default for this parameter is <literal>true</literal>
		     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-ecltiming</option> <replaceable>onoff</replaceable></term>
                  <listitem>
                     <para>
                        This parameter, when true enables the gate1 ECL input to
                        to be a clock source for the timestamp if true.  If false,
                        The ECL G1 input is an ECL gate1.
                     </para>
		     <para>
			 By default this is <literal>false</literal>.
		     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-nimtiming</option> <replaceable>onoff</replaceable></term>
                  <listitem>
                     <para>
                        If true, enables the NIM Gate1 input to be a clock source
                        for the timestamp.  If not, the NIM Gate1 input is an adc gate.
                     </para>
		     <para>
			 By default, <option>-nimtiming</option> is
			 <literal>false</literal>.
		     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-timingsource</option> <replaceable>sourceName</replaceable></term>
                  <listitem>
                     <para>
                        Specifies the source of the clock for timestamps.
                        If <literal>external</literal>, whichever of the NIM or
                        ECL GATE1 inputs are enabled is the clock source.
                        If <literal>vme</literal> the VME 16Mhz backplane
                        clock is the clock.
                     </para>
		     <para>
			 By default <option>-timingsource</option> is
			 <literal>vme</literal>.
		     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-timingdivisor</option> <replaceable>log2</replaceable></term>
                  <listitem>
                     <para>
                        Specifies a scale-down value for the timestamp clock.
                        At the time I'm typing this, this value is log base
                        2 of the scale down, that is
                        the final scale down is 1 &lt;&lt; <parameter>log2</parameter>.
                        By the time we get installed, I am supposed to have
                        some firwmare that will allow this to be a 16 bit
                        direct scaledown (e.g. the scaledown would be between 1 and
                        65535).
                     </para>
		     <para>
			 The default for this is <literal>15</literal>.
		     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-thresholds</option> <replaceable>valueList</replaceable></term>
                  <listitem>
                     <para>
                        Supplies the per channel thresholds for the adc.
                        Channels which convert below their threshold are suppressed
                        from the data stream reducing both data volume and
                        dead-time.  The <parameter>valueList</parameter> is a
                        32 element Tcl  list of the integer thresholds.
                     </para>
                     <para>
                        Note that at the time I'm typing this, channel thresholds
                        have not yet been implemented in the firmware.
                        The firmware I bring with me at installation time
                        will hopefully implement this feature.
                     </para>
		     <para>
			 By default this is a 32 element list containing all
			 <literal>0</literal>.
		     </para>
                  </listitem>
                </varlistentry>
		  <varlistentry>
            <term><option>-nimbusy</option> <replaceable>busyselecst</replaceable></term>
            <listitem>
                <para>
				This option selects which signal is presented at the
				NIM busy output connector.  Note that this can interact with
				the mxdcrcbus driver.  See more below. 
                </para>
			 <para>
				Legal values for this parameter are:
			 </para>
			 <variablelist>
				<varlistentry>
					<term><literal>busy</literal></term>
					<listitem>
					    <para>
							The default.  The output reflects the module
							busy. Busy is asserted when the module is converting
							as a result of a gate or when the module's buffer
							is full. 
					    </para>
					    <para>
						For single event mode, full means that the event most
						recently converted has not yet been read out.  For
						multi event mode, this means that there is not
						sufficient buffer space for a maximally sized next
						event.
					    </para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>
						<literal>gate0</literal>
					</term>
					<listitem>
					    <para>
						The Gate0 signal.  Note that if the internal gate
						and delay generator is in use, this will reflect
						the output of that gate generator.  This allows
						you to see if the delay and width parameters of
						the gate generator is properly set.
					    </para>
					</listitem>
				</varlistentry>
				<varlistentry>
                    <term>
					<literal>gate1</literal>
				</term>
                    <listitem>
                        <para>
					The Gate1 signal.  Again if the gate generator is
					enabled, you can use this to monitor the gate signal
					<emphasis>after</emphasis> it has been modified
					by the gate and delay generator.
                        </para>
                    </listitem>
                </varlistentry>
				<varlistentry>
                    <term><literal>cbus</literal></term>
                    <listitem>
                        <para>
					The Busy output is used as a CBus master.  See
					the <literal>IMPORTANT NOTE</literal> below.
                        </para>
                    </listitem>
                </varlistentry>
			 </variablelist>
			 <note>
				<title>IMPORTANT NOTE:</title>
				<para>
					If this module is being used as the master for the CBus
					in a mxdcrcbus slow control module, this <emphasis>must</emphasis>
					be set to <literal>cbus</literal>.  Otherwise once the first
					run starts, you will no longer be able to perform
					control operations over Cbus connected moduls
				</para>
			 </note>
            </listitem>
          </varlistentry>
	       <varlistentry>
                  <term><option>-multievent</option> <replaceable>boolean</replaceable></term>
                  <listitem>
                    <para>
                      Allows the module to be used in multi-event mode.
                      This is normally done in conjunction with the
                      <command>madcchain</command> configuration command.
                      It also usually requires a custom SpecTcl version
                      to handle the data from this device.
                    </para>
                    <para>
                      the default value for this parameter is
                      <literal>false</literal> which runs the module in
                      single event mode.
                    </para>
		    <para>
			 This is <literal>false</literal> by default.
		    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term><option>-irqthreshold</option> <replaceable>integer</replaceable></term>
                  <listitem>
                    <para>
                      Sets the interrupt threshold.  When a number of
                      complete events have put at least this number of
                      longwords in the fifo, if interupts are enabled,
                      the module will interrupt.
                    </para>
		    <para>
			 This is <literal>0</literal> by default.
		    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term><option>-resolution</option> <replaceable>2k|4k|4khires|8k|8khires</replaceable></term>
                  <listitem>
                    <para>
                      Sets the resolution of the module.  This has an impact on
                      the conversion time. 
                    </para>
		    <para>
			 This defaults to <literal>8k</literal>
		    </para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </refsect1>

            <refsect1>
              <title>EXAMPLES</title>
              <example>
                <title>Sample use of madc command</title>
                <programlisting>
set madcTimeDivisor 14

madc create adc -base 0x40000000 -id 5 -ipl 0             <co id="madccreate" />
madc config adc -gatemode common -gategenerator disabled
madc config adc -inputrange 8v
madc config adc -timestamp on -timingsource vme -timingdivisor $madcTimeDivisor  <co id="madcsubst" />

for {set i 0} {$i &lt; 32} {incr i} {
    lappend thresholds 0                                 <co id="madcmakethresh" />
}
madc config adc -thresholds $thresholds                  <co id="madcthresholds" />

                </programlisting>
              </example>
              <calloutlist>
                <callout arearefs="madccreate">
                  <para>
                    This command creates an object to manage an MADC 32
                    whose base address is <literal>0x40000000</literal>.
                    The module will be referred to by the symbolic name:
                    <literal>adc</literal>
                  </para>
                </callout>
                <callout arearefs="madcsubst">
                  <para>
                    This line illustrates substitution of a Tcl variable for
                    a parameter value.  Tcl variable substition is textual,
                    so you can also use varibles to hold option names, though
                    that may be  a bit odd.
                  </para>
                </callout>
                <callout arearefs="madcmakethresh">
                  <para>
                    This highlights the fact that the configuration file is
                    really a configuration program.  The loop creates a
                    varaiable named <varname>thresholds</varname> that
                    contains a list of 32 zeroes.  This list will be used
                    to program the <literal>adc</literal> thresholds.
                    Normally these values will neither be zero nor uniform
                    from channel to channel.  It may be best to read them from
                    some external file.
                  </para>
                </callout>
                <callout arearefs="madcthresholds" >
                  <para>
                    This command uses the <varname>thresholds</varname> variable
                    and programs the channel thresholds of the ADC.
                  </para>
                </callout>
              </calloutlist>
            </refsect1>

          </refentry>

          <refentry id="vmusb3_mtdc">
            <refentryinfo>
              <author>
                <personname>
                  <firstname>Ron</firstname>
                  <surname>Fox</surname>
                </personname>
		<personblurb><para></para></personblurb>
              </author>
              <productname>NSCLDAQ</productname>
              <productnumber></productnumber>
            </refentryinfo>
            <refmeta>
              <refentrytitle>mtdc</refentrytitle>
              <manvolnum>3vmusb</manvolnum>
              <refmiscinfo class='empty'></refmiscinfo>
            </refmeta>
            <refnamediv>
              <refname>mtdc</refname>
              <refpurpose>Mesytec 32/34 channel TDC</refpurpose>
            </refnamediv>

            <refsynopsisdiv>
              <cmdsynopsis>
                <command>
                  mtdc create <replaceable>name ?options...?</replaceable>
                </command>
              </cmdsynopsis>
              <cmdsynopsis>
                <command>
              mtdc config <replaceable>name option value ?...?</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
              mtdc cget <replaceable>name</replaceable>
            </command>
          </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
          <title>DESCRIPTION</title>
          <para>
            The MTDC32 is a multi hit time digitizer from Mesytec.
            It has two fundamentally different modes of operation;
            <firstterm>trigger matching</firstterm> and
            <firstterm>timestamping</firstterm>
          </para>
          <para>
            In trigger matching mode you establish a time window
            relative to gate inputs.  Hits which occur during that
            time window are accepted and the hit time relative to
            the gate is returned for each hit.  By placing the
            time window correcty it is possible to use this
            mode to simulate a common start or common stop
            TDC. The module can run as two separate 16 channel
            logical modules or as a single 32 channel module.
          </para>
          <para>
            In timestamping mode, all hits are digitized and their
            times relative to the most recent time clear are
            returned.  In timestamping mode, the gate inputs are
            simply another pair of inputs making the module a
            34 channel module when used for timestamping.
          </para>
          <para>
            The module is very flexible and setup can be complex so it is
            important that you understand the MTDC32 manual when reading
            this documentation.
          </para>
          <para>
            The <command>mtdc</command> command is a typical VM-USB
            device support command.  It provides a
            <command>create</command> sub-command for generating module
            instances, a <command>config</command> sub-command for
            configuring module instances and a <command>cget</command>
            subcommand for introspecting the configuration of a module
            instance.
          </para>
        </refsect1>
        <refsect1>
          <title>
            OPTIONS
          </title>
          <variablelist>
            <varlistentry>
              <term><option>-base</option> <parameter>base-address</parameter></term>
              <listitem>
                <para>
                  Supplies the modules VME base address.
                  The <parameter>base-address</parameter>
                  value must match the base address as set in the
                  module rotary switches.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-id</option> <parameter>module-id</parameter></term>
              <listitem>
                <para>
                  Defines the module's id.  This value appears
                  in the id field of the data returned by the device.
                  The <option>-id</option> value is 8 bits wide
                  and therefore can be an unsigned value between
                  <literal>0</literal> and <literal>255</literal>.
                </para>
		<para>
		    This defaults to <literal>0</literal>.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-ipl</option> <parameter>priority-level</parameter></term>
              <listitem>
                <para>
                  Sets the interrupt priority level for interrupt
                  requests from this module.  The <option>-ipl</option>
                  value can be between <literal>0</literal>
                  and <literal>7</literal>.  A value of
                  <literal>0</literal> disables interrupts.
                </para>
		<para>
		    The default value is <literal>0</literal>
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-vector</option> <parameter>status-id</parameter></term>
              <listitem>
                <para>
                  Provides the VME status id put on the bus
                  when the module generates an interrupt.
                  The MTDC issues an 8 bit status id.
                  Therefore this value can be between
                  <literal>0</literal> and
                  <literal>255</literal>.  It defaults to <literal>0</literal>
                </para>
		<para>
		    Note that while the MTDC32 produces an 8 bit vector, the
		    VMUSB reads a 16 bit vector.  The VME standard is
		    ambiguous about how the top 8 bits are set.  The
		    MTDC sets these unused bits to 1.  Therefore
		    a <option>-vector</option> <literal>0x80</literal>
		    will produce a vector as seen by the VMUSB of
		    <literal>0xff80</literal>.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-irqthreshold</option> <parameter>word-count</parameter></term>
              <listitem>
                <para>
                  Determines the minimum number of 32 bit words the
                  module  must have buffered before it interrupts.
                  When an event has been buffered, if the number of
                  words in the module FIFO is larger than the
                  <option>-irqthreshold</option> value,
                  an interrupt will be requested if enabled.
                </para>
                <para>
                  The FIFO is 32K 32 bit words long so this
                  value can be between
                  <literal>0</literal> and <literal>0x7fff</literal> and
		  defaults to <literal>1</literal> which is suitable for single
		  event mode.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-maxtransfers</option> <literal>word-count</literal></term>
              <listitem>
                <para>
                  When the module is in multi-event mode 3, this sets
                  a soft limit on the number of 32 bit words
                  that can be transferred from the module before
                  it issues a <literal>BERR</literal>.
                  The limit is soft in that complete events are
                  always transferred.
                </para>
		<para>
		    This defaults to <literal>1</literal>
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-datalen</option> <parameter>length-spec</parameter></term>
              <listitem>
                <para>
                  Determins how the event is padded for alignment.
                  while the values <literal>8</literal>,
                  <literal>16</literal>, <literal>32</literal>
                  and <literal>64</literal> are all legal,
                  in pratice since the events are multiples
                  of 32 bit words, only the latter
                  two values are meaningful.  If the value
                  <literal>64</literal> is chosen then if
                  necessary 32 bit words containing
                  <literal>0xffff</literal> are added
                  to the event data to pad it out to the
                  next 64 bit boundary.
                </para>
		<para>
		    Defaults value for this parameter is <literal>32</literal>
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multievent</option> <parameter>on |off |limited</parameter></term>
              <listitem>
                <para>
                  Enables or disables multi-event mode.
                  If <literal>limited</literal> is used, the
                  <option>-datalen</option> specification is used
                  as well.
                </para>
		<para>
		    This defaults to <literal>off</literal>
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-skipberr</option> <parameter>on | off|</parameter></term>
              <listitem>
                <para>
                  If true then at the end of the read rather
                  than asserting <literal>BUSERR</literal>
                  return data with the top two bits set to
                  <literal>10</literal> indicating an end of
                  buffer.
                </para>
		<para>
		    By default, this is <literal>false</literal>
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-countevents</option> <parameter>yes | no</parameter></term>
              <listitem>
                <para>
                  If true, then the <option>-maxtransfers</option>
                  value is taken to be the number of events rather
                  than the number of words.
                </para>
		<para>
		    By default this is <literal>false</literal>.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-marktype</option> <parameter>timestamp | eventcount | extended-timestamp</parameter></term>
              <listitem>
                <para>
                  Determines what the value in the event correlation
                  field of the data means.  
                </para>
		<para>
		    By default, this is <literal>timestamp</literal>
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-joinedbanks</option> <parameter>yes |no</parameter></term>
              <listitem>
                <para>
                  Only relevant in trigger matching mode when this determines if
                  the gates are ored in to both banks (<literal>yes</literal>
                  or if they affect individual banks
                  of 16 channels (<literal>no</literal>).  This defaults to
		  <literal>true</literal>.  
                </para>
		<para>
		    Note that in split bank mode, the module acts and supplies
		    data like two independent modules.  Thus a single VMUSB
		    trigger may result in two packets of data from this module
		    in trigger matching mode.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-resolution</option> <parameter>resolution-value</parameter></term>
              <listitem>
                <para>
                  Sets the TDC resolution.  This is only relevant in
                  trigger matching modes as the timestamping mode
                  resolution is always 3.9ps.
                  Allowed values are
                  <literal>500ps 250ps 125ps 62.5ps 31.3ps 15.6ps 7.8ps</literal>
                  and <literal>3.9ps</literal>.
                </para>
		<para>This defaults to <literal>3.9ps</literal></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-format</option> <parameter>standard |fulltime</parameter></term>
              <listitem>
                <para>
                  Determines if the data are time differences from the
                  gate (trigger matching mode) or full timestamps
                  (timestamping mode).
                </para>
		<para>
		    Defaults to <literal>standard</literal>
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-bank0winstart</option> <parameter>ns</parameter></term>
              <term><option>-bank1winstart</option> <parameter>ns</parameter></term>
              <listitem>
                <para>
                  Determines when the matching window for trigger matching
                  mode starts relative to the gate.  <option>-bank1winstart</option>
                  is only relevant with the <option>-joinedbanks</option> is
                  false.  This value is a number between <literal>0</literal>
                  and <literal>32767</literal> where the vaslue
                  <literal>16384</literal> means the window starts with the
                  gate, larger values delay the start and smaller
                  values start the
                  matching window prior to the gate.
                </para>
		<para>
		    These both default to <literal>16*1024-16</literal>.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-bank0winwidth</option> <parameter>width</parameter></term>
              <term><option>-bank1winwidth</option> <parameter>width</parameter></term>
              <listitem>
                <para>
                  Determines the width of the trigger matching
                  window.  The <parameter>width</parameter>
                  value is in nanoseconds and can be
                  <literal>0</literal> through
                  <literal>16383</literal>, giving a range of
                  16 microseconds.
                </para>
                <para>
                  <option>-bank1winwidth</option> is only meaningful
                  if the
                  <option>-joinedbanks</option> is disabled.
                </para>
		<para>
		    These both default to <literal>32</literal>.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-bank0triggersource</option> <parameter>trigger-spec</parameter></term>
              <term><option>-bank1triggersource</option> <parameter>trigger-spec</parameter></term>
              <listitem>
                <para>
                  The actual triggering of the module is quite flexible.
                  These options allow you to specify how the module is triggered.
                  <option>-bank1triggersource</option> is only
                  meaningful if <option>-joinedbanks</option> is
                  off.
                </para>
                <para>
                  The valid values for the <parameter>trigger-spec</parameter>
                  are:
                </para>
                <variablelist>
                  <varlistentry>
                    <term><literal>Tr0</literal></term>
                    <listitem>
                      <para>
                        The bank is triggered on the Gate 0 input.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>Tr1</literal></term>
                    <listitem>
                      <para>
                        The bank is triggered on the Gate 1 input.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>Ch0</literal> ... <literal>Ch31</literal></term>
                    <listitem>
                      <para>
                        The specified channel is the trigger for the bank.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>Bank0</literal></term>
                    <listitem>
                      <para>
                        A hit in any channel of Bank 0 is the trigger for
                        the bank.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>Bank1</literal></term>
                    <listitem>
                      <para>
                        A hit in any channel of Bank 1 is a trigger
                        for the bank.
                      </para>
                    </listitem>
                  </varlistentry>

                </variablelist>
		<para>
		    The default for <option>-bank0triggerrsource</option>
		    is <literal>Tr0</literal>, the trigger 0 input.  The default
		    for <option>-bank1triggersource</option> is
		    <literal>Tr1</literal>.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-bank0firsthit</option> <parameter>boolean</parameter></term>
              <term><option>-bank1firsthit</option> <parameter>boolean</parameter></term>
              <listitem>
                <para>
                  If true, only the first hit from the bank
                  is
                  transmitted.  Otherwise all hits in the
                  bank's trigger matching window are
                  transmitted.
                </para>
		<para>
		    This defaults to <literal>false</literal> allowing multiple
		    hits from both banks of the module.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-edge</option> <parameter>rising | falling</parameter></term>
              <listitem>
                <para>
                  Determines which signal edge is timed.  This defaults to
		  <literal>falling</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-tr0terminated</option> <parameter>boolean</parameter></term>
              <term><option>-tr1terminated</option> <parameter>boolean</parameter></term>
              <listitem>
                <para>
                  If this parameter is true, the ECL Trn input is
                  terminated by the module.  If not that
                  input is unterminated.
                </para>
		<para>
		    These parameters defaul to <literal>false</literal> which allow
		    the trigger inputs to be bussed to other ECL inputs.
		    The input at the end of the bus <emphasis>must</emphasis>
		    be terminated however.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-resetterminated</option> <parameter>boolean</parameter></term>
              <listitem>
                <para>
                  If true, the ECL reset input is terminated
                  otherwise it is unterminated.   This defaults to
		  <literal>false</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-ecltrig1isoscillator</option> <parameter>boolean</parameter></term>
              <listitem>
                <para>
                  If true then the ECL trig1 input is treated
                  as an oscillator that is suitable for
                  incrementing the timestamp.  Note that you must also set the
                  <option>-timingsource</option> option properly as
                  well to actually ulse this input as the
                  timestamp clock.
                </para>
		<para>
		    Thuis defaults to <literal>false</literal>.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-trigfromecl</option> <option>boolean</option></term>
              <listitem>
                <para>
                  If true, the trigger comes from the ECL inputs,
                  otherwise it comes from the NIM inputs.  This
                  is an exclusive setting (see register
                  <literal>0x6068</literal> documentation e.g.)
                </para>
		<para>
		    Defaults to <literal>false</literal> so that by default the
		    trigger inputs are the NIM inputs.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-nimtrig1isoscillator</option> <option>boolean</option></term>
              <listitem>
                <para>
                  The nim TRIG1 input can be used to supply
                  a clock pulse train for the timestamp.
                  See <option>-timingsource</option> which must
                  be set properly as well.
                </para>
		<para>
		    This is <literal>false</literal> by default.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-busy</option> <parameter>bothbanks | cbusoutput | abovethreshold</parameter></term>
              <listitem>
                <para>
                  Describes the function of the busy output:
                </para>
                <variablelist>
                  <varlistentry>
                    <term><literal>bothbanks</literal></term>
                    <listitem>
                      <para>
                        The busy is set when FIFO is full or
                        acquisition is halted (the module
                        cannot accept a busy).
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>cbusoutput</literal></term>
                    <listitem>
                      <para>
                        The busy output is used to run
                        a CBUS control bus.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>abovethreshold</literal></term>
                    <listitem>
                      <para>
                        The busy output indicates the
                        FIFO is occupied above the
                        <option>-irqthreshold</option>
                        value.
                      </para>
                    </listitem>
                  </varlistentry>

                </variablelist>
	  	    <para>
		      The default for this paramter is
		      <literal>bothbanks</literal>.
		    </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-pulseron</option> <parameter>boolean</parameter></term>
              <listitem>
                <para>
                  If true, the test pulser is active.  This is
		  <literal>false</literal> by default.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-pulserpattern</option> <parameter>bitmask</parameter></term>
              <listitem>
                <para>
                  Sets the pulser pattern, which determines
                  which channels are
                  pulsed.  This is <literal>0</literal> by default.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-bank0threshold</option> <parameter>level</parameter></term>
              <term><option>-bank1threshold</option> <parameter>level</parameter></term>
              <listitem>
                <para>
                  When the modue is jumpered for
                  unipolar inputs, this value determines
                  the threshold used to determine when a
                  signal has happened on the inputs to bankn.
                  If you are doing this
                  <emphasis>read the manual carefully</emphasis>
                </para>
		<para>
		    This defaults to <literal>105</literal> which the manual
		    says is suitable for a NIM input.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-timingsource</option> <parameter>vme | external</parameter></term>
              <listitem>
                <para>
                  Determines the timing source for the
                  timestamp clock.  If <literal>vme</literal>
                  the 16Mhz backplane clock specified
                  by the VME standard is used.  If
                  <parameter>external</parameter>,
                  You must have configured one of
                  <option>-ecltrig1isoscillator</option>
                  or <option>-nimtrig1isoscillator</option>
                  to be true in which case the associated
                  input is used as the source for the
                  timestamp clock.
                </para>
		<para>
		    This defaults to <literal>vme</literal> which is suitable
		    for synchronizing timing across a single VME backplane when
		    used with the <command>madcchain</command> which will
		    use multicast addressing to simultaneously clear the
		    timestamps of all participating modules.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-tsdivisor</option> <parameter>divisor</parameter></term>
              <listitem>
                <para>
                  Sets the scaledown of the timestamp
                  clock input. This is a 16 bit value and
                  the value 0 means division by
                  <literal>65536</literal>.
                </para>
		<para>
		    The default value is <literal>1</literal> which does not
		    scale down the timestamp clock.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multlow0</option> <parameter>0-255</parameter></term>
              <listitem>
                <para>
                  The bank0 number of channels that must be
                  present to define an event (note that
                  if <option>-joinedbanks</option> is true
                  this multiplicity is over both banks).
                </para>
		<para>Defaults to <literal>0</literal></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multhi0</option> <parameter>0-255</parameter></term>
              <listitem>
                <para>
                  The largest number of channels that must
                  be
                  present to define an event for bank0
                  or both banks if <option>-joinedbanks</option>
                  is true.
                </para>
		<para>Defaults to <literal>255</literal></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multlow1</option> <parameter>0-255</parameter></term>
              <listitem>
                <para>
                  If banks are not joined the low multiplicity
                  required for an event from bank 1.  Defaults to
		  <literal>0</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multhi1</option> <parameter>0-255</parameter></term>
              <listitem>
                <para>
                  If banks are not joined, the high multiplicity
                  allowed for an event from bank1.  Defaults to
		  <literal>255</literal>
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </refsect1>
      </refentry>

      <refentry id="vmusb3-mqdc">
	    <refentryinfo>
	      <author>
		  <personname>
		      <firstname>Jeromy</firstname>
		      <surname>Tompkins</surname>
		  </personname>
		  <personblurb><para></para></personblurb>
	      </author>
	      <productname>NSCLDAQ</productname>
	      <productnumber></productnumber>
	    </refentryinfo>
	  
        <refmeta>
          <refentrytitle>mqdc</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
          <refmiscinfo class="empty"></refmiscinfo>
        </refmeta>

        <refnamediv>
          <refname>mqdc</refname>
          <refpurpose>Support Mesytec MQDC-32 modules</refpurpose>
        </refnamediv>

        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
mqdc create <replaceable>name</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
mqdc config <replaceable>name ?options</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
mqdc cget <replaceable>name</replaceable>
            </command>
          </cmdsynopsis>
        </refsynopsisdiv>

        <refsect1>
          <title>DESCRIPTION</title>
          <para>
            The <command>mqdc</command> command provides scripted support
            for the Mesytec 32 channel charge-to-digital converter.
          </para>
          <para>
            As with all VM-USB module support commands, <command>mqdc</command>
            is a command ensemble with subcommands that
            <command>create</command> and
            <command>config</command>ure modules as well as
            <command>cget</command>, which introspects a module configuration.
          </para>
          <para>
            <command>create</command> creates an object with the specified
            <parameter>name</parameter>. Additional options are treated like
            configuration options.  <command>config</command> configures
            an existing module, and <command>cget</command> returns a list of
            configuration name/value pairs that describe the configuration of
            the module.
          </para>
          <para>
            It is important to note that the module configuration does not
            actually get loaded until the run is initialized.  The order in
            which configuration parameters are supplied is therefore unimportant.
            Think of the configuration options as being accumulated and then
            applied as the run starts.  Only modules that are registered to a 
            <command>stack</command> are configured. 
          </para>
          <para>
            The configurable options are given names and reasonable defaults
            for the purpose of reducing the learning curve for using the device.
            However, in order to address the considerable number of use cases 
            that this driver will be used in, the decision was made to support
            flexibility at the cost of some complexity. To create a specific 
            behavior, it is sometimes necessary to configure multiple options.
            For this reason, correlated options to the option be described are 
            listed for cross reference. Furthermore, two examples are provided
            in the EXAMPLES section to demonstrate common configurations.
          </para>
        </refsect1>

        <refsect1>
          <title>
            OPTIONS
          </title>
          <para>
            In contrast to some of the other Mesytec digitizer drivers provided
            by NSCLDAQ,
            this driver does not initiate a soft reset at the beginning of every
            run. This is so that timestamps have the option of not clearing between
            runs, which is a behavior that some experiments have required.
            If you would like to soft reset the device, see the slow controls module
            <command>mxdcsoftreset</command>. When used, this module will cause
            a soft reset at the startup of the VMUSBReadout program and then on-demand
            via the <command>init</command> command any time thereafter.
          </para>
          <variablelist>
            <varlistentry>
              <term><option>-base</option> <replaceable>address</replaceable></term>
              <listitem>
                <para>
                  <parameter>address</parameter> must be the module base
                  address as configured in its rotary switches.
                  This base address is used to access the module's register
                  and event memory.
                </para>
                <para>
                  Each module must be programmed and hardware configured
                  with a different base address. The address used will be
                  an A32 VME address.
                </para>
                <para>
                  By default, the value is <literal>0</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-id</option> <replaceable>vsn</replaceable></term>
              <listitem>
                <para>
                  <parameter>vsn</parameter> will be used as the module's
                  identifier or <firstterm>virtual slot number</firstterm>.
                  The <parameter>vsn</parameter> will be encoded into the
                  event data that is returned by the module.  This, in turn
                  is normally used by event decoders to determine which parameters
                  the channels of the module should be unpacked into.
                </para>
                <para>
                  Each module should be given a unique <parameter>vsn</parameter>.
                </para>
                <para>
                  By default, the value is <literal>0</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-timestamp</option>  <replaceable>onoff</replaceable></term>
              <listitem>
                <para>
                  This option controls whether or not the
                  module tags each event with a trigger number (event count) or with a
                  timestamp (see also the
                  <option>-timingsource</option>,
                  <option>-timingdivisor</option>,
                  <option>-nimtiming</option>,
                  <option>-ecltiming</option>, and 
                  <option>-syncmode</option> options).
                </para>
                <para>
                  The <replaceable>onoff</replaceable> is a boolean value.
                  If true, the module tags events with a 46-bit timestamp. Otherwise,
                  a 32-bit trigger number number is used. The upper 16 bits of the 46-bit 
                  timestamp are encoded into the extended timestamp packet that is outputted before
                  the end of event word.
                </para>
                <para>By default, this is <literal>false</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-usethresholds</option> <replaceable>onoff</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>onoff</replaceable> sets whether the thresholds will be
                  used or not. The effect is the same as providing a list of 32 zeroes to the
                  <option>-thresholds</option> option.
                </para>
                <para>By default, the value is <literal>true</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-thresholds</option> <replaceable>valueList</replaceable></term>
              <listitem>
                <para>
                  Supplies the per channel thresholds for the adc.
                  Channels which convert below their threshold are suppressed
                  from the data stream reducing both data volume and
                  dead-time.  The <parameter>valueList</parameter> is a
                  32 element Tcl  list of the integer thresholds.
                </para>
                <para>
                  The user can supply an 8-bit threshold for each channel. Note that
                  there zero threshold value disables the threshold for the associated channel.
                  To disable all usage of thresholds, the user can either provide a 
                  TCL list containing all zero values or make use of the <option>-usethresholds</option>
                  option.
                </para>
                <para>By default, all values in the list are <literal>0</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-ipl</option> <replaceable>irqlevel</replaceable></term>
              <listitem>
                <para>
                  If the module will be used to trigger an interrupt driven
                  stack, the <parameter>irqlevel</parameter> parameter must
                  be programmed to a valid non zero interrupt priority level
                  (<literal>1</literal> through <literal>7</literal>).
                  This must match the interrupt priority level used to trigger
                  the stack.
                </para>
                <para>
                  The default value of <literal>0</literal> disables module
                  interrupts.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-vector</option> <replaceable>statusId</replaceable></term>
              <listitem>
                <para>
                  If the module will be used to trigger an interrupt driven
                  stack, the <parameter>statusId</parameter> must be programmed
                  to a non zero 8-bit status id, or <firstterm>vector</firstterm>
                  (between <literal>1</literal> and <literal>255</literal>).
                </para>
                <para>
                  The value used must match the value of the
                  <option>-vector</option> configuration parameter used to
                  trigger the stack.
                </para>
                <para>
                  The default value is <literal>1</literal>.
                </para>
		<para>
		    Note that while the MQDC has an 8 bit statusID, the
		    VMUSB does a 16 bit transfer to read it when an interrupt
		    occurs.   The VME standard is ambiguous about what the
		    top bits of the statusID will be as seen by the
		    VMUSB.  The MQDC sets those unused bits to 1.  Therefore,
		    a <option>-vector</option> <literal>0x80</literal>
		    in an MQDC will produce a statusID of <literal>0xff80</literal>
		    as seen by the VMUSB.
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-irqthreshold</option> <replaceable>integer</replaceable></term>
              <listitem>
                <para>
                  Sets the interrupt threshold.  If interrupts are enabled, the module
                  will interrupt when the buffer contains at least this number of longwords.
                </para>
                <para>
                  The "max transfer data" (register at 0x601a) described in the MQDC-32 
                  manual is always the same as the value provided to this option.
                </para>
                <para>
                  The default value is <literal>1</literal>.
                </para>
                <para>
                  Be aware that the value provided will be overridden if <option>-multievent</option> is
                  set to <literal>off</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multievent</option> <replaceable>off | on | limited</replaceable></term>
              <listitem>
                <para>
		  Configures the device for multievent mode. The valid values are <literal>off</literal>,
		  <literal>on</literal>, and <literal>limited</literal>. When the value is <literal>off</literal>,
                  then the device is a purely single event mode. There is no buffering that occurs within the
                  device and no new gates are accepted until the device is read out (we reset the device when we read).
                  When the value is <literal>on</literal>, the device will transfer an unlimited amount of data with
                  each read. This driver is written so that each read will attempt to transfer 1024 words. 
                  Finally, if the value is <literal>limited</literal>, then the device will buffer events and then
                  read out an amount determined by the <option>-maxtransfers</option> option.
                  The default value for this parameter is <literal>off</literal>.                
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-countevents</option> <parameter>on | off</parameter></term>
              <listitem>
                <para>
                  If the value passed to this parameter is <literal>on</literal>, then the <option>-maxtransfers</option>
                  value is taken to be the number of events rather
                  than the number of words. If you inspect the manual, this controls the 
                  "count events" bit in the multievent mode register. Note that this
                  only affects the output when the <option>-multievent</option> parameter
                  is set to <literal>limited</literal>. The default value is <literal>no</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-skipberr</option> <parameter>yes | no</parameter></term>
              <listitem>
                <para>
                  If true, then an "end of buffer" is sent instead of a BERR (0xffffffff) when the 
                  reached and <option>-multievent</option>
                  is set to <literal>limited</literal>. This controls the "Emit EOE" bit in the
                  multievent register (see MQDC-32 manual). The default value is <literal>no</literal>.
                </para>
              </listitem>
            </varlistentry> 
            <varlistentry>
              <term><option>-maxtransfers</option> <parameter>integer</parameter></term>
	      <listitem>
                <para>
                  This is a soft threshold for the number of words that can be transferred in a single
                  read when the <option>-multievent</option> parameter is set to <literal>limited</literal>. The number of words 
	          transferred is the least number of words beyond the value set to complete an event. This is
                  only a meaningful parameter if the <option>-multievent</option> parameter is set to <literal>limited</literal>.
                  The default value is <literal>1</literal>.
                </para>
              </listitem>
	    </varlistentry>
	    
            <varlistentry>
              <term><option>-bankoffsets</option> <replaceable>intlist</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>intlist</replaceable> must be a two element TCL list whose
                  entries are interpreted as the bank 0 and bank 1 offsets, in that order. The 
                  values can be in the range [0,255] independently and effectively shift the 
                  spectrum by about 2000 channels.
                </para>
                <para>
                  The default value is <literal>128</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-gatemode</option>  <replaceable>mode</replaceable></term>
              <listitem>
                <para>
                  The MQDC32 has a pair of gate inputs.  The <replaceable>mode</replaceable>
                  can be either <literal>separate</literal> or <literal>common</literal>.
                </para>
                <para>
                  If set to <literal>separate</literal>, two separate gates are to be 
                  provided for each bank of inputs. One must go into gate 0 input and the 
                  other into the gate 1 input. If on the other hand, the option is set
                  to <literal>common</literal>, the gate 0 input will be used gate all 
                  32 channels.
                </para>
                <para>
                  The default setting is <literal>common</literal>.
                </para>
                <para>
                  Note that this value will modify the effect of some other
                  options such as <option>-multlowerlimits</option> and 
                  <option>-multupperlimits</option>,
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-gatelimits</option> <replaceable>intlist</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>intlist</replaceable> must be a two element TCL list
                  that contains integer elements in the range [0,255]. The manual provides
                  a coarse table describing the nonlinear mapping. 
                  It maps the values 0 to 254 to an integration 
                  width range between 4 and 300 ns. If the value is 255, the gate limit is
                  considered infinite such that the physical gate provided as input is 
                  used without any width limit. 
                </para>
                <para>
                  The default value is <literal>255</literal>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-exptrigdelays</option> <replaceable>intlist</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>intlist</replaceable> must be a two element TCL list
                  that contains integer elements each in the range [0,16383]. The range maps to
                  a range of delay from 0 ns to 16384 ns.
                </para>
                <para>
                  The default value is <literal>0</literal>.
                </para>
              </listitem>
            </varlistentry>
    
            <varlistentry>
              <term><option>-inputcoupling0</option> <replaceable>type</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>type</replaceable> determines whether or not the signal inputs
                  for bank 0 are AC or DC couplied. The accepted values for the option are
                  <literal>AC</literal> and <literal>DC</literal>.
                </para>
                <para>
                  The default value is <literal>AC</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-inputcoupling1</option> <replaceable>type</replaceable></term>
              <listitem>
                <para>
                  This has the exact same semantics as the <option>-inputcoupling0</option> option 
                  except that it applies to the bank 1 signal inputs.
                </para>
                <para>
                  The default value is <literal>AC</literal>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-pulser</option> <replaceable>onoff</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>onoff</replaceable> specifies whether the internal test
                  pulser will be turned on or off. It must be a valid boolean value. 
                </para>
                <para>
                  If the test pulser is enabled, the amplitude of the pulser is determined
                  by the value of the <option>-pulseramp</option> option. The pulser is not described
                  in detail in the manual. What happens at the time of writing is that when the 
                  pulser is enabled, an internally generated gate is used to integrate any input
                  signal. This will be uncorrelated to any pulses so the integrator will 
                  in general integrate the baseline noise. The pulser amplitude is added to this integrated
                  value. The result is that if no physical signal inputs are provided, the pulser peak will
                  be quite sharp. On the other hand, if any input signals are connected, the pulser 
                  peak will be smeared out by the variations in the baseline integration. HOWEVER!
                  What was just described only applies when no cable is attached to the individual
                  gate inputs. If the individual gates are potentially being provided 
                  (determined by the presence of a cable), the pulser is rendered ineffective!
                </para>
                <para>
                  The default value is <literal>false</literal>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-pulseramp</option> <replaceable>value</replaceable></term> 
              <listitem>
                <para>
                  The integer value provided for <replaceable>value</replaceable> is to be
                  used for the pulser amplitude. The value must be in the range [0,255].
                </para>
                <para>
                  The default value <literal>32</literal>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-ecltermination</option> <replaceable>onoff</replaceable></term>
              <listitem>
                <para>
                  This parameter when true enables the ECL input termination.
                  If disabled, the termination is off.  If you are bussing
                  the ECL inputs, only the final module in the bus should
                  have terminatinon enabled, all other modules, should
                  have termination turned off.
                </para>
                <para>
                  The default value is <literal>true</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-ecltiming</option> <replaceable>onoff</replaceable></term>
              <listitem>
                <para>
                  When true, this parameter enables the gate1 ECL input to
                  to be used as a clock source for the timestamp. It also enables the
                  fast clear ECL input to be used as an external timestamp reset input. 
                  When false,
                  the ECL G1 input is an ECL gate1 and the ECL fast clear is a fast clear. 
                </para>
                <para>
                  In the case that it is used as a timestamp reset, the behavior is 
                  tightly coupled to the value of the <option>-resetlogic</option> option. 
                </para>
                <para>
                  The default value is false.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-nimtiming</option> <replaceable>onoff</replaceable></term>
              <listitem>
                <para>
                  If true, enables the NIM Gate1 input to be a clock source
                  for the timestamp and NIM faxt clear input to be used as a timestamp
                  reset.  If false, the NIM Gate1 input is a gate for bank 1 and the NIM 
                  fast clear input is a fast clear.
                </para>
                <para>
                  The actual behavior of
                  the reset depends on the value of the <option>-resetlogic</option>.
                </para>
                <para>
                  The default value is false.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-nimbusy</option> <replaceable>busyselect</replaceable></term>
              <listitem>
                <para>
                  This option selects which signal is presented at the
                  NIM busy output lemo connector.  By default, this will
                  be the module busy.  The <parameter>busyselect</parameter> can
                  be any of the following strings:
                </para>
                <variablelist>
                  <varlistentry>
                    <term><literal>busy</literal></term>
                    <listitem>
                      <para>The module busy is outputted.  This is the default.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>rcbus</literal></term>
                    <listitem>
                      <para>
                        This allows the device to be used as a proxy for the Mesytec RC-bus
                        protocol. The NIM busy output serves as the communication port. 
                        A slow-controls module,
                        <literal>mxdcrcbus</literal>, should be used to perform the
                        actual communication with devices.
                      </para>  
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>overthreshold</literal></term>
                    <listitem>
                      <para>
                        A gate will be outputted when the buffer contains more data words than 
                        are specified in the <option>-irqthreshold</option> value. This could 
                        in principle be used
                        as a signal indicating data is ready to be read out if not using an 
                        interrupt as a trigger.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>full</literal></term>
                    <listitem>
                      <para>
                        A gate will be outputted when the buffer is full of data.
                      </para>
                    </listitem>
                  </varlistentry>
                </variablelist>

              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-timingsource</option> <replaceable>sourceName</replaceable></term>
              <listitem>
                <para>
                  The value of <replaceable>sourceName</replaceable> specifies the 
                  source of the clock for timestamps.
                  If <literal>external</literal>, whichever of the NIM or
                  ECL GATE1 inputs are enabled is the clock source.
                  If <literal>vme</literal>, the VME 16Mhz backplane
                  clock is the clock.
                </para>
                <para>
                  If you use an <literal>external</literal> time
                  source,  it is very important that <option>-ecltiming</option>
                  and <option>-nimtiming</option> values are set in a manner that
                  matches your setup.
                </para>
                <para>
                  The default value is <literal>vme</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-timingdivisor</option> <replaceable>val</replaceable></term>
              <listitem>
                <para>
                  The <literal>val</literal> is a 16-bit integer that scales down the 
                  counter in use (event count or timestamp).
                </para>
                <para>
                  The default value is 1.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-resetlogic</option> <replaceable>mode</replaceable></term>
              <listitem>
                <para>
                  The effect of this option should not be confused with enabling or disabling
                  the ability to reset the internal counters (i.e. timestamp or trigger count). 
                  Rather it should be used to set some reset logic in the device. There are 
                  three accepted values that are described below. The default value is
                  <literal>begin_run</literal>.
                </para>
                <variablelist>
                  <varlistentry>
                    <term><literal>never</literal></term>
                    <listitem>
                      <para>
                        In this mode, the counters will never reset automatically between
                        runs. The only 
                        way they will reset is by an external reset input, if the devices inputs are 
                        configured to accept one (See <option>-nimtiming</option> and 
                        <option>-ecltiming</option>). In which case, there is no limit to 
                        the number of times a reset by an external signal can occur.
                      </para>
                      <para>
                        You could use this mode to establish hardware level timestamp 
                        synchronization if you have enabled the device for timestamping 
                        and also for using an external timing source. If doing so, it is
                        left to the user to make sure only one reset signal arrives during
                        the run.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>begin_run</literal></term> 
                    <listitem>
                      <para>
                        In this mode, the counters will reset during the intialization phase
                        of every run. If using a trigger count (aka. an event count), this is 
                        the preferred reset logic.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>extern_oneshot</literal></term>
                    <listitem>
                      <para>
                        In this mode, the counter will never reset automatically between runs
                        unless an external signal arrives to a reset input 
                        (See <option>-nimtiming</option> and <option>-ecltiming</option>).
                        In this respect the behavior is similar to the <literal>never</literal>
                        mode. The difference is that this only allows a single reset to occur
                        after the start of a run. What this does is arm the device to reset
                        on the rising edge of the first external reset input. After this first
                        input, the device will not reset until it is armed again during the 
                        initialization phase of the next run.
                      </para>
                      <para>
                        If the user has enabled the device for timestamping
                        and the timing source is external, this is the simplest way to
                        establish hardware level synchronization with other components in the 
                        system. In fact, it is recommended over use of the <literal>never</literal>
                        mode.
                      </para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-multlowerlimit0</option> <replaceable>val</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>val</replaceable> must be an integer in the range [0,32]. 
                  The effect of this option changes 
                  according to the value of the <option>-gatemode</option> option. In general,
                  this provides a lower multiplicity limit for accepting data. If the number
                  of channels with data for a single gate is greater than or equal to the lower
                  multiplicity limit, the data is added to the buffer. If that is not the case,
                  all data produced for that single gate is discarded.

                </para> 
                <para>
                  If <option>-gatemode</option> is set to <literal>common</literal>, then 
                  the value serves as the lower multiplicity limit for all 32 channels. 
                </para>
                <para>
                  If instead <option>-gatemode</option> is set to <literal>separate</literal>, 
                  it serves as the lower multiplicity limit for bank 0 channels
                  (channels 0 to 15).
                </para>
                <para>
                  The default value for this is 0.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-multlowerlimit1</option> <replaceable>val</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>val</replaceable> must be an integer in the range [0,16]. 
                  The effect of this option changes 
                  according to the value of the <option>-gatemode</option> option. 
                  If <option>-gatemode</option> is set to <literal>common</literal>, then 
                  the value is written to the device, but the device makes no use of it.
                  If instead <option>-gatemode</option> is set to <literal>separate</literal>, 
                  it serves as the lower multiplicity limit for bank 1 channels
                  (channels 16 to 31).
                </para>
                <para>
                  The default value for this is 0.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multupperlimit0</option> <replaceable>val</replaceable></term>
              <listitem>
                <para>
                  The requirements and meaning for this are the same as for the 
                  <option>-multlowerlimit0</option> option. The difference is that the 
                  <replaceable>val</replaceable> provided is an upper limit
                  instead of a lower limit. If the number of channels with data for a gate must
                  be less than or equal to the upper limit value provided to be accepted. The
                  valid range of values for <replaceable>val</replaceable> are [0,32].
                </para>
                <para>
                  The default value for this 32.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multupperlimit1</option> <replaceable>val</replaceable></term>
              <listitem>
                <para>
                  The requirements and meaning for this are the same as for the 
                  <option>-multlowerlimit1</option> option. The difference is that the 
                  <replaceable>val</replaceable> provided is an upper limit
                  instead of a lower limit. If the number of channels with data for a gate must
                  be less than or equal to the upper limit value provided to be accepted. The
                  valid range of values for <replaceable>val</replaceable> are [0,16].
                </para>
                <para>
                  The default value for this 16.
                </para>
              </listitem>
            </varlistentry>

          </variablelist>

        </refsect1>
        <refsect1>
          <title>EXAMPLES</title>
          <example>
            <title>Sample use of mqdc command for timestamping with external oscillator</title>
            <para>
              The following example configures the device for use in a system that 
              has single event readout logic. The user will initiate the data readout 
              by means of some logic external to the device. Furthermore the data must be timestamped for the 
              purpose of event building. The clock is provided on NIM G1 input and an external
              synchronization pulse is provided into the NIM Reset input. Furthermore, the
              device must scale down the clock count by 14.
            </para>
            <programlisting>
set madcTimeDivisor 10

mqdc create qdc -base 0x40000000 -id 5 -ipl 0             <co id="mqdccreate" />
mqdc config qdc -gatemode common
mqdc config qdc -nimtiming true
mqdc config qdc -timestamp on -timingsource external -timingdivisor $madcTimeDivisor 
mqdc config qdc -resetlogic extern_oneshot                <co id="mqdctiming"/>

set thresholds [list]
for {set i 0} {$i &lt; 32} {incr i} {
  lappend thresholds 0                                    <co id="mqdcmakethresh" />
}
mqdc config qdc -thresholds $thresholds                   <co id="mqdcthresholds" />
            </programlisting>
          </example>
          <calloutlist>
            <callout arearefs="mqdccreate">
              <para>
                This command creates an object to manage an MQDC-32
                whose base address is <literal>0x40000000</literal>.
                The module will be referred to by the symbolic name:
                <literal>qdc</literal>.
              </para>
            </callout>
            <callout arearefs="mqdctiming">
              <para>
                This line and the two above it set up the device to receive
                an external clock signal through the NIM inputs and then
                synchronize it via a signal at NIM FC. It also establishes
                that the sync reset will occur once after the run begins
                and that the number of clock cycles that arrive will be scaled
                down by a factor of 10 to produce the timestamp.
              </para>
            </callout>
            <callout arearefs="mqdcmakethresh">
              <para>
                This highlights the fact that the configuration file is
                really a configuration program.  The loop creates a
                variable named <varname>thresholds</varname> that
                contains a list of 32 zeroes.  This list will be used
                to program the <literal>qdc</literal> thresholds.
                Normally these values will neither be zero nor uniform
                from channel to channel.  It may be best to read them from
                some external file.
              </para>
            </callout>
            <callout arearefs="mqdcthresholds" >
              <para>
                This command uses the <varname>thresholds</varname> variable
                and programs the channel thresholds of the QDC.
              </para>
            </callout>
          </calloutlist>

          <example>
            <title>Sample configuration of mqdc for event counting and interrupt readout</title>
            <para>
              The following example will show how to use the device for readout triggered
              by an interrupt. It will also use an event count rather than a timestamp that
              resets between runs.  The readout will be single event mode.
            </para>
            <programlisting>
set thresholds [list]
for {set i 0} {$i &lt; 32} {incr i} {
  lappend thresholds 0                                   
}

mqdc create qdc -base 0x40000000 -ipl 1 -vector 0                   <co id="mqdcirqconfig"/>
mqdc config qdc -thresholds $thresholds

stack create evt
stack config evt -modules {qdc} -trigger interrupt -ipl 1 -vector 0 <co id="mqdcirqrdo"/>
            </programlisting>
          </example>
          <calloutlist>
            <callout arearefs="mqdcirqconfig">
              <para>
                This creates a new object to manage a QDC whose base address is 
                <literal>0x40000000</literal> that will generate an interrupt
                whenever an event occurs. The device's interrupt priority level will be
                1 and the vector it will respond to is 0.
              </para>
            </callout>
            <callout arearefs="mqdcirqrdo">
              <para>
                Here we set up a stack that is triggered by an interrupt with priority level 1. 
                It will then trigger readout of the qdc that we have enabled to respond via
                a vector 0.
              </para>
            </callout>
          </calloutlist>

        </refsect1>

      </refentry>


      <refentry id="vmusb3-madcchain">
        <refentryinfo>
          <author>
            <personname>
              <firstname>Ron</firstname>
              <surname>Fox</surname>
            </personname>
	    <personblurb><para></para></personblurb>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
          <refentrytitle>madcchain</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
          <refname>madcchain</refname>
          <refpurpose>Support CBLT chains of Mesytec MxDC32 family of modules.</refpurpose>
        </refnamediv>
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
madcchain create <replaceable>name</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
madcchain config <replaceable>name ?options</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
madcchain cget <replaceable>name</replaceable>
            </command>
          </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This module creates and configures chains of MxDC32 modules.
            At the moment the MADC-32, MTDC-32, and MQDC-32 all are 
            supported.
            If these modules are, in turn, run in multi-event mode,
            a specialized SpecTcl will be needed to unpack the data.
            It is possible, however to use single event mode with
            CBLT readout and use 'normal' SpecTcl unpacking.
          </para>
          <para>
            The <command>create</command> creates a new MxDC32 chain.
            <replaceable>name</replaceable> will be used to refer to this chain
            during configuration.  At any time the
            <command>cget</command> returns the configuration of the chain
            as a list of parameter-name parameter-value pairs.
          </para>
          <para>
            The <command>config</command> configures an MxDC32 chain.
            A set of option name option value argument pairs should follow
            the chain name on the commandline.  OPTIONS below describes the
            options and their legal values.
          </para>
        </refsect1>
        <refsect1>
          <title>OPTIONS</title>
          <para>
            This section describes the configuration options supported by
            the <command>cmadcchain</command> command.
          </para>
          <variablelist>
            <varlistentry>
              <term><option>-cbltaddress</option>  <replaceable>base-address</replaceable></term>
              <listitem>
                <para>
                  Defines the base address to which the CBLT reads will be
                  directed.  When the modules in the chain are initialized,
                  this address will be programmed as the CBLT base address.
                  Note that only the top 8 bits of this value are used.
                </para>
		<para>
		    The default value for this option is <literal>0</literal>
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-mcastaddress</option> <replaceable>base-address</replaceable></term>
              <listitem>
                <para>
                  Defines the base address for the chain's multicast address.
                  The multicast address is used to perform synchronous initialization
                  and time-stamp clears.  This address will be programmed as the
                  MCAST base address for all modules in the chain.
                  Only the top 8 bits of the <replaceable>base-address</replaceable>
                  have any meaning.
                </para>
		<para>
		    The default value for this option is <literal>0</literal>
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-maxwordspermodule</option> <replaceable>longword-coun</replaceable></term>
              <listitem>
                <para>
                  Defines the maximum words that can be read from each module.
                  This should be a number between
                  <literal>1</literal> and <literal>1024</literal>.
                  This value should usually be larger than the
                  <option>-irqthreshold</option> option programmed into the
                  MxDC32 modules in the chain.  For each block read, the
                  module will return no more data than the complete event that
                  causes the number of longwords read from the module to exceed
                  this value.
                </para>
		<para>
		    This option value defaults to <literal>512</literal>
		</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-modules</option>  <replaceable>module-name-list</replaceable></term>
              <listitem>
                <para>
                  Defines the list of MxDC32 modules that make up the chain.
                  The value for this option should be a well formulated
                  Tcl list containing names of <command>madc</command> modules.
                  There is a restriction on the order of these names.  The
                  first name in the list must be the leftmost module in the
                  crate and the last name must be the right most module in the
                  chain. 
                </para>
                <para>
                  For practical purposes, to limit confusion, I generally
                  enumerate the modules from left (low slot number) to
                  right (higher slot number). 
                </para>
		<para>
		    This option value defaults to an empty chain.  It is
		    an error to configure an madchain with fewer than two modules
		    (a starting module and an ending module).
		</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </refsect1>

        <refsect1>
          <title>EXAMPLE</title>
          <para>
            The following daqconfig.tcl script will operate on an MADC-32 and an
            MQDC-32 placed in adjacent slots of a VME crate. The MADC-32 has
            base address set to 0x0d000000 and the MQDC-32 has its base address
            set to 0x40000000 both via jumper switches. The two devices are
            configured to read out using an interrupt trigger. The MADC-32 is
            leftmost in the crate and thus is the first module to be read out.
            Both will respond to the chain block transfer address 0xaa000000 and
            multicast address 0xbb000000. 
          </para>
          <example>
            <title>Sample usage</title>
            <programlisting>
# create and configure the MADC-32 object
madc create adc -base 0x0d000000 -id 1
madc config adc -ipl 1 -vector 0

# create and configure the MQDC-32 object
mqdc create qdc -base 0x40000000 -id 2 
mqdc config qdc -ipl 1 -vector 0

# Create the chain
madcchain create chain 
madcchain config chain -cbltaddress 0xaa000000 
madcchain config chain -mcastaddress 0xbb000000
madcchain config chain -maxwordspermodule 1 

# order matters here. The adc is read first and the qdc last.
madcchain config chain -modules [list adc qdc]

# create a stack that executes via an interrupt
stack create event
stack config event -modules [list chain] -trigger interrupt -ipl 1 -vector 0 
            </programlisting>
          </example>
        </refsect1>
      </refentry>


      <refentry id="vmusb3-madcscaler">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
		<personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
        <refmeta>
           <refentrytitle>madcscaler</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>madcscaler</refname>
           <refpurpose>Support dead-time counters in MADC32 as scalers.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
madcscaler create <replaceable>name ?options?</replaceable>              
              </command>
          </cmdsynopsis>
         <cmdsynopsis>
             <command>
madcscaler config <replaceable>name ?options?</replaceable>
             </command>
         </cmdsynopsis>
         <cmdsynopsis>
             <command>
madcscaler cget <replaceable>name</replaceable>         
             </command>
         </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
              The Mesytec MADC 32 module provides two counters. These counters
              count time and ADC busy time (time between the adc gate and
              readout completion).  Reading these two values as periodic scalers
              in a scaler stack, allows for the computation of dead-time ratios
              without the use of an additional external scaler module..
           </para>
           <para>
               The <command>madcscaler</command> command supports configuring
               MADC32 modules for use as dead-time scalers.
           </para>
           <para>
            The <command>madcscaler</command> command provides the usual
            ensemble of subcommands;
            <command>create</command> to create a named module object,
            <command>config</command> to configure a previously existing object
            by name, and
            <command>cget</command> to obtain the configuration of an existing
            named object.
           </para>
           <para>
             OPTIONS below describes the configuration options.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
              <varlistentry>
                  <term><option>-base</option> <replaceable>baseAddress</replaceable></term>
                  <listitem>
                      <para>
                        Provides the base address of the module as configured
                        in its rotary switches.
                      </para>
                  </listitem>
              </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>

      <refentry id="vmusb3-mase">
        <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
	    <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
	<refmeta>
	   <refentrytitle>mase</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
            <refmiscinfo class='empty'></refmiscinfo>
	</refmeta>
	<refnamediv>
	   <refname>mase</refname>
	   <refpurpose>Support for XLM with MASE firmware.</refpurpose>
	</refnamediv>
	
	<refsynopsisdiv>
	  <cmdsynopsis>
	      <command>
mase create <replaceable>name ?options?</replaceable>
              </command>
	  </cmdsynopsis>
          <cmdsynopsis>
	     <command>
mase config <replaceable>name ?options?</replaceable>
	     </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	     <command>
mase cget <replaceable>name</replaceable>
	     </command>
          </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	   <title>DESCRIPTION</title>
	   <para>
	      The <command>mase</command> command allows you to create and configure
	      modules that are XLM-VV FGPA modules with firmware for the
	      Indiana MASE data acqusitiopn subsystem.  Please note that this
	      modules is a block mode device, in the sense that each
	      VM-USB trigger may result in multiple events being present in the
	      XLM memory by the time the VM-USB reads the data.  When used with
	      other modules, you must arrange for event building at some point
	      in the system to ensure that data from the MASE module are coherently
	      assembled with data from other devices.
	   </para>
	   <para>
              The module object is created via the <command>create</command>
	      subcommand.  The <parameter>name</parameter> on this defines
	      a unique name which will be used to refer to this module in
	      future commands directed at it.  The optional options are
	      name value pairs used to configure the module.  See
	      OPTIONS below for a list of the supported options.
	   </para>
	   <para>
	      The <command>config</command> subcommand can be used to set or modify
	      configuration parameters after the module is created.  The
	      <parameter>name</parameter> is the name of the module as defined
	      by the <command>create</command> subcommand.   The options are
	      once more name value pairs that are described in the OPTIONS section
	      below.
	   </para>
	   <para>
	      The <command>cget</command> subcommand is can be used to ask
	      a module about its current configuration.  The module configuration is
	      returned as a Tcl list of name value pairs where the name is the
	      name of a configuration option described in the OPTIONS section
	      and the value is the value of that configuration parameter.
	   </para>
	</refsect1>
	<refsect1>
	   <title>
	      OPTIONS
	   </title>
	   <variablelist>
              <varlistentry>
	         <term><option>-base</option>  <replaceable>base-address</replaceable></term>
		 <listitem>
		    <para>
		       Supplies the base address of the XLM module.  The XLM base
		       address is determined by the slot it occupies in a VME
		       backplane with V430 extensions (V430 supplies additional
		       voltages and the slot location on a middle 'JAUX' connector).
		       The base address must be an unsigned integer.  There is no
		       default value for this configuration option.  The value
		       supplied must match the actual board's base address.
                   </para>
		   <para>
		       The XLM-VV must be used in a V430 backplane as it has no other
		       mechanism for the board to set the base address.
		       For information about the JAUX connector see e.g.
		       <ulink url='http://cdsweb.cern.ch/record/1201456/files/Blanchetti_001.pdf'>
		       http://cdsweb.cern.ch/record/1201456/files/Blanchetti_001.pdf</ulink>
		       Specifically page 10 and page 25 and beyond.
		   </para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
	         <term><option>-firmware</option>  <replaceable>firmware-path</replaceable></term>
		 <listitem>
		    <para>
		       <replaceable>firmware-path</replaceable> provides the path
		       to the XLM firmware file.  In the MASE module, the firmware
		       is loaded prior to the start of a run.  The file path
		       can be relative or absolute, however environment variables
		       and tilde expansions are not performed by the module driver.
		       The Tcl script however may use the <command>file normalilze</command>
		       and the <varname>envname</varname> to perform these substitutions
		       prior to providing the final filename to this option.
		    </para>
		    <para>
			 The default for the firmware file is an empty string,
			 therefore you must explicitly configure this.
		    </para>
		 </listitem>
	      </varlistentry>
	      <varlistentry>
		  <term><option>-loadfirmware</option> <replaceable> true | false</replaceable></term>
		  <listitem>
		      <para>
			 Determines whether or not the firmware file should be
			 loaded as part of the run initialization.  If the
			 module firmware is likely to be fine after a single load,
			 you can initially set this to <literal>true</literal>
			 and, after the first run starts, set it to
			 <literal>false</literal> to speed up the start of a run.
		      </para>
		      <para>
			 This option value defaults to <literal>true</literal>
			 loading the firmware at the start of each run.
		      </para>
		  </listitem>
	      </varlistentry>
	   </variablelist>
	</refsect1>

      </refentry>


<refentry id="vmusb3-tdcv1x90">
    <refentryinfo>
      <author>
	  <personname>
	      <firstname>Ron</firstname>
	      <surname>Fox</surname>
	  </personname>
	  <personblurb><para></para></personblurb>
      </author>
      <productname>NSCLDAQ</productname>
      <productnumber></productnumber>
    </refentryinfo>
  
  <refmeta>
     <refentrytitle>tdc1x90</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
     <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>tdc1x90</refname>
     <refpurpose>Provide support for the CAEN V1x90 TDC family.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
tdc1x90 create name ?options...?
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
    <command>
tdc1x90 config name ?options?
    </command>
</cmdsynopsis>
<cmdsynopsis>
    <command>
tdc1x90 cget name
    </command>
</cmdsynopsis>

  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	Creates, configures and introspects CAEN V1x90 TDCs.  These modules
        are only supported in trigger matching mode.  Note that the trigger
        time is only good to the FPGA clock, to get precise trigger relative
        timing you will need to also digitize the trigger itself.  SpecTcl
        supports doing a digital subtraction of the trigger channel from
        all other channels to get precise trigger relative timing.
     </para>
     <para>
         The <command>create</command> subcommand creates a new TDC named
         <parameter>name</parameter> the <parameter>options...</parameter> optional
         parameter are configuration option value pairs as described in
         OPTIONS below.
         The <command>config</command> subcommand locates the TDC named
         <parameter>name</parameter> and further configures it via the
         options described in OPTIONS below.
     </para>
      <para>
         The <command>cget</command> subcommand returns as a value the module
         configuration.  The configurationis returned as a list.  Each element
         of the list is a two element sublist consisting of the configuration
         option name and its current value.
      </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	<varlistentry>
	    <term><option>-base</option> <replaceable>base-address</replaceable></term>
	    <listitem>
		<para>
                  provides the module base address as set by the rotary switches
                  on the board.
		</para>
	    </listitem>
	</varlistentry>
        <varlistentry>
         <term><option>-vsn</option> <replaceable>geo</replaceable></term>
         <listitem>
            <para>
               Provides the virtual slot number. This value will appear in the
               data from the module in the GEO field.  The <parameter>geo</parameter>
               value must be between 0 and 31 inclusive.
            </para>
	    <para>
	       Default value for this option is <literal>0</literal>.
	    </para>
         </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>-ipl <replaceable>n</replaceable></option></term>
        <listitem>
            <para>
                Sets the interrupt priority level when using the device interrupts.
                If this is 0 interrupts are disabled.  Legal value are between
                0 and 7 inclusive.  See the <option>-vector</option> switch
                as well.  This defaults to 0.
            </para>
        </listitem>
       </varlistentry>
        <varlistentry>
            <term><option>-vector</option> <replaceable>nnn</replaceable></term>
            <listitem>
                <para>
                    Sets the interrrupt status id value for the module if
                    used in interrupt mode.  If this is 0, interrupts are disabled.
                    See <option>-ipl</option> as well.  This defaults to 0.
                    The values must be integers in the range 0 - 255 inclusive.
                </para>
		<para>
		    This defaults to <literal>0</literal>.
		</para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-termination</option> <replaceable>none|switch|on</replaceable></term>
            <listitem>
                <para>
                    Sets the module termination.  The value can be any of the
                    following:
                    <variablelist>
                    <varlistentry>
                       <term><literal>none</literal></term>
                       <listitem>
                       <para>
                          No termination will be supplied by the module.
                       </para>
                       </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>switch</literal></term>
                       <listitem>
                       <para>
                          Termination will be controlled by switches in the module
                       </para>
                       </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>on</literal></term>
                       <listitem>
                          <para>
                          Termination is enabled.
                          </para>
                       </listitem>
                    </varlistentry>
                    </variablelist>
                    The default is <literal>on</literal>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-tagtime</option> <replaceable>on|off</replaceable></term>
            <listitem>
                <para>
                    Controls wehther or not the trigger time will be inlcuded
                    in the data.  Note that the trigger time is only accurate
                    to within one tick of the 80Mhz FPGA clock.
                </para>
		<para>
		    This parameter is <literal>on</literal> by default.
		</para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-highwatermark</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Determines the numbger of events that must be buffered by the TDC
                to generate an interrupt.  The vale must be an integer in the range
                0..65535 inclusive.  The default value 1, means an interrupt is
                generated whenever there is at least one event in the TDC and
                the TDC interrupts are enabled.
            </para>
	    <para>
	       Defaults to <literal>1</literal> whic is suitable for running
	       the module in single event mode as an interrupt trigger.
	    </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-ecloutput</option> <replaceable>ready|full|almostfull|error</replaceable></term>
            <listitem>
            <para>
                Determines which signal is presented at the programmable ECL
                output pins.  See the CAEN V1190/1290 manuals for information about
                the possible values.  The default is <literal>ready</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-window</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
              The width of the trigger matching window in 25ns units.
              This is sets the effective range of the TDC when simulating
              a common stop or common start TDC. See also <option>-offset</option>,
              <option>-extramargin</option> and <option>-rejectmargin</option>
              and see the section of the TDC manual that describes trigger matching
              mode.  The default value is 40 which corresponds to a 1usec
              matching window.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-offset</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Determines when the trigger matching window starts relative
                to the gate.  A positive offset starts the match window after the
                gate while a negative offset starts the match window prior to the
                gate.  The values are integers and are in 25ns units.  See
                section 2.4.1 for additional constraints.  Note that the actual
                window start time will jitter by +/-25ns, and therefore you should
                use a reference channel to get good gate relative timing.
                Values must be in the range -2048 to 40 inclusive...
                Defaults to -40 or 1usec prior to the gate.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-extramargin</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                The extra search margin for hits.  This is the addtional
                time during after the matching window during which the module
                will search for hits that
                are within the window before declaring the event.  
                This is needed because hits are searched for in the
                module's L1 buffer. Contention may prevent matching hits
                from being written to the L1 buffer for some time after
                they have actually occured.  See 2.4.1 in the manual.
                The units of this value are also 25ns.
                Defaults to  8 which is 200ns.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-rejectmargin</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                 The reject margin.  This is also in 25ns units.  While
                 the module is in continuous storage, it maintains a reject
                counter that flushes hits from the buffer when the
                trigger window is not active.  The module will only
                retain hits for the width of the trigger 
                window + offset + reject marjin before throwing them away
                if there is no trigger.  This ensures the TDC buffer does
                not overflow and that the search for matching hits on the
                trigger is rapid.  
                Defaults to 4 which is 100ns.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-triggerrelative</option> <replaceable>enabled|disabled</replaceable></term>
            <listitem>
            <para>
                 If enabled, the trigger time is subtracted from all the
                hits.  Note again that the trigger time is 
                only precise to 25ns. Precise timing relative to the trigger
                can only be done by subtracting a digitized trigger time
                from the hits.
                Defaults to  <literal>enabled</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-edgedetect</option> <replaceable>pair | leading | trailing | both</replaceable></term>
            <listitem>
            <para>
                Sets the module edge detect mode.   Figure 2.2 provides
                trailing, both}  documentation about what this means;
                'pair' provides the width of a pulse in a 
                channel, 'leading' provides a hit time at the leading
                edge of a pulse, 'trailing' provides a hit time at the
                trailing edge of an input pulse, and 'both' provides
                the time of both the leading and trailing edges of a pulse
                Defaults to  <literal>leading</literal>.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-edgeresolution</option> <replaceable>800ps | 200ps | 100sp | 25ps </replaceable></term>
            <listitem>
            <para>
                 Selects the resolution for the leading/trailing resolution.
                 It is an error to use 25ps if the module is not a V1290
                Defaults to  <literal>100ps</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-leresolution</option> <replaceable>100ps | 200ps | 400ps
            | 800ps | 1.6ns | 3.12ns | 6.25ns | 12.5ns </replaceable></term>
            <listitem>
            <para>
                 In leading, trailing and both mode, sets the resolution
                 with which the leading edge is detected.  
                 Defaults to: <literal>100ps</literal>.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-widthresolution</option> <replaceable>
            100ps | 200ps | 400ops | 800ps | 1.6ns | 3.2ns | 6.25ns | 12.5ns | 400ns | 800ns </replaceable> </term>
            <listitem>
            <para>
                 Sets the resolution with which a pulse width is
                 measured in pair mode. 
                 defaults to <literal>100ps</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-deadtime</option> <replaceable>
            5ns | 10ns | 30ns | Sets 
                  100ns</replaceable></term>
            <listitem>
            <para>
                the double hit resolution. Defaults to <literal>5ns</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-encapsulatechip</option> <replaceable>true | false </replaceable></term>
            <listitem>
            <para>
                If true, the data from a chip is encapsulated as shown
                in figures 6.2/6.4 by a TDC Chip header/trailer.
                default <literal>enabled</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-maxhits</option> <replaceable>
            0 | 1 |  2 |  4 |  8 |
                 16 | 32 | 64 | 128 | infinite</replaceable></term>  
            <listitem>
            <para>
                     Specifies the maximum number of hits for each TDC chip
                     in an event.  Note that a TDC chip has 32 channels.
            </para>
	    <para>
	       Defaults to <literal>infinite</literal>, not limiting the number
	       of hits the module can return per trigger.
	    </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-errormark</option> <replaceable>true | false </replaceable></term>
            <listitem>
            <para>
                 If true, when an error is detected, an error mark item
                is placed in the output buffer. Figure 6.5 describes the
                format of this item.
                Defaults to  <literal>true</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-errorbypass</option> <replaceable>on | off</replaceable></term>
            <listitem>
            <para>
                If enabled, a TDC that reports an error will not be
                read out for that event.
                Default: <literal>on</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-globaloffset</option> <replaceable>{n m}</replaceable></term>
            <listitem>
            <para>
                Provides the global offset/vernier offset.
                Default: <literal>{0 0}</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-channeladjusts</option></term>
            <listitem>
            <para>
                 Arbitary number of elements that can adjust
                the value of individual channels by adding a positive
                offset to them.  The value of this is a list of two element
                lists where each element consist of a channel number and
                its offset. e.g. {{10 6} {32 5}}  sets the channel
                offsets for channel 10 to 6 and for channel 32 to 5.
            </para>
	    <para>
	       The default for this option is an empty list which supplies
	       no channel adjustments.
	    </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-refchannel</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Sets the reference channel.  The value of this channel
                is subtracted from all other channels to produce
                high precision times.  Defaults to <literal>0</literal>.
                This option is only used by VMUSBSpecTcl and does not influence
                the way the TDC is initialized or read.  This subtraction
		requires the use of VMUSBSpecTcl.  If you are rolling your own
		SpecTcl you'll need to know and perform this subtraction yourself.
            </para>
	    <para>
	       By default this value is <literal>0</literal>
	    </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-depth</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Sets the number of hits to retain for each channel
                for the purposes of histogramming.
                Defaults to <literal>16</literal>. This option is only
                processed by VMUSBSpecTcl.  It setting does not influence the setup
                or readout of the TDC.  Note however that setting this value
                larger than the value of <option>-maxhits</option> is probably
                not very useful.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-channelcount</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Sets the number of channels the model of the TDC being used has.
                This is only used to setup VMUSBSpecTcl's histogramming.
                The value should be one  of 16, 32, 64, or 128, however
                this is not checked by the processing code for this option.
            </para>
	    <para>
	       This defaults to an empty string.  If you are using this module
	       with VMUSBSpecTcl you must configure this option
	       explicitly.
	    </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
     <title>METHODS</title>
     <variablelist>
	<varlistentry>
	    <term><command>create <replaceable>name base</replaceable></command></term>
	    <listitem>
		<para>
                    Creates a new instance of a CAEN multihit TDC from the
                    V1x90 family of digitizers.
                    <parameter>name</parameter> is used to refer to this module
                    from now on.
                    The 
                    <parameter>base</parameter> sets the base address of the
                    module.
		</para>
	    </listitem>
	</varlistentry>
        <varlistentry>
            <term><command>config <replaceable>name options</replaceable></command></term>
            <listitem>
            <para>
                Configures an existing TDC <parameter>name</parameter>
                <parameter>options</parameter> are option name value pairs described
                above.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>cget <replaceable>name</replaceable></command></term>
            <listitem>
            <para>
                Returns the module <parameter>name</parameter>'s configuration
                as a list of name value pairs.
            </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
     <title>EXAMPLES</title>
     <para>
     </para>
  </refsect1>

</refentry>
	  
        <refentry id="vmusb3-v1729a">
	    <refentryinfo>
	      <author>
		  <personname>
		      <firstname>Ron</firstname>
		      <surname>Fox</surname>
		  </personname>
		  <personblurb><para></para></personblurb>
	      </author>
	      <productname>NSCLDAQ</productname>
	      <productnumber></productnumber>
	    </refentryinfo>
          <refmeta>
             <refentrytitle>v1729a</refentrytitle>
             <manvolnum>3vmusb</manvolnum>
	     <refmiscinfo class='empty'></refmiscinfo>
          </refmeta>
          <refnamediv>
             <refname>v1729a</refname>
             <refpurpose>CAENV1729a waveform digitizer.</refpurpose>
          </refnamediv>
          
          <refsynopsisdiv>
            <cmdsynopsis>
                <command>
v1729a create <replaceable>name base</replaceable>
            </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
v1729a config <replaceable>name options</replaceable>
            </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
v1729a cget <replaceable>name</replaceable>
            </command>
            </cmdsynopsis>
      
          </refsynopsisdiv>
          <refsect1>
             <title>DESCRIPTION</title>
             <para>
                This command ensemble provides access to the CAEN V1729A
                waveform digitizer.  The three subcommands allow creation
                configuration and introspection.  See METHODS below for more
                information about these subcommands and their formats.
             </para>
             <para>
                The options described in OPTIONS below allow data taking
                and analysis to be configured according the needs of the
                application.
             </para>
          </refsect1>
          <refsect1>
             <title>
                OPTIONS
             </title>
             <variablelist>
                <varlistentry>
                <term><option>-base</option> <replaceable>base</replaceable></term>
                <listitem>
                <para>
                    Provides the module base address.  The <parameter>base</parameter>
                    must match the base address set in the rotary switches
                    of the module.
                </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term><option>-threshold</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                     Threshold for internal trigger.  The default value is
                     <literal>4095</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-pretrigger</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                    Pretrigger time in samples.  Defaults to
                    <literal>10240</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-posttrigger</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                    Post trigger time in samples.
                    Defaults to <literal>64</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggersource</option>
                <replaceable>external | internal | both</replaceable></term>
                <listitem>
                <para>
                    Specifies trigger source: this can  be  <literal>external</literal>,
		    <literal>internal</literal>, or
		    <literal>both</literal>.
                    Defaults to <literal>external</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggeredge</option> <replaceable>rising | falling</replaceable></term>
                <listitem>
                <para>
                    Specifies which edge of the trigger is used.
                    Default is <literal>rising</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggermask</option> <replaceable>on | off</replaceable></term>
                <listitem>
                <para>
                     Specifies whether the trigger is masked via the EXT_EN_TRIGGER
                    if this is 'on' EXT_EN_TRIGGER is required to enable triggers
                    to fire.  Defaults to <literal>off</literal>.
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggerchannels</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                    Only used if internal triggers are allowed.  Set one bit for each
                    channel from which triggers are allowed.  This defaults
		    to <literal>0xf</literal> allowing any channel to be used
		    as an internal trigger.
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-poststoplatency</option> <replaceable> n</replaceable></term>
                <listitem>
                <para>
                    Sets the post trigger latency register in samples.
                    Defaults to <literal>4</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-postlatencypretrig</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                    Sets the value of the post latency pretrigger register.
                    Defaults to <literal>1</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-samplingfreq</option>
                <replaceable>2ghz | 1gzh | 500mhz</replaceable></term>
                <listitem>
                <para>
                     Sampling frequency.  Default value is
                     <literal>2ghz</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-delay</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                     uSec to delay prior to executing the readout.
                    this can be set to zero if the modle interrupt is 
                    used to trigger the data acquisition else it should be set
                    to on the order of 700usec depending on triggering parameters.
                    650usec from end of the signal are required to transfer data.
                    the remaining time depends on the time of the computer trigger
                    relative to the time of the signal end.
                    When setting this recall that the module requires 650usec
                    to digitize and transfer data from the analog memory to
                    the readout memory.
                </para>
		<para>
		    This defaults to <literal>0</literal>, so in general you
		    will need to explicitly configure this.
		</para>
                </listitem>
            </varlistentry>

            </variablelist>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    Subcommands recognized by this module are:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>create <replaceable>name base</replaceable></term>
                        <listitem>
                        <para>
                            Creates a new module that can be referred to by
                            <parameter>name</parameter>.  <parameter>base</parameter>
                            is the module base address. This can be overidden
                            by the <option>-base</option> configuration
                            parameter.
                        </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>config <replaceable>name options</replaceable></term>
                        <listitem>
                        <para>
                            Configures the module <parameter>name</parameter>.
                            The <parameter>optinos</parameter> are configuration
                            option value pairs described inthe OPTIONS
                            section above.
                        </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>cget <replaceable>name</replaceable></term>
                        <listitem>
                        <para>
                            Retrieves the module configuration as a list
                            of name value pairs.
                        </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
          </refsect1>
  
        </refentry>

      <refentry id="vmusb3-stack">
	    <refentryinfo>
	      <author>
		  <personname>
		      <firstname>Ron</firstname>
		      <surname>Fox</surname>
		  </personname>
		  <personblurb><para></para></personblurb>
	      </author>
	      <productname>NSCLDAQ</productname>
	      <productnumber></productnumber>
	    </refentryinfo>
	  
        <refmeta>
           <refentrytitle>stack</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
	   <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>stack</refname>
           <refpurpose>Compose and configure VM-USB readout stacks.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
      	<command>
stack create <replaceable>name</replaceable>
      	</command>
          </cmdsynopsis>
             <cmdsynopsis>
                 <command>
stack config <replaceable>name option value...</replaceable>
                 </command>
             </cmdsynopsis>
             <cmdsynopsis>
                 <command>
stack cget <replaceable>name</replaceable>
                 </command>
             </cmdsynopsis>
         
        </refsynopsisdiv>        

        <refsect1>
    
           <title>DESCRIPTION</title>
           <para>
               The VM-USB supports eight readout <firstterm>stacks</firstterm>.
               A stack can be thought of as a set of VME operations the
               VM-USB should perform in response to some trigger condition.
               Reads performed by a stack are placed in an event buffer. Writes
               occure but result in no data.  At appropriate times, the VM-USB
               transmits buffers of read events to the host computer over its USB
               interface. Stacks provide avoid the high latency of the USB bus
               by pushing the readout intelligence for events into the VM-USB, and
               out of the host.
           </para>
           <para>
               The VM-USB supports 8 stacks, and  three kinds of triggers for stacks.
               While all stacks can be
               interrupt triggered, we simplify the VM-USB usage by only allowing
               stacks 2-7 to accept interrupt triggers, defining stack 0 to be
               only triggerable on the <literal>NIM1</literal> input, and stack
               1 to only be triggered with some time periodicity.
           </para>
            <para>
               The <command>stack</command> command allows you to compose stacks
               and specify their trigger conditions.  When data taking is
               enabled, all defined stacks are loaded into the VM-USB and
               their triggers set up.  Stacks are composed by specifying the
               set of modules they should read via the <option>-modules</option>
               configuration option.  All modules in a stack are initialized
               at stack load time and read when the stack is triggered, in the
               order in which they were specified.
            </para>
            <para>
               The <command>create</command> subcommand creates a stack named
               <parameter>name </parameter>.  <parameter>name</parameter>
               will be used by you in future <command>config</command> and
               <command>cget</command> subcommands to refer to this stack.
            </para>
            <para>
               The <command>config</command> subcommand allows you to configure
               the stack contents and trigger conditions of the stack.
               <parameter>name</parameter> determines which stack will be configured.
               The configuration is specified via a set of <replaceable>option value</replaceable>
               pairs.  These are described in OPTIONS below.
            </para>
            <para>
               The <command>cget</command> command returns the configuration of
               the stack as a well formed Tcl list of <replaceable>option value</replaceable>
               pairs.
            </para>
        </refsect1>
        <refsect1>
           <title>
      	OPTIONS
           </title>
           <variablelist>
      	<varlistentry>
      	    <term><option>-trigger</option> <replaceable>nim1 | scaler | interrupt</replaceable></term>
      	    <listitem>
      		<para>
                  Defines the strigger source for the stack.  When the designated
                  trigger is present, the stack will execute.
                  <literal>nim1</literal> triggers the stack on a nim logic true pulse
                  to the IN1 input of the VM-USB.  This forces the stack to be 
                  VM-USB stack number zero as that is the only stack that can be
                  triggered by the IN1.
      		</para>
                <para>
                  <literal>scaler</literal>
                  triggers the stack on the periodic scaler.  This forces the stack
                  to be stack number 1 as that is the only peridically triggerable stack.
                  We restrict periodic triggers to time based periodicity rather than
                  event division periodicity.  The <option>-period</option> option
                  defined below must be configured as well to define the periodicity
                  of the scaler stack.
                </para>
                <para>
                  <literal>interrupt</literal>
                  indicates the stack will be interrupt triggered. This can be
                  used for stacks 2 through 7 as defined by the <option>-stack</option>
                  configuration parameter.   The actual VME interrupt that will trigger
                  the stack is defined by both its interrupt priority level
                  <option>-ipl</option> and the status id the interrupt source
                  places on the backplane in response to the interrupt acknowledge
                  cycle, and specified with the <option>-vector</option> configuration
                  parameter.
                </para>
		<para>
		    The default value for <option>-trigger</option> is
		    <literal>nim1</literal>.
		</para>
      	    </listitem>
      	</varlistentry>
         <varlistentry>
            <term><option>-period</option> <replaceable>seconds</replaceable></term>
            <listitem>
               <para>
                  Defines the number of seconds (integer) between scaler stack triggers.
                  This is ignored for all stacks that are not <literal>scaler</literal>
                  <option>-trigger</option>-ed.  The VM-USB manual defines the range of legal
                  values for this option.
               </para>
	       <para>
		    Defaults to <literal>2</literal>. 
	       </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-stack</option> <replaceable>stacknum</replaceable></term>
            <listitem>
               <para>
                  Defines the stack number for <literal>interrupt</literal>
                  <option>-trigger</option>-ed stacks.  This is an integer value
                  in the range 2-7 inclusive. This will also select the
                  interrupt register used to define the trigger for the stack.
               </para>
	       <para>
		    Defaults to <literal>2</literal>, the first interrupt
		    driven stack.  Note that each stack must have a unique
		    stack number.  The <literal>nim1</literal> triggered
		    stack will be stack <literal>0</literal>,
		    the <literal>scaler</literal> stack will be
		    stack <literal>1</literal>.
	       </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-vector</option> <replaceable>status-id</replaceable></term>
            <listitem>
               <para>
                  For <literal>interrupt</literal> <option>-trigger</option>-ed
                  stacks, this defines the status Id that must be presented by
                  the interrupt source in response to an interrupt acknowledge
                  to trigger the list.  This taken together with the value of the
                  <option>-ipl</option> configuration option defines the trigger
                  condition for these stacks. The <parameter>status-id</parameter>
                  must be a value between 0 and <literal>0xffff</literal>
		  inclusive.
               </para>
	       <para>
		    Note that while the <option>-vector</option> parameter is
		    a 16 bit value, all modules we have produce 8 bit vectors.
		    The VME standard is ambiguous about how the top bits of
		    an 8 bit vector are returned when read by a 16 bit wide
		    statusID cycle.  The standard allows these bits to either
		    be set or clear.  Where we know what individual modules
		    do, we have documented that.  If what your module
		    does is not documented, we have not charted what the module
		    does.  Try either setting those bits to 1 or 0 and please
		    let us know what you find so that we can improve
		    this documentation.
	       </para>
	       <para>
		    This defaults to <literal>0</literal>.
	       </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-ipl</option> <replaceable>priority</replaceable></term>
            <listitem>
               <para>
                  Defines the interrupt priority level that of the interrupt
                  that will trigger the stack.  An iterrupter places a 3 bit
                  interrupt priority level (IPL) on the VME bus when it requests
                  an interrupt.  The IPL must be nonzero and is intended to reflect
                  the priority of the interrupt (7 highest, 1 lowest), although, in fact,
                  the VME standard allows interrupt responders to treat this value
                  in any way they want.
               </para>
               <para>
                  The VM-USB uses the specified <parameter>priority</parameter> as
                  part of the trigger condition for an <literal>interrupt</literal>
                  <option>-trigger</option>-ed stack.  When an acknowledged interrupt
                  matches both the <option>-ipl</option>, and the <option>-vector</option>
                  configuration parameters of a stack the stack is triggered.
	       </para>
	       <para>
		    The default value is <literal>6</literal>.
	       </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-delay</option> <replaceable>microseconds</replaceable></term>
            <listitem>
               <para>
                  The VM-USB allows you to define a delay between the stack trigger condition
                  and the actual start of stack execution.  This is normally intended to be used
                  with stacks that are triggered on <literal>nim1</literal>, as there may be
                  a significant time between the generation of an external trigger and the
                  conversion of the digitizers associated with the trigger.  As I read the
                  VM-USB manual, however this delay applies to <emphasis>all</emphasis> stacks.
               </para>
               <para>
                  The <parameter>microseconds</parameter> is the number of microseconds to delay
                  (0-255) between triggers and stack executions.  Because of my understanding of the
                  <emphasis>intent</emphasis> of this delay, the <option>-delay</option> option
                  is ignored for all stacks that are not <literal>nim1</literal>
                  <option>-trigger</option>-ed.
               </para>
               <para>
                  In the very unlikely event that you need to apply a trigger delay
                  to interrupt triggered stacks (most hardware interrupts when data
                  are ready not on a trigger), and you are not using <literal>nim1</literal>
                  triggered stacks, simply build a non-empty <literal>nim1</literal> triggered
                  stack, set it's
                  <option>-delay</option> option to the required delay and never trigger
                  that stack (don't cable anything to the IN1 input).
		  Otherwise you can insert <command>delay</command> modules in
		  the stack.
               </para>
	       <para>
		    The default <command>-delay</command> value is
		    <literal>0</literal>
	       </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-modules</option>  <replaceable>module-list</replaceable></term>
            <listitem>
               <para>
                  Defines the set of modules that will be read out. This can be
                  a valid Tcl list of any set of modules that have been defined
                  so far.  The modules are specified in the order in which readout
                  commands for them will be added to the stack.  If you have
                  built a <command>caenchain</command> add that to the stack rather
                  than adding the individual modules.
               </para>
               <para>
                  Lists of modules must be valid Tcl lists thus:
                  <programlisting>
stack config astack -modules adc1 adc2 adc3  ;      # Incorrect
stack config astack -modules [list adc1 adc2 adc3]; # Correct.
                  </programlisting>
               </para>
	       <para>
		    The default <option>-modules</option> value is an empty
		    list.  Since an empty lsit is not allowed,
		    you will need to explicitly configure this option.
	       </para>
            </listitem>
         </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
           <title>EXAMPLES</title>
           <para>
               The example below is a rather complete demonstration of how to
               define a set of modules, adc's and scalers, aggregate the
               three adc's into a caenchain, and read that chain as a stack
               triggered on NIM1, and read a pair of scalers triggered every two seconds.
           </para>
           <example>
            <title>Building Stacks</title>
            <programlisting>
adc create adc1    0x04000000
adc config adc1    -geo 12 -supressrange off  -ipl 0 -vector 0

adc create adc2    0x05000000
adc config adc2    -geo 13 -supressrange off  -ipl 0 -vector 0

adc create adc3    0x06000000
adc config adc3    -geo 14 -supressrange off -ipl 0 -vector 0


caenchain create chain

caenchain config chain -base 0x10000000 -modules [list adc1 adc2 adc3]


sis3820 create scaler1 0x35000000
v830    create scaler2 0x80000000
sis3804 create scaler3 -base 0x38383800



stack create events
stack config events -trigger nim1   -modules chain -delay 12

set scalers [list scaler1 scaler2 scaler3]


stack create scalers


stack config scalers -trigger scaler -modules $scalers -period 2

            </programlisting>
           </example>
        </refsect1>

      </refentry>

     <!--  mdpp32qdc command reference -->
     <refentry id="vmusb3-mdpp32qdc">
         <refentryinfo>
             <author>
                 <personname>
                     <firstname>Genie</firstname>
                     <surname>Jhang</surname>
                 </personname>
                 <personblurb><para></para></personblurb>
             </author>
             <productname>NSCLDAQ</productname>
             <productnumber></productnumber>
         </refentryinfo>
         <refmeta>
             <refentrytitle>mdpp32qdc</refentrytitle>
             <manvolnum>3vmusb</manvolnum>
             <refmiscinfo class='empty'></refmiscinfo>
         </refmeta>
         <refnamediv>
             <refname>mdpp32qdc</refname>
             <refpurpose>Mesytec MDPP-32 module with QDC firmware</refpurpose>
         </refnamediv>
         <refsynopsisdiv>
             <cmdsynopsis>
                 <command>
mdpp32qdc create <replaceable>name -base base [option1 value1 option2 value2 ...]</replaceable>
                 </command>
             </cmdsynopsis>
             <cmdsynopsis>
                 <command>
mdpp32qdc config <replaceable>name option value ...</replaceable>
                 </command>
             </cmdsynopsis>
             <cmdsynopsis>
                 <command>
mdpp32qdc cget <replaceable>name</replaceable>
                 </command>
             </cmdsynopsis>
         </refsynopsisdiv>
         <refsect1>
             <title>DESCRIPTION</title>
             <para>
                 This command creates, configures and retrieves the configuration of
                 Mesytec MDPP-32 module with QDC firmware.
             </para>
             <para>
                 Use the <command>create</command> subcommand to create a new module instance
                 providing it with a unique <parameter>name</parameter> that will
                 be used to identify it in future commands.  The <parameter>-base</parameter>
                 parameter is the base address of the module as set in the module rotary
                 switches. Options and corresponding values can be provided with the
                 <command>create</command> subcommand instead of using <command>config</command>
                 subcommand to configure.
             </para>
             <para>
                 Use the <command>config</command> subcommand to configure
                 a module named <parameter>name</parameter>  the <parameter>option</parameter>
                 options and legal values are described in the section OPTIONS below.
             </para>
             <para>
                 The <command>cget</command> subcommand returns as its value the configuration
                 of the module <parameter>name</parameter>.  The configuration is
                 returned as a list of two element sublists where each sublist
                 contains, in order, an option from OPTIONS below, and its value.
                 Note that some values may themselves be lists.
             </para>
         </refsect1>
         <refsect1>
             <title>
                 OPTIONS
             </title>
             <variablelist>
                 <varlistentry>
                     <term><option>-base</option> <replaceable>value</replaceable></term>
                     <listitem>
                         <para>
                             Allows you to reconfigure the base address of a module.
                             This defaults to <literal>0</literal>. The required
                             <parameter>-base</parameter> parameter of the create
                             option for this device overrides the default value.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-id</option> <replaceable>vsn</replaceable></term>
                     <listitem>
                         <para>
                             <parameter>vsn</parameter> will be used as the module's
                             identifier or <firstterm>virtual slot number</firstterm>.
                             The <parameter>vsn</parameter> will be encoded into the
                             event data that is returned by the module. This, in turn
                             is normally used by event decoders to determine which parameters
                             the channels of the module should be unpacked into.
                         </para>
                         <para>
                             Each module should be given a unique <parameter>vsn</parameter>.
                         </para>
                         <para>
                             By default, the value is <literal>0</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-ipl</option> <replaceable>0-7</replaceable></term>
                     <listitem>
                         <para>
                             The interrupt priority level the module should use to request
                             a VME bus interrupt. Normally interrupts will be used
                             to trigger an interrupt triggered stack.
                         </para>
                         <para>
                             By default, the value is <literal>0</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-vector</option> <replaceable>0-255</replaceable></term>
                     <listitem>
                         <para>
                             The interrupt vector the module should use. The vector value is ignored if
                             the module interrupts are disabled.
                         </para>
                         <para>
                             Note that the VMUSB processes 16 bit vectors, but the
                             vector produced by this module is 8 bits wide.
                             The VME standard is ambiguous about how such modules
                             produce the top eight bits of the vector under these
                             circumstances. Mesytec modules set those top bits
                             to 0xFF.  E.g. <option>-vector </option> <literal>0x80</literal>
                             produces a vector, as see by the VMUSB of <literal>0xFF80</literal>.
                             One important thing to note in this case is that one must pass
                             <option>-vector</option> option to the stack as <literal>0xFF80</literal>
                             to use interrupt-triggered stack. <literal>0x0080</literal> won't work.
                         </para>
                         <para>
                             By default, the value is <literal>0</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-irqeventthreshold</option> <replaceable>0-32767</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 QDC documentation) Every time the number of events in the FIFO
                             exceeds this threshold, an IRQ is emitted.
                         </para>
                         <para>
                             The register length is 15 bit. Thus, the maximum number it can take should be
                             <literal>0x3FFF (32757)</literal>
                         </para>
                         <para>
                             By default, the value is <literal>3</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-irqdatathreshold</option> <replaceable>0-32256</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 QDC documentation) Every time the number of 32 bit words in
                             the FIFO exceeds this threshold, an IRQ is emitted. Maximum allowed threshold
                             is "FIFO size".
                         </para>
                         <para>
                             "FIFO size" in the QDC documentation is 32k-512=32256.
                         </para>
                         <para>
                             By default, the value is <literal>1</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-irqsource</option> <replaceable>event|data</replaceable></term>
                     <listitem>
                         <variablelist>
                             <varlistentry>
                                 <term><literal>event</literal></term>
                                 <listitem>
                                     <para>
                                         Use the value provided with <option>-irqeventthreshold</option> as
                                         the IRQ threshold.
                                     </para>
                                 </listitem>
                             </varlistentry>
                             <varlistentry>
                                 <term><literal>data</literal></term>
                                 <listitem>
                                     <para>
                                         Use the value provided with <option>-irqdatathreshold</option> as
                                         the IRQ threshold.
                                     </para>
				     
                                 </listitem>
                             </varlistentry>
                         </variablelist>
                         <para>
                           By default, the value is <literal>event</literal>
                         </para>

                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-maxtransfer</option> <replaceable>0-32256</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 QDC documentation) With
                             "<option>-multievent</option> <literal>3</literal>", the value specifies
                             the amount of data read from FIFO before Berr is emitted. Transfer stops
                             only after full events.
                         </para>
                         <para>
                             e.g. With "<option>-maxtransfer</option> <literal>1</literal>", 1 event
                             per transfer is emitted.
                         </para>
                         <para>
                             With "<option>-multievent</option> <literal>0xb</literal>", the value specifies
                             the number of events read from FIFO before Berr is emitted.
                         </para>
                         <para>
                             Setting this option to <literal>0</literal> allows unlimited transfer.
                         </para>
                         <para>
                             By default, the value is <literal>1</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-datalenformat</option>
                         <replaceable>8bit | 16bit | 32bit | 64bit | numevents</replaceable>
                     </term>
                     <listitem>
                         <variablelist>
                             <varlistentry>
                               <term><literal>numevents</literal></term>
			       <listitem>
                                 <para>Show number of events in FIFO</para>
			       </listitem>
                             </varlistentry>
                         </variablelist>
                         <para>
                             (From MDPP-32 QDC documnetation) The number of 32 bit words is always even.
                             If necessary the fill word "0" is added. For the setting <literal>0</literal>
                             and <literal>1</literal>, the max value <literal>0xFFFF</literal> is shown
                             when number exceeds the 16 bit format. The FIFO is not affected.
                         </para>
                         <para>
                             By default, the value is <literal>32bit</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-multievent</option> <replaceable>See detail</replaceable></term>
                     <listitem>
                         <para>
                             By default, the value is <literal>0xb</literal>.
                         </para>
                         <informalexample>
                             <programlisting>
+-----------------------------------------+
|     Bit[3]     |   Bit[2]   | Bit[1:0]  |
+-----------------------------------------+
|  count events  | skip Berr, | mode[1:0] |
|   not words    | send EOB   |           |
| (reg. 0x601A)  |            |           |
+-----------------------------------------+
                             </programlisting>
                         </informalexample>
                         <variablelist>
                             <varlistentry>
                                 <term><literal>Bit[1:0]</literal></term>
                                 <listitem>
                                     <para>
                                         (From MDPP-32 QDC documentation)
                                     </para>
                                     <para>
                                         Allow multi event buffering.
                                     </para>
                                     <variablelist>
                                         <varlistentry>
                                             <term><literal>0</literal></term>
                                             <listitem>
                                                 <para>
                                                     Not allowing multi event buffering
                                                 </para>
                                                 <para>
                                                     Register <literal>0x6034</literal> clears events
                                                     allowing new conversion.
                                                 </para>
                                             </listitem>
                                         </varlistentry>
                                         <varlistentry>
                                             <term><literal>1</literal></term>
                                             <listitem>
                                                 <para>
                                                     Allowing multi event buffering
                                                 </para>
                                                 <para>
                                                     Unlimited transfer. No readout reset required.
                                                     Register <literal>0x6034</literal> can be written
                                                    after block readout. Don't use for CBLT.
                                                 </para>
                                             </listitem>
                                         </varlistentry>
                                         <varlistentry>
                                             <term><literal>3</literal></term>
                                             <listitem>
                                                 <para>
                                                     Allowing multi event buffering, but MDPP transfers
                                                     limited amount of data.
                                                 </para>
                                                 <para>
                                                     The number of data words can be specified via
                                                     register <literal>0x601A</literal> After word limit is
                                                     reached, the next end of event mark terminates transfer
                                                     by emitting Berr. So, register <literal>0x601A</literal>=1
                                                     means event by event transfer (Berr after each event).
                                                 </para>
                                                 <para>
                                                     The next data block can be transferred after writing
                                                     the register <literal>0x6034</literal> (resets Berr).
                                                 </para>
                                             </listitem>
                                         </varlistentry>
                                     </variablelist>
                                 </listitem>
                             </varlistentry>
                             <varlistentry>
                                 <term><literal>Bit[2]</literal></term>
                                 <listitem>
                                     <para>
                                         Berr handling. If set, send <literal>EOB=bit[31:30]=bx10</literal>
                                         instead of Berr.
                                     </para>
                                 </listitem>
                             </varlistentry>
                             <varlistentry>
                                 <term><literal>Bit[3]</literal></term>
                                 <listitem>
                                     <para>
                                         Compare number of transmitted events (not words!) with the register
                                         <literal>0x601A</literal> value (<option>-maxtransfer</option> value)
                                         for Berr condition.
                                     </para>
                                 </listitem>
                             </varlistentry>
                         </variablelist>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-marktype</option>
                         <replaceable>eventcount | timestamp | extended-timestamp</replaceable>
                     </term>
                     <listitem>
                         <para>
                             By default, the value is <literal>timestamp</literal>.
                         </para>
                         <variablelist>
                             <varlistentry>
                                 <term><literal>eventcount</literal></term>
                                 <term><literal>timestamp</literal></term>
                                 <listitem>
                                     <para>
                                         The last 32 bit word in the data contains either event counts
                                         or timestamp according to the setting.
                                     </para>
                                     <informalexample>
                                         <programlisting>
+------------------------------+
|  2  |           30           |
+------------------------------+
| b11 | eventcount / timestamp |
+------------------------------+
                                         </programlisting>
                                     </informalexample>
                                 </listitem>
                             </varlistentry>
                             <varlistentry>
                                 <term><literal>extended-timestamp</literal></term>
                                 <listitem>
                                     <para>
                                         Following 32 bit word will be added to the data.
                                     </para>
                                     <informalexample>
                                         <programlisting>
+------------------------------------------------------+
|  2  |  2  |       12       |           16            |
+------------------------------------------------------+
| b00 | b10 | xxxx xxxx xxxx | 16 high bits time stamp |
+------------------------------------------------------+
                                         </programlisting>
                                     </informalexample>
                                 </listitem>
                             </varlistentry>
                         </variablelist>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-tdcresolution</option>
                         <replaceable>24ps | 49ps | 98ps | 195ps | 391ps | 781ps</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Just for your information, TDC resolution is calculated using the
                             raw register value with formula: 25ns/pow(2, 10-value)
                         </para>
                         <para>
                             By default, the value is <literal>24ps</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-adcresolution</option>
                         <replaceable>64k | 32k | 16k | 8k | 4k</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Just for your information, ADC resolution is calculated using the
                             raw register value with formula: pow(2, 6-value)k
                         </para>
                         <para>
                             By default, the value is <literal>64k</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-outputformat</option> <replaceable>0-3</replaceable></term>
                     <listitem>
                         <variablelist>
                             <varlistentry>
                               <term><literal>0</literal></term>
			       <listitem>
                                 <para>
                                     Time and long integral
                                 </para>
			       </listitem>
                             </varlistentry>
                             <varlistentry>
                               <term><literal>1</literal></term>
			       <listitem>
                                 <para>
                                     Long integral only (QDC mode)
                                 </para>
			       </listitem>
                             </varlistentry>
                             <varlistentry>
                               <term><literal>2</literal></term>
			       <listitem>
                                 <para>
                                     Time only (TDC mode)
                                 </para>
			       </listitem>
                             </varlistentry>
                             <varlistentry>
                               <term><literal>3</literal></term>
			       <listitem>
                                 <para>
                                     Long integral, short integral and time
                                 </para>
			       </listitem>
                             </varlistentry>
                         </variablelist>
                         <para>
                             By default, the value is <literal>3</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-windowstart</option> <replaceable>int 0-32767 (0-0x7fff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 documentation) Unit: 1.56 ns (=25ns/16)
                        </para>
                        <para>
                             Start window of interest: 0x0000 start at -25.56us, 0x7FFF start at +25.56us, 0x4000 = 16k no delay.
                        </para>
                        <para>
                             &lt; 16k, window starts before Trigger, &gt; 16k, window is delayed.
                        </para>
                        <para>
                             By default, this parameter is 0x3fbe(=16318).
                        </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-windowwidth</option> <replaceable>int 0-16383 (0-0x3fff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 documentation) Unit: 1.56 ns, max 16k = 25.56 us
                        </para>
                        <para>
                             By default, this parameter is 0x80(=128).
                        </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-firsthit</option> <replaceable>0 | 1</replaceable></term>
                     <listitem>
                         
                            <variablelist>
                                <varlistentry>
                                    <term><literal>0</literal></term>
                                    <listitem>
                                        <para>
                                            transmit all hits in the window
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term><literal>1</literal> (default)</term>
                                    <listitem>
                                        <para>
                                            only transmit first hit
                                        </para>
                                    </listitem>
                                </varlistentry>
                            </variablelist>
                    
                        
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-testpulser</option> <replaceable>0 | 1</replaceable></term>
                     <listitem>
                         <para>
                             Switch for the internal test pulser.
                        </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-pulseramplitude</option> <replaceable>int 0-4095 (0-0xfff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 documentation) Max value corresponds to about 30% at gain=1.
                             Gain jumpers are situated before pulser coupling,
                             so have no effect on the pulser amplitude.
                         </para>
                         <para>
                             This value has no effect unless <option>-testpulser</option> is set <literal>1</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-triggersource</option> <replaceable>int 0-1023 (0-0x3ff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 documentation) Defines the trigger which creates the window of interest.
                             This can be: one or both of the trigger inputs, lower 16 channels(B0), upper 16 channels(B1),
                             or both banks (all channels). 
                         </para>
                         <para>
                           MDPPTriggerControl GUI is included in the FRIBDAQ package. This value needs to be set to 0x400
                           to use the GUI controller. In this case, the last setting is preserved while start/stop runs.
                         </para>
                         <informalexample>
                             <programlisting>
+-------------------------------------------+
| Whole bank |    16 channels     |  trig   |
|   2 bits   |       6 bits       | 2 bits  |
+-------------------------------------------+
|  B1  | B0  | active | Chan[4:0] | T1 | T0 |
+-------------------------------------------+
                             </programlisting>
                         </informalexample>
                         <para>
                             The default value is 0x400.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-triggersource</option> <replaceable>int 0-1023 (0-0x3ff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 documentation) Defines the trigger which creates output trigger.
                             This can be: one or both of the trigger inputs, lower 16 channels(B0), upper 16 channels(B1),
                             or both banks (all channels). 
                         </para>
                         <para>
                           MDPPTriggerControl GUI is included in the FRIBDAQ package. This value needs to be set to 0x400
                           to use the GUI controller. In this case, the last setting is preserved while start/stop runs.
                         </para>
                         <informalexample>
                             <programlisting>
+-----------------------------------------+
| Whole bank |    16 channels     |   00  |
+-----------------------------------------+
|  B1  | B0  | active | Chan[4:0] | 0 | 0 |
+-----------------------------------------+
                             </programlisting>
                         </informalexample>
                         <para>
                             The default value is 0x400.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-monitoron</option>
                         <replaceable>bool</replaceable>
                     </term>
                     <listitem>
										 
                         <para>
                             Switch monitor on
                         </para>
                        </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-setmonitorch</option>
                         <replaceable>int 0-31</replaceable>
                     </term>
                     <listitem>
						
                         <para>
                             Set channel to monitor
                         </para>
					 </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-setwave</option>
                         <replaceable>int 0-3</replaceable>
                     </term>
                     <listitem>
										 
                         <para>
                             Set wave to monitior
                         </para>
					</listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-signalwidth</option>
                         <replaceable>int[8] 0-1023 (FWHM value in ns)</replaceable>
                     </term>
                     <listitem>
                         <para>
                             FWHM value of the input pulse in ns.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[4*index, 4*index+3]</literal>.
                         </para>
                         <para>
                             By default, the value is <literal>[list 20 20 20 20  20 20 20 20]</literal>,
                             which is 20ns for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-inputamplitude</option>
                         <replaceable>int[8] 0-65535 (mV)</replaceable>
                     </term>
                     <listitem>
                         <para>
                             0 to peak value of input pulse in mV. The amplitude cannot exceed the
                             jumper range provided by <option>-jumperrange</option> and the physical
                             jumper installed on the module.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[4*index, 4*index+3]</literal>.
                         </para>
                         <para>
                             By default, the value is
                             <literal>[list 1000 1000 1000 1000  1000 1000 1000 1000]</literal>,
                             which is 1000 mV for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-jumperrange</option>
                         <replaceable>int[8] 0-65535 (mV)</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Range printed on the jumper installed on the module in mV.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[4*index, 4*index+3]</literal>.
                         </para>
                         <para>
                             By default, the value is
                             <literal>[list 3000 3000 3000 3000  3000 3000 3000 3000]</literal>,
                             which is 3000 mV for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-qdcjumper</option> <replaceable>int[8] 0 | 1</replaceable></term>
                     <listitem>
                         <para>
                             Only used when QDC jumper is installed on the module.
                         </para>
                         <para>
                             (From MDPP-32 documentation) QDC jumpers give better amplitude resolution
                             and linearity if the signal width is less than 15ns.
                             The QDC jumpers have band width limit of 30MHz, so increase the width
                             of input pulses to about 25ns. They shouldn't be used for pulse shape
                             discrimination.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[4*index, 4*index+3]</literal>.
                         </para>
                         <para>
                             By default, the value is <literal>[list 0 0 0 0  0 0 0 0]</literal>,
                             which is 0 for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-intlong</option>
                         <replaceable>int[8] 2-506</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Input pulse integrating range from the time the pulse exceeds the threshold
                             in multiple of 12.5 ns.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[4*index, 4*index+3]</literal>.
                         </para>
                         <para>
                             By default, the value is <literal>[list 16 16 16 16  16 16 16 16]</literal>,
                             which is 16 (16*12.5=200ns) for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-intshort</option>
                         <replaceable>int[8] 1-127</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Input pulse integrating range from the time the pulse exceeds the threshold
                             in multiple of 12.5 ns. This value must be smaller than
                             <option>-intlong</option> value.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[4*index, 4*index+3]</literal>.
                         </para>
                         <para>
                             By default, the value is <literal>[list 2 2 2 2  2 2 2 2]</literal>,
                             which is 2 (2*12.5=25ns) for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-threshold</option> <replaceable>int[32] 0-65535</replaceable></term>
                     <listitem>
                         <para>
                         </para>
                         <para>
                             The parameter provided must be a list of 32 integers. Each element sets
                             the threshold to each channel.
                         </para>
                         <para>
                             By default, the value is
                             <literal>[list 0x4FF 0x4FF 0x4FF 0x4FF ... 0x4FF 0x4FF 0x4FF 0x4FF]</literal>,
                             which is 1279 (~1.95%) for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
<!--                 <varlistentry>
                     <term><option>-resettime</option> <replaceable></replaceable></term>
                     <listitem>
                         <para>

                         </para>
                     </listitem>
                 </varlistentry>-->
                 <varlistentry>
                     <term>
                         <option>-gaincorrectionlong</option>
                         <replaceable>string[8] none | div4  |mult4</replaceable>
                     </term>
                     <listitem>
                         <variablelist>
                             <varlistentry>
                               <term><literal>none</literal></term>
			       <listitem>
                                 <para>
                                     No change with the amplitude in a spectrum
                                 </para>
			       </listitem>
                             </varlistentry>
                             <varlistentry>
                               <term><literal>div4</literal></term>
			       <listitem>
                                 <para>
                                     Decrease the gain by the factor of 4 affecting the amplitude in a spectrum
                                 </para>
			       </listitem>
                             </varlistentry>
                             <varlistentry>
                               <term><literal>mult4</literal></term>
			       <listitem>
                                 <para>
                                     Increase the gain by the factor of 4 affecting the amplitude in a spectrum
                                 </para>
			       </listitem>
                             </varlistentry>
                         </variablelist>
                         <para>
                             (From MDPP-32 documentation) The internal gains and hardware gain are
                             calculated based on the signal width and amplitude. This should give a quite
                             good start value. Detais of the signals will have an effect on the real
                             amplitude. So, there are 2 scaling factors to correct the gains.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 strings.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[4*index, 4*index+3]</literal>.
                         </para>
                         <para>
                             By default, the value is
                             <literal>[list none none none none  none none none none]</literal>,
                             which is no change for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-gaincorrectionshort</option>
                         <replaceable>int[8] none | div4 | mult4</replaceable>
                     </term>
                     <listitem>
                         <para>
                             (From MDPP-32 documentation) The internal gains and hardware gain are
                             calculated based on the signal width and amplitude. This should give a quite
                             good start value. Detais of the signals will have an effect on the real
                             amplitude. So, there are 2 scaling factors to correct the gains.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-printregisters</option> <replaceable>0 | 1</replaceable></term>
                     <listitem>
                         <para>
                             Print out register values from the module. The values are not from the user input,
                             but from the actual register values read from the module after processing the input.
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </refsect1>
         <refsect1>
             <title>EXAMPLES</title>
             <example>
                 <title>Sample MDPP-32 QDC commands</title>
                 <programlisting>
set signalWidth         [list 100 16 16 16  16 16 16 16]
set inputAmplitude      [list 1000 2000 2000 2000  2000 2000 2000 2000]
set jumperRange         [list 2000 2000 2000 2000  2000 2000 2000 2000]
set qdcJumper           [list 0 0 0 0  0 0 0 0]
set integrationLong     [list 8 16 16 16  16 16 16 16]
set integrationShort    [list 2 2 2 2  2 2 2 2]
set threshold           [list 0xfff 0xfff 0xfff 0xfff  0xfff 0xfff 0xfff 0xfff \
                              0xfff 0xfff 0xfff 0xfff  0xfff 0xfff 0xfff 0xfff \
                              0xfff 0xfff 0xfff 0xfff  0xfff 0xfff 0xfff 0xfff \
                              0xfff 0xfff 0xfff 0xfff  0xfff 0xfff 0xfff 0xfff]
<!--set resetTime           [list 32 32 32 32  32 32 32 32]-->
set longGainCorrection  [list div4 none none none  none none none none]
set shortGainCorrection [list div4 none none none  none none none none]
set windowStart         16368
set windowWidth         32
set firstHit            1
set testPulser          1
set pulserAmplitude     400
set triggerSource       0x100
set triggerOutput       0x100
set monitorOn           0
set monitorCh           0
set monitorWave         0

mdpp32qdc create qdc -base 0x00030000
mdpp32qdc config qdc -signalwidth $signalWidth \
                     -inputamplitude $inputAmplitude \
                     -threshold $threshold \
                     -jumperrange $jumperRange \
                     -intshort $integrationShort \
                     -intlong $integrationLong \
                     -gaincorrectionlong $longGainCorrection \
                     -gaincorrectionshort $shortGainCorrection \
                     -windowstart $windowStart \
                     -windowwidth $windowWidth \
                     -firsthit $firstHit \
                     -testpulser $testPulser \
                     -pulseramplitude $pulserAmplitude \
                     -triggersource $triggerSource \
                     -triggeroutput $triggerOutput \
                     -monitoron $monitorOn \
                     -setmonitorch $monitorCh \
                     -setwave $monitorWave \
                     -printregisters 1
                 </programlisting>
             </example>
             <para>
                 Defines a module with base address <literal>0x00030000</literal>.
                 While many register values are defined with lists, not all of them are
                 used to configure the module (<literal>qdcJumper</literal>
                 is not used).
             </para>
             <para>
                 If any of the parameters are not specified in <literal>config</literal>,
                 it uses the default values. It is recommeneded only define variables
                 need to change and omit others for taking default values.
             </para>
         </refsect1>
     </refentry>

     <!--  mdpp16qdc command reference -->
     <refentry id="vmusb3-mdpp16qdc">
         <refentryinfo>
             <author>
                 <personname>
                     <firstname>Genie</firstname>
                     <surname>Jhang</surname>
                 </personname>
                 <personblurb><para></para></personblurb>
             </author>
             <productname>NSCLDAQ</productname>
             <productnumber></productnumber>
         </refentryinfo>
         <refmeta>
             <refentrytitle>mdpp16qdc</refentrytitle>
             <manvolnum>3vmusb</manvolnum>
             <refmiscinfo class='empty'></refmiscinfo>
         </refmeta>
         <refnamediv>
             <refname>mdpp16qdc</refname>
             <refpurpose>Mesytec MDPP-16 module with QDC firmware</refpurpose>
         </refnamediv>
         <refsynopsisdiv>
             <cmdsynopsis>
                 <command>
mdpp16qdc create <replaceable>name -base base [option1 value1 option2 value2 ...]</replaceable>
                 </command>
             </cmdsynopsis>
             <cmdsynopsis>
                 <command>
mdpp16qdc config <replaceable>name option value ...</replaceable>
                 </command>
             </cmdsynopsis>
             <cmdsynopsis>
                 <command>
mdpp16qdc cget <replaceable>name</replaceable>
                 </command>
             </cmdsynopsis>
         </refsynopsisdiv>
         <refsect1>
             <title>DESCRIPTION</title>
             <para>
                 This command creates, configures and retrieves the configuration of
                 Mesytec MDPP-16 module with QDC firmware.
             </para>
             <para>
                 Use the <command>create</command> subcommand to create a new module instance
                 providing it with a unique <parameter>name</parameter> that will
                 be used to identify it in future commands.  The <parameter>-base</parameter>
                 parameter is the base address of the module as set in the module rotary
                 switches. Options and corresponding values can be provided with the
                 <command>create</command> subcommand instead of using <command>config</command>
                 subcommand to configure.
             </para>
             <para>
                 Use the <command>config</command> subcommand to configure
                 a module named <parameter>name</parameter>  the <parameter>option</parameter>
                 options and legal values are described in the section OPTIONS below.
             </para>
             <para>
                 The <command>cget</command> subcommand returns as its value the configuration
                 of the module <parameter>name</parameter>.  The configuration is
                 returned as a list of two element sublists where each sublist
                 contains, in order, an option from OPTIONS below, and its value.
                 Note that some values may themselves be lists.
             </para>
         </refsect1>
         <refsect1>
             <title>
                 OPTIONS
             </title>
             <variablelist>
                 <varlistentry>
                     <term><option>-base</option> <replaceable>value</replaceable></term>
                     <listitem>
                         <para>
                             Allows you to reconfigure the base address of a module.
                             This defaults to <literal>0</literal>. The required
                             <parameter>-base</parameter> parameter of the create
                             option for this device overrides the default value.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-id</option> <replaceable>vsn</replaceable></term>
                     <listitem>
                         <para>
                             <parameter>vsn</parameter> will be used as the module's
                             identifier or <firstterm>virtual slot number</firstterm>.
                             The <parameter>vsn</parameter> will be encoded into the
                             event data that is returned by the module. This, in turn
                             is normally used by event decoders to determine which parameters
                             the channels of the module should be unpacked into.
                         </para>
                         <para>
                             Each module should be given a unique <parameter>vsn</parameter>.
                         </para>
                         <para>
                             By default, the value is <literal>0</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-ipl</option> <replaceable>0-7</replaceable></term>
                     <listitem>
                         <para>
                             The interrupt priority level the module should use to request
                             a VME bus interrupt. Normally interrupts will be used
                             to trigger an interrupt triggered stack.
                         </para>
                         <para>
                             By default, the value is <literal>0</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-vector</option> <replaceable>0-255</replaceable></term>
                     <listitem>
                         <para>
                             The interrupt vector the module should use. The vector value is ignored if
                             the module interrupts are disabled.
                         </para>
                         <para>
                             Note that the VMUSB processes 16 bit vectors, but the
                             vector produced by this module is 8 bits wide.
                             The VME standard is ambiguous about how such modules
                             produce the top eight bits of the vector under these
                             circumstances. Mesytec modules set those top bits
                             to 0xFF.  E.g. <option>-vector </option> <literal>0x80</literal>
                             produces a vector, as see by the VMUSB of <literal>0xFF80</literal>.
                             One important thing to note in this case is that one must pass
                             <option>-vector</option> option to the stack as <literal>0xFF80</literal>
                             to use interrupt-triggered stack. <literal>0x0080</literal> won't work.
                         </para>
                         <para>
                             By default, the value is <literal>0</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-irqeventthreshold</option> <replaceable>0-32767</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-16 QDC documentation) Every time the number of events in the FIFO
                             exceeds this threshold, an IRQ is emitted.
                         </para>
                         <para>
                             The register length is 15 bit. Thus, the maximum number it can take should be
                             <literal>0x3FFF (32757)</literal>
                         </para>
                         <para>
                             By default, the value is <literal>3</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-irqdatathreshold</option> <replaceable>0-32256</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-16 QDC documentation) Every time the number of 32 bit words in
                             the FIFO exceeds this threshold, an IRQ is emitted. Maximum allowed threshold
                             is "FIFO size".
                         </para>
                         <para>
                             "FIFO size" in the QDC documentation is 32k-512=32256.
                         </para>
                         <para>
                             By default, the value is <literal>1</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-irqsource</option> <replaceable>event|data</replaceable></term>
                     <listitem>
                         <variablelist>
                             <varlistentry>
                                 <term><literal>event</literal></term>
                                 <listitem>
                                     <para>
                                         Use the value provided with <option>-irqeventthreshold</option> as
                                         the IRQ threshold.
                                     </para>
                                 </listitem>
                             </varlistentry>
                             <varlistentry>
                                 <term><literal>data</literal></term>
                                 <listitem>
                                     <para>
                                         Use the value provided with <option>-irqdatathreshold</option> as
                                         the IRQ threshold.
                                     </para>
				     
                                 </listitem>
                             </varlistentry>
                         </variablelist>
                         <para>
                           By default, the value is <literal>event</literal>
                         </para>

                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-maxtransfer</option> <replaceable>0-32256</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-16 QDC documentation) With
                             "<option>-multievent</option> <literal>3</literal>", the value specifies
                             the amount of data read from FIFO before Berr is emitted. Transfer stops
                             only after full events.
                         </para>
                         <para>
                             e.g. With "<option>-maxtransfer</option> <literal>1</literal>", 1 event
                             per transfer is emitted.
                         </para>
                         <para>
                             With "<option>-multievent</option> <literal>0xb</literal>", the value specifies
                             the number of events read from FIFO before Berr is emitted.
                         </para>
                         <para>
                             Setting this option to <literal>0</literal> allows unlimited transfer.
                         </para>
                         <para>
                             By default, the value is <literal>1</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-datalenformat</option>
                         <replaceable>8bit | 16bit | 32bit | 64bit | numevents</replaceable>
                     </term>
                     <listitem>
                         <variablelist>
                             <varlistentry>
                               <term><literal>numevents</literal></term>
			       <listitem>
                                 <para>Show number of events in FIFO</para>
			       </listitem>
                             </varlistentry>
                         </variablelist>
                         <para>
                             (From MDPP-16 QDC documnetation) The number of 32 bit words is always even.
                             If necessary the fill word "0" is added. For the setting <literal>0</literal>
                             and <literal>1</literal>, the max value <literal>0xFFFF</literal> is shown
                             when number exceeds the 16 bit format. The FIFO is not affected.
                         </para>
                         <para>
                             By default, the value is <literal>32bit</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-multievent</option> <replaceable>See detail</replaceable></term>
                     <listitem>
                         <para>
                             By default, the value is <literal>0xb</literal>.
                         </para>
                         <informalexample>
                             <programlisting>
+-----------------------------------------+
|     Bit[3]     |   Bit[2]   | Bit[1:0]  |
+-----------------------------------------+
|  count events  | skip Berr, | mode[1:0] |
|   not words    | send EOB   |           |
| (reg. 0x601A)  |            |           |
+-----------------------------------------+
                             </programlisting>
                         </informalexample>
                         <variablelist>
                             <varlistentry>
                                 <term><literal>Bit[1:0]</literal></term>
                                 <listitem>
                                     <para>
                                         (From MDPP-16 QDC documentation)
                                     </para>
                                     <para>
                                         Allow multi event buffering.
                                     </para>
                                     <variablelist>
                                         <varlistentry>
                                             <term><literal>0</literal></term>
                                             <listitem>
                                                 <para>
                                                     Not allowing multi event buffering
                                                 </para>
                                                 <para>
                                                     Register <literal>0x6034</literal> clears events
                                                     allowing new conversion.
                                                 </para>
                                             </listitem>
                                         </varlistentry>
                                         <varlistentry>
                                             <term><literal>1</literal></term>
                                             <listitem>
                                                 <para>
                                                     Allowing multi event buffering
                                                 </para>
                                                 <para>
                                                     Unlimited transfer. No readout reset required.
                                                     Register <literal>0x6034</literal> can be written
                                                    after block readout. Don't use for CBLT.
                                                 </para>
                                             </listitem>
                                         </varlistentry>
                                         <varlistentry>
                                             <term><literal>3</literal></term>
                                             <listitem>
                                                 <para>
                                                     Allowing multi event buffering, but MDPP transfers
                                                     limited amount of data.
                                                 </para>
                                                 <para>
                                                     The number of data words can be specified via
                                                     register <literal>0x601A</literal> After word limit is
                                                     reached, the next end of event mark terminates transfer
                                                     by emitting Berr. So, register <literal>0x601A</literal>=1
                                                     means event by event transfer (Berr after each event).
                                                 </para>
                                                 <para>
                                                     The next data block can be transferred after writing
                                                     the register <literal>0x6034</literal> (resets Berr).
                                                 </para>
                                             </listitem>
                                         </varlistentry>
                                     </variablelist>
                                 </listitem>
                             </varlistentry>
                             <varlistentry>
                                 <term><literal>Bit[2]</literal></term>
                                 <listitem>
                                     <para>
                                         Berr handling. If set, send <literal>EOB=bit[31:30]=bx10</literal>
                                         instead of Berr.
                                     </para>
                                 </listitem>
                             </varlistentry>
                             <varlistentry>
                                 <term><literal>Bit[3]</literal></term>
                                 <listitem>
                                     <para>
                                         Compare number of transmitted events (not words!) with the register
                                         <literal>0x601A</literal> value (<option>-maxtransfer</option> value)
                                         for Berr condition.
                                     </para>
                                 </listitem>
                             </varlistentry>
                         </variablelist>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-marktype</option>
                         <replaceable>eventcount | timestamp | extended-timestamp</replaceable>
                     </term>
                     <listitem>
                         <para>
                             By default, the value is <literal>timestamp</literal>.
                         </para>
                         <variablelist>
                             <varlistentry>
                                 <term><literal>eventcount</literal></term>
                                 <term><literal>timestamp</literal></term>
                                 <listitem>
                                     <para>
                                         The last 32 bit word in the data contains either event counts
                                         or timestamp according to the setting.
                                     </para>
                                     <informalexample>
                                         <programlisting>
+------------------------------+
|  2  |           30           |
+------------------------------+
| b11 | eventcount / timestamp |
+------------------------------+
                                         </programlisting>
                                     </informalexample>
                                 </listitem>
                             </varlistentry>
                             <varlistentry>
                                 <term><literal>extended-timestamp</literal></term>
                                 <listitem>
                                     <para>
                                         Following 32 bit word will be added to the data.
                                     </para>
                                     <informalexample>
                                         <programlisting>
+------------------------------------------------------+
|  2  |  2  |       12       |           16            |
+------------------------------------------------------+
| b00 | b10 | xxxx xxxx xxxx | 16 high bits time stamp |
+------------------------------------------------------+
                                         </programlisting>
                                     </informalexample>
                                 </listitem>
                             </varlistentry>
                         </variablelist>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-tdcresolution</option>
                         <replaceable>24ps | 49ps | 98ps | 195ps | 391ps | 781ps</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Just for your information, TDC resolution is calculated using the
                             raw register value with formula: 25ns/pow(2, 10-value)
                         </para>
                         <para>
                             By default, the value is <literal>24ps</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-adcresolution</option>
                         <replaceable>64k | 32k | 16k | 8k | 4k</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Just for your information, ADC resolution is calculated using the
                             raw register value with formula: pow(2, 6-value)k
                         </para>
                         <para>
                             By default, the value is <literal>64k</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-outputformat</option> <replaceable>0-3</replaceable></term>
                     <listitem>
                         <variablelist>
                             <varlistentry>
                               <term><literal>0</literal></term>
			       <listitem>
                                 <para>
                                     Time and long integral
                                 </para>
			       </listitem>
                             </varlistentry>
                             <varlistentry>
                               <term><literal>1</literal></term>
			       <listitem>
                                 <para>
                                     Long integral only (QDC mode)
                                 </para>
			       </listitem>
                             </varlistentry>
                             <varlistentry>
                               <term><literal>2</literal></term>
			       <listitem>
                                 <para>
                                     Time only (TDC mode)
                                 </para>
			       </listitem>
                             </varlistentry>
                             <varlistentry>
                               <term><literal>3</literal></term>
			       <listitem>
                                 <para>
                                     Long integral, short integral and time
                                 </para>
			       </listitem>
                             </varlistentry>
                         </variablelist>
                         <para>
                             By default, the value is <literal>3</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-windowstart</option> <replaceable>int 0-32767 (0-0x7fff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-16 documentation) Unit: 1.56 ns (=25ns/16)
                        </para>
                        <para>
                             Start window of interest: 0x0000 start at -25.56us, 0x7FFF start at +25.56us, 0x4000 = 16k no delay.
                        </para>
                        <para>
                             &lt; 16k, window starts before Trigger, &gt; 16k, window is delayed.
                        </para>
                        <para>
                             By default, this parameter is 0x3fbe(=16318).
                        </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-windowwidth</option> <replaceable>int 0-16383 (0-0x3fff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-16 documentation) Unit: 1.56 ns, max 16k = 25.56 us
                        </para>
                        <para>
                             By default, this parameter is 0x80(=128).
                        </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-firsthit</option> <replaceable>0 | 1</replaceable></term>
                     <listitem>
                         
                            <variablelist>
                                <varlistentry>
                                    <term><literal>0</literal></term>
                                    <listitem>
                                        <para>
                                            transmit all hits in the window
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term><literal>1</literal> (default)</term>
                                    <listitem>
                                        <para>
                                            only transmit first hit
                                        </para>
                                    </listitem>
                                </varlistentry>
                            </variablelist>
                    
                        
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-testpulser</option> <replaceable>0 | 1</replaceable></term>
                     <listitem>
                         <para>
                             Switch for the internal test pulser.
                        </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-pulseramplitude</option> <replaceable>int 0-4095 (0-0xfff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-16 documentation) Max value corresponds to about 30% at gain=1.
                             Gain jumpers are situated before pulser coupling,
                             so have no effect on the pulser amplitude.
                         </para>
                         <para>
                             This value has no effect unless <option>-testpulser</option> is set <literal>1</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-triggersource</option> <replaceable>int 0-1023 (0-0x3ff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-16 documentation) Defines the trigger which creates the window of interest.
                             This can be: one or both of the trigger inputs, lower 16 channels(B0), upper 16 channels(B1),
                             or both banks (all channels). 
                         </para>
                         <para>
                           MDPPTriggerControl GUI is included in the FRIBDAQ package. This value needs to be set to 0x400
                           to use the GUI controller. In this case, the last setting is preserved while start/stop runs.
                         </para>
                         <informalexample>
                             <programlisting>
+-------------------------------------------+
| Whole bank |    16 channels     |  trig   |
|   2 bits   |       6 bits       | 2 bits  |
+-------------------------------------------+
|  B1  | B0  | active | Chan[4:0] | T1 | T0 |
+-------------------------------------------+
                             </programlisting>
                         </informalexample>
                         <para>
                             The default value is 0x400.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-triggersource</option> <replaceable>int 0-1023 (0-0x3ff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-16 documentation) Defines the trigger which creates output trigger.
                             This can be: one or both of the trigger inputs, lower 16 channels(B0), upper 16 channels(B1),
                             or both banks (all channels). 
                         </para>
                         <para>
                           MDPPTriggerControl GUI is included in the FRIBDAQ package. This value needs to be set to 0x400
                           to use the GUI controller. In this case, the last setting is preserved while start/stop runs.
                         </para>
                         <informalexample>
                             <programlisting>
+-----------------------------------------+
| Whole bank |    16 channels     |   00  |
+-----------------------------------------+
|  B1  | B0  | active | Chan[4:0] | 0 | 0 |
+-----------------------------------------+
                             </programlisting>
                         </informalexample>
                         <para>
                             The default value is 0x400.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-monitoron</option>
                         <replaceable>bool</replaceable>
                     </term>
                     <listitem>
										 
                         <para>
                             Switch monitor on
                         </para>
										 </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-setmonitorch</option>
                         <replaceable>int 0-31</replaceable>
                     </term>
                     <listitem>
										 
                         <para>
                             Set channel to monitor
                         </para>
										 </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-setwave</option>
                         <replaceable>int 0-3</replaceable>
                     </term>
                     <listitem>
										 
                         <para>
                             Set wave to monitior
                         </para>
										 </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-signalwidth</option>
                         <replaceable>int[8] 0-1023 (FWHM value in ns)</replaceable>
                     </term>
                     <listitem>
                         <para>
                             FWHM value of the input pulse in ns.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[2*index, 2*index+1]</literal>.
                         </para>
                         <para>
                             By default, the value is <literal>[list 20 20 20 20  20 20 20 20]</literal>,
                             which is 20ns for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-inputamplitude</option>
                         <replaceable>int[8] 0-65535 (mV)</replaceable>
                     </term>
                     <listitem>
                         <para>
                             0 to peak value of input pulse in mV. The amplitude cannot exceed the
                             jumper range provided by <option>-jumperrange</option> and the physical
                             jumper installed on the module.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[2*index, 2*index+1]</literal>.
                         </para>
                         <para>
                             By default, the value is
                             <literal>[list 1000 1000 1000 1000  1000 1000 1000 1000]</literal>,
                             which is 1000 mV for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-jumperrange</option>
                         <replaceable>int[8] 0-65535 (mV)</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Range printed on the jumper installed on the module in mV.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[2*index, 2*index+1]</literal>.
                         </para>
                         <para>
                             By default, the value is
                             <literal>[list 3000 3000 3000 3000  3000 3000 3000 3000]</literal>,
                             which is 3000 mV for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-qdcjumper</option> <replaceable>int[8] 0 | 1</replaceable></term>
                     <listitem>
                         <para>
                             Only used when QDC jumper is installed on the module.
                         </para>
                         <para>
                             (From MDPP-16 documentation) QDC jumpers give better amplitude resolution
                             and linearity if the signal width is less than 15ns.
                             The QDC jumpers have band width limit of 30MHz, so increase the width
                             of input pulses to about 25ns. They shouldn't be used for pulse shape
                             discrimination.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[2*index, 2*index+1]</literal>.
                         </para>
                         <para>
                             By default, the value is <literal>[list 0 0 0 0  0 0 0 0]</literal>,
                             which is 0 for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-intlong</option>
                         <replaceable>int[8] 2-506</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Input pulse integrating range from the time the pulse exceeds the threshold
                             in multiple of 12.5 ns.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[2*index, 2*index+1]</literal>.
                         </para>
                         <para>
                             By default, the value is <literal>[list 16 16 16 16  16 16 16 16]</literal>,
                             which is 16 (16*12.5=200ns) for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-intshort</option>
                         <replaceable>int[8] 1-127</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Input pulse integrating range from the time the pulse exceeds the threshold
                             in multiple of 12.5 ns. This value must be smaller than
                             <option>-intlong</option> value.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[2*index, 2*index+1]</literal>.
                         </para>
                         <para>
                             By default, the value is <literal>[list 2 2 2 2  2 2 2 2]</literal>,
                             which is 2 (2*12.5=25ns) for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-threshold</option> <replaceable>int[32] 0-65535</replaceable></term>
                     <listitem>
                         <para>
                         </para>
                         <para>
                             The parameter provided must be a list of 32 integers. Each element sets
                             the threshold to each channel.
                         </para>
                         <para>
                             By default, the value is
                             <literal>[list 0x4FF 0x4FF 0x4FF 0x4FF ... 0x4FF 0x4FF 0x4FF 0x4FF]</literal>,
                             which is 1279 (~1.95%) for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
<!--                 <varlistentry>
                     <term><option>-resettime</option> <replaceable></replaceable></term>
                     <listitem>
                         <para>

                         </para>
                     </listitem>
                 </varlistentry>-->
                 <varlistentry>
                     <term>
                         <option>-gaincorrectionlong</option>
                         <replaceable>string[8] none | div4  |mult4</replaceable>
                     </term>
                     <listitem>
                         <variablelist>
                             <varlistentry>
                               <term><literal>none</literal></term>
			       <listitem>
                                 <para>
                                     No change with the amplitude in a spectrum
                                 </para>
			       </listitem>
                             </varlistentry>
                             <varlistentry>
                               <term><literal>div4</literal></term>
			       <listitem>
                                 <para>
                                     Decrease the gain by the factor of 4 affecting the amplitude in a spectrum
                                 </para>
			       </listitem>
                             </varlistentry>
                             <varlistentry>
                               <term><literal>mult4</literal></term>
			       <listitem>
                                 <para>
                                     Increase the gain by the factor of 4 affecting the amplitude in a spectrum
                                 </para>
			       </listitem>
                             </varlistentry>
                         </variablelist>
                         <para>
                             (From MDPP-16 documentation) The internal gains and hardware gain are
                             calculated based on the signal width and amplitude. This should give a quite
                             good start value. Detais of the signals will have an effect on the real
                             amplitude. So, there are 2 scaling factors to correct the gains.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 strings.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the two channels <literal>[2*index, 2*index+1]</literal>.
                         </para>
                         <para>
                             By default, the value is
                             <literal>[list none none none none  none none none none]</literal>,
                             which is no change for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-gaincorrectionshort</option>
                         <replaceable>int[8] none | div4 | mult4</replaceable>
                     </term>
                     <listitem>
                         <para>
                             (From MDPP-16 documentation) The internal gains and hardware gain are
                             calculated based on the signal width and amplitude. This should give a quite
                             good start value. Detais of the signals will have an effect on the real
                             amplitude. So, there are 2 scaling factors to correct the gains.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-printregisters</option> <replaceable>0 | 1</replaceable></term>
                     <listitem>
                         <para>
                             Print out register values from the module. The values are not from the user input,
                             but from the actual register values read from the module after processing the input.
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </refsect1>
         <refsect1>
             <title>EXAMPLES</title>
             <example>
                 <title>Sample MDPP-16 QDC commands</title>
                 <programlisting>
set signalWidth         [list 100 16 16 16  16 16 16 16]
set inputAmplitude      [list 1000 2000 2000 2000  2000 2000 2000 2000]
set jumperRange         [list 2000 2000 2000 2000  2000 2000 2000 2000]
set qdcJumper           [list 0 0 0 0  0 0 0 0]
set integrationLong     [list 8 16 16 16  16 16 16 16]
set integrationShort    [list 2 2 2 2  2 2 2 2]
set threshold           [list 0xfff 0xfff 0xfff 0xfff  0xfff 0xfff 0xfff 0xfff \
                              0xfff 0xfff 0xfff 0xfff  0xfff 0xfff 0xfff 0xfff \
                              0xfff 0xfff 0xfff 0xfff  0xfff 0xfff 0xfff 0xfff \
                              0xfff 0xfff 0xfff 0xfff  0xfff 0xfff 0xfff 0xfff]
<!--set resetTime           [list 32 32 32 32  32 32 32 32]-->
set longGainCorrection  [list div4 none none none  none none none none]
set shortGainCorrection [list div4 none none none  none none none none]
set windowStart         16368
set windowWidth         32
set firstHit            1
set testPulser          1
set pulserAmplitude     400
set triggerSource       0x100
set triggerOutput       0x100
set monitorOn           0
set monitorCh           0
set monitorWave         0

mdpp16qdc create qdc -base 0x00030000
mdpp16qdc config qdc -signalwidth $signalWidth \
                     -inputamplitude $inputAmplitude \
                     -threshold $threshold \
                     -jumperrange $jumperRange \
                     -intshort $integrationShort \
                     -intlong $integrationLong \
                     -gaincorrectionlong $longGainCorrection \
                     -gaincorrectionshort $shortGainCorrection \
                     -windowstart $windowStart \
                     -windowwidth $windowWidth \
                     -firsthit $firstHit \
                     -testpulser $testPulser \
                     -pulseramplitude $pulserAmplitude \
                     -triggersource $triggerSource \
                     -triggeroutput $triggerOutput \
                     -monitoron $monitorOn \
                     -setmonitorch $monitorCh \
                     -setwave $monitorWave \
                     -printregisters 1
                 </programlisting>
             </example>
             <para>
                 Defines a module with base address <literal>0x00030000</literal>.
                 While many register values are defined with lists, not all of them are
                 used to configure the module (<literal>qdcJumper</literal>
                 is not used).
             </para>
             <para>
                 If any of the parameters are not specified in <literal>config</literal>,
                 it uses the default values. It is recommeneded only define variables
                 need to change and omit others for taking default values.
             </para>
         </refsect1>
     </refentry>

     <!--  mdpp32scp command reference -->
     <refentry id="vmusb3-mdpp32scp">
         <refentryinfo>
             <author>
                 <personname>
                     <firstname>Genie</firstname>
                     <surname>Jhang</surname>
                 </personname>
                 <personblurb><para></para></personblurb>
             </author>
             <productname>NSCLDAQ</productname>
             <productnumber></productnumber>
         </refentryinfo>
         <refmeta>
             <refentrytitle>mdpp32scp</refentrytitle>
             <manvolnum>3vmusb</manvolnum>
             <refmiscinfo class='empty'></refmiscinfo>
         </refmeta>
         <refnamediv>
             <refname>mdpp32scp</refname>
             <refpurpose>Mesytec MDPP-32 module with SCP firmware</refpurpose>
         </refnamediv>
         <refsynopsisdiv>
             <cmdsynopsis>
                 <command>
mdpp32scp create <replaceable>name -base base [option1 value1 option2 value2 ...]</replaceable>
                 </command>
             </cmdsynopsis>
             <cmdsynopsis>
                 <command>
mdpp32scp config <replaceable>name option value ...</replaceable>
                 </command>
             </cmdsynopsis>
             <cmdsynopsis>
                 <command>
mdpp32scp cget <replaceable>name</replaceable>
                 </command>
             </cmdsynopsis>
         </refsynopsisdiv>
         <refsect1>
             <title>DESCRIPTION</title>
             <para>
                 This command creates, configures and retrieves the configuration of
                 Mesytec MDPP-32 module with SCP firmware.
             </para>
             <para>
                 Use the <command>create</command> subcommand to create a new module instance
                 providing it with a unique <parameter>name</parameter> that will
                 be used to identify it in future commands.  The <parameter>-base</parameter>
                 parameter is the base address of the module as set in the module rotary
                 switches. Options and corresponding values can be provided with the
                 <command>create</command> subcommand instead of using <command>config</command>
                 subcommand to configure.
             </para>
             <para>
                 Use the <command>config</command> subcommand to configure
                 a module named <parameter>name</parameter>  the <parameter>option</parameter>
                 options and legal values are described in the section OPTIONS below.
             </para>
             <para>
                 The <command>cget</command> subcommand returns as its value the configuration
                 of the module <parameter>name</parameter>.  The configuration is
                 returned as a list of two element sublists where each sublist
                 contains, in order, an option from OPTIONS below, and its value.
                 Note that some values may themselves be lists.
             </para>
         </refsect1>
         <refsect1>
             <title>
                 OPTIONS
             </title>
             <variablelist>
                 <varlistentry>
                     <term><option>-base</option> <replaceable>value</replaceable></term>
                     <listitem>
                         <para>
                             Allows you to reconfigure the base address of a module.
                             This defaults to <literal>0</literal>. The required
                             <parameter>-base</parameter> parameter of the create
                             option for this device overrides the default value.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-id</option> <replaceable>vsn</replaceable></term>
                     <listitem>
                         <para>
                             <parameter>vsn</parameter> will be used as the module's
                             identifier or <firstterm>virtual slot number</firstterm>.
                             The <parameter>vsn</parameter> will be encoded into the
                             event data that is returned by the module. This, in turn
                             is normally used by event decoders to determine which parameters
                             the channels of the module should be unpacked into.
                         </para>
                         <para>
                             Each module should be given a unique <parameter>vsn</parameter>.
                         </para>
                         <para>
                             By default, the value is <literal>0</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-ipl</option> <replaceable>0-7</replaceable></term>
                     <listitem>
                         <para>
                             The interrupt priority level the module should use to request
                             a VME bus interrupt. Normally interrupts will be used
                             to trigger an interrupt triggered stack.
                         </para>
                         <para>
                             By default, the value is <literal>0</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-vector</option> <replaceable>0-255</replaceable></term>
                     <listitem>
                         <para>
                             The interrupt vector the module should use. The vector value is ignored if
                             the module interrupts are disabled.
                         </para>
                         <para>
                             Note that the VMUSB processes 16 bit vectors, but the
                             vector produced by this module is 8 bits wide.
                             The VME standard is ambiguous about how such modules
                             produce the top eight bits of the vector under these
                             circumstances. Mesytec modules set those top bits
                             to 0xFF.  E.g. <option>-vector </option> <literal>0x80</literal>
                             produces a vector, as see by the VMUSB of <literal>0xFF80</literal>.
                             One important thing to note in this case is that one must pass
                             <option>-vector</option> option to the stack as <literal>0xFF80</literal>
                             to use interrupt-triggered stack. <literal>0x0080</literal> won't work.
                         </para>
                         <para>
                             By default, the value is <literal>0</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-irqeventthreshold</option> <replaceable>0-32767</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 SCP documentation) Every time the number of events in the FIFO
                             exceeds this threshold, an IRQ is emitted.
                         </para>
                         <para>
                             The register length is 15 bit. Thus, the maximum number it can take should be
                             <literal>0x3FFF (32757)</literal>
                         </para>
                         <para>
                             By default, the value is <literal>3</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-irqdatathreshold</option> <replaceable>0-32256</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 SCP documentation) Every time the number of 32 bit words in
                             the FIFO exceeds this threshold, an IRQ is emitted. Maximum allowed threshold
                             is "FIFO size".
                         </para>
                         <para>
                             "FIFO size" in the SCP documentation is 32k-512=32256.
                         </para>
                         <para>
                             By default, the value is <literal>1</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-irqsource</option> <replaceable>event|data</replaceable></term>
                     <listitem>
                         <variablelist>
                             <varlistentry>
                                 <term><literal>event</literal></term>
                                 <listitem>
                                     <para>
                                         Use the value provided with <option>-irqeventthreshold</option> as
                                         the IRQ threshold.
                                     </para>
                                 </listitem>
                             </varlistentry>
                             <varlistentry>
                                 <term><literal>data</literal></term>
                                 <listitem>
                                     <para>
                                         Use the value provided with <option>-irqdatathreshold</option> as
                                         the IRQ threshold.
                                     </para>
				     
                                 </listitem>
                             </varlistentry>
                         </variablelist>
			 <para>
                           By default, the value is <literal>event</literal>
                         </para>

                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-maxtransfer</option> <replaceable>0-32256</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 SCP documentation) With
                             "<option>-multievent</option> <literal>3</literal>", the value specifies
                             the amount of data read from FIFO before Berr is emitted. Transfer stops
                             only after full events.
                         </para>
                         <para>
                             e.g. With "<option>-maxtransfer</option> <literal>1</literal>", 1 event
                             per transfer is emitted.
                         </para>
                         <para>
                             With "<option>-multievent</option> <literal>0xb</literal>", the value specifies
                             the number of events read from FIFO before Berr is emitted.
                         </para>
                         <para>
                             Setting this option to <literal>0</literal> allows unlimited transfer.
                         </para>
                         <para>
                             By default, the value is <literal>1</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-multievent</option> <replaceable>See detail</replaceable></term>
                     <listitem>
                         <para>
                             By default, the value is <literal>0xb</literal>.
                         </para>
                         <informalexample>
                             <programlisting>
+-----------------------------------------+
|     Bit[3]     |   Bit[2]   | Bit[1:0]  |
+-----------------------------------------+
|  count events  | skip Berr, | mode[1:0] |
|   not words    | send EOB   |           |
| (reg. 0x601A)  |            |           |
+-----------------------------------------+
                             </programlisting>
                         </informalexample>
                         <variablelist>
                             <varlistentry>
                                 <term><literal>Bit[1:0]</literal></term>
                                 <listitem>
                                     <para>
                                         (From MDPP-32 SCP documentation)
                                     </para>
                                     <para>
                                         Allow multi event buffering.
                                     </para>
                                     <variablelist>
                                         <varlistentry>
                                             <term><literal>0</literal></term>
                                             <listitem>
                                                 <para>
                                                     Not allowing multi event buffering
                                                 </para>
                                                 <para>
                                                     Register <literal>0x6034</literal> clears events
                                                     allowing new conversion.
                                                 </para>
                                             </listitem>
                                         </varlistentry>
                                         <varlistentry>
                                             <term><literal>1</literal></term>
                                             <listitem>
                                                 <para>
                                                     Allowing multi event buffering
                                                 </para>
                                                 <para>
                                                     Unlimited transfer. No readout reset required.
                                                     Register <literal>0x6034</literal> can be written
                                                    after block readout. Don't use for CBLT.
                                                 </para>
                                             </listitem>
                                         </varlistentry>
                                         <varlistentry>
                                             <term><literal>3</literal></term>
                                             <listitem>
                                                 <para>
                                                     Allowing multi event buffering, but MDPP transfers
                                                     limited amount of data.
                                                 </para>
                                                 <para>
                                                     The number of data words can be specified via
                                                     register <literal>0x601A</literal> After word limit is
                                                     reached, the next end of event mark terminates transfer
                                                     by emitting Berr. So, register <literal>0x601A</literal>=1
                                                     means event by event transfer (Berr after each event).
                                                 </para>
                                                 <para>
                                                     The next data block can be transferred after writing
                                                     the register <literal>0x6034</literal> (resets Berr).
                                                 </para>
                                             </listitem>
                                         </varlistentry>
                                     </variablelist>
                                 </listitem>
                             </varlistentry>
                             <varlistentry>
                                 <term><literal>Bit[2]</literal></term>
                                 <listitem>
                                     <para>
                                         Berr handling. If set, send <literal>EOB=bit[31:30]=bx10</literal>
                                         instead of Berr.
                                     </para>
                                 </listitem>
                             </varlistentry>
                             <varlistentry>
                                 <term><literal>Bit[3]</literal></term>
                                 <listitem>
                                     <para>
                                         Compare number of transmitted events (not words!) with the register
                                         <literal>0x601A</literal> value (<option>-maxtransfer</option> value)
                                         for Berr condition.
                                     </para>
                                 </listitem>
                             </varlistentry>
                         </variablelist>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-marktype</option>
                         <replaceable>eventcount | timestamp | extended-timestamp</replaceable>
                     </term>
                     <listitem>
                         <para>
                             By default, the value is <literal>timestamp</literal>.
                         </para>
                         <variablelist>
                             <varlistentry>
                                 <term><literal>eventcount</literal></term>
                                 <term><literal>timestamp</literal></term>
                                 <listitem>
                                     <para>
                                         The last 32 bit word in the data contains either event counts
                                         or timestamp according to the setting.
                                     </para>
                                     <informalexample>
                                         <programlisting>
+------------------------------+
|  2  |           30           |
+------------------------------+
| b11 | eventcount / timestamp |
+------------------------------+
                                         </programlisting>
                                     </informalexample>
                                 </listitem>
                             </varlistentry>
                             <varlistentry>
                                 <term><literal>extended-timestamp</literal></term>
                                 <listitem>
                                     <para>
                                         Following 32 bit word will be added to the data.
                                     </para>
                                     <informalexample>
                                         <programlisting>
+------------------------------------------------------+
|  2  |  2  |       12       |           16            |
+------------------------------------------------------+
| b00 | b10 | xxxx xxxx xxxx | 16 high bits time stamp |
+------------------------------------------------------+
                                         </programlisting>
                                     </informalexample>
                                 </listitem>
                             </varlistentry>
                         </variablelist>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-tdcresolution</option>
                         <replaceable>24ps | 49ps | 98ps | 195ps | 391ps | 781ps</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Just for your information, TDC resolution is calculated using the
                             raw register value with formula: 25ns/pow(2, 10-value)
                         </para>
                         <para>
                             By default, the value is <literal>24ps</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-outputformat</option> <replaceable>0-2</replaceable></term>
                     <listitem>
                         <variablelist>
                             <varlistentry>
                               <term><literal>0</literal></term>
			       <listitem>
                                 <para>
                                     Standard (time and amplitude)
                                 </para>
			       </listitem>
                             </varlistentry>
                             <varlistentry>
                               <term><literal>1</literal></term>
			       <listitem>
                                 <para>
                                     Amplitude only
                                 </para>
			       </listitem>
                             </varlistentry>
                             <varlistentry>
                               <term><literal>2</literal></term>
			       <listitem>
                                 <para>
                                     Time only
                                 </para>
			       </listitem>
                             </varlistentry>
                         </variablelist>
                         <para>
                             By default, the value is <literal>0</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-windowstart</option> <replaceable>int 0-32767 (0-0x7fff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 documentation) Unit: 1.56 ns (=25ns/16)
                        </para>
                        <para>
                             Start window of interest: 0x0000 start at -25.56us, 0x7FFF start at +25.56us, 0x4000 = 16k no delay.
                        </para>
                        <para>
                             &lt; 16k, window starts before Trigger, &gt; 16k, window is delayed.
                        </para>
                        <para>
                             By default, this parameter is 0x3fbe(=16318).
                        </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-windowwidth</option> <replaceable>int 0-16383 (0-0x3fff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 documentation) Unit: 1.56 ns, max 16k = 25.56 us
                        </para>
                        <para>
                             By default, this parameter is 0x20(=32).
                        </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-firsthit</option> <replaceable>0 | 1</replaceable></term>
                     <listitem>
                         
                            <variablelist>
                                <varlistentry>
                                    <term><literal>0</literal></term>
                                    <listitem>
                                        <para>
                                            transmit all hits in the window
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term><literal>1</literal> (default)</term>
                                    <listitem>
                                        <para>
                                            only transmit first hit
                                        </para>
                                    </listitem>
                                </varlistentry>
                            </variablelist>
                    
                        
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-testpulser</option> <replaceable>0 | 1</replaceable></term>
                     <listitem>
                         <para>
                             Switch for the internal test pulser.
                        </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-pulseramplitude</option> <replaceable>int 0-4095 (0-0xfff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 documentation) Max value corresponds to about 30% at gain=1.
                             Gain jumpers are situated before pulser coupling,
                             so have no effect on the pulser amplitude.
                         </para>
                         <para>
                             This value has no effect unless <option>-testpulser</option> is set <literal>1</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-triggersource</option> <replaceable>int 0-1023 (0-0x3ff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 documentation) Defines the trigger which creates the window of interest.
                             This can be: one or both of the trigger inputs, lower 16 channels(B0), upper 16 channels(B1),
                             or both banks (all channels). 
                         </para>
                         <para>
                           MDPPTriggerControl GUI is included in the FRIBDAQ package. This value needs to be set to 0x400
                           to use the GUI controller. In this case, the last setting is preserved while start/stop runs.
                         </para>
                         <informalexample>
                             <programlisting>
+-------------------------------------------+
| Whole bank |    16 channels     |  trig   |
|   2 bits   |       6 bits       | 2 bits  |
+-------------------------------------------+
|  B1  | B0  | active | Chan[4:0] | T1 | T0 |
+-------------------------------------------+
                             </programlisting>
                         </informalexample>
                         <para>
                             The default value is 0x400.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term><option>-triggeroutput</option> <replaceable>int 0-1023 (0-0x3ff)</replaceable></term>
                     <listitem>
                         <para>
                             (From MDPP-32 documentation) Defines the trigger which creates output trigger.
                             This can be: one or both of the trigger inputs, lower 16 channels(B0), upper 16 channels(B1),
                             or both banks (all channels). 
                         </para>
                         <para>
                           MDPPTriggerControl GUI is included in the FRIBDAQ package. This value needs to be set to 0x400
                           to use the GUI controller. In this case, the last setting is preserved while start/stop runs.
                         </para>
                         <informalexample>
                             <programlisting>
+-----------------------------------------+
| Whole bank |    16 channels     |   00  |
+-----------------------------------------+
|  B1  | B0  | active | Chan[4:0] | 0 | 0 |
+-----------------------------------------+
                             </programlisting>
                         </informalexample>
                         <para>
                             The default value is 0x400.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-monitoron</option>
                         <replaceable>bool</replaceable>
                     </term>
                     <listitem>
										 
                         <para>
                             Switch monitor on
                         </para>
										 </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-setmonitorch</option>
                         <replaceable>int 0-31</replaceable>
                     </term>
                     <listitem>
										 
                         <para>
                             Set channel to monitor
                         </para>
										 </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-setwave</option>
                         <replaceable>int 0-3</replaceable>
                     </term>
                     <listitem>
										 
                         <para>
                             Set wave to monitior
                         </para>
										 </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-tfintdiff</option>
                         <replaceable>int[8] 1-127</replaceable>
                     </term>
                     <listitem>
                         <para>
                             TF integration/differentiation time in 12.5 ns unit
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[4*index, 4*index+3]</literal>.
                         </para>
                         <para>
                             By default, the value is <literal>[list 20 20 20 20  20 20 20 20]</literal>,
                             which is 250 ns for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-pz</option>
                         <replaceable>int[32] 64-65535</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Signal decay time in 12.5 ns unit. Allowed range is [64-64000] and 65535.
                             Setting 65535 means infinite decay time.
                         </para>
                         <para>
                             The parameter provided must be a list of 32 integers. Each element sets
                             the decay time to each channel.
                         </para>
                         <para>
                             By default, the value is
                             <literal>[list 0xffff 0xffff ... 0xffff 0xffff]</literal>,
                             which is infinite decay time for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-gain</option>
                         <replaceable>int[8] 100-25000</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Gain. 100 means gain 1. 25000 means gain 250.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[4*index, 4*index+3]</literal>.
                         </para>
                         <para>
                             By default, the value is <literal>[list 200 200 200 200  200 200 200 200]</literal>,
                             which is gain 2 for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-threshold</option>
                         <replaceable>int[32] 0-64000</replaceable>
                     </term>
                     <listitem>
                         <para>
                             The parameter provided must be a list of 32 integers. Each element sets
                             the threshold to each channel.
                         </para>
                         <para>
                             By default, the value is
                             <literal>[list 2000 2000 2000 2000 ... 2000 2000 2000 2000]</literal>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-shapingtime</option>
                         <replaceable>int[8] 8-2000 (=100ns-25us)</replaceable>
                     </term>
                     <listitem>
                         <para>
                             FWHM-width of input signals in multiple of 12.5 ns
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[4*index, 4*index+3]</literal>.
                         </para>
                         <para>
                             By default, the value is
                             <literal>[list 200 200 200 200  200 200 200 200]</literal>,
                             which is 200 for all channels which is 2.5us.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-blr</option>
                         <replaceable>int[8] 0 | 1 | 2</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Base line restorer setting.
                         </para>
                         <para>
                             0: Off, 1: Strict (int. time = 4 shaping times), 2: Soft (int. time = 8 shaping times)
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[4*index, 4*index+3]</literal>.
                         </para>
                         <para>
                             By default, the value is <literal>[list 2 2 2 2  2 2 2 2]</literal>,
                             which is soft for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>
                         <option>-signalrisetime</option>
                         <replaceable>int[8] 0-127</replaceable>
                     </term>
                     <listitem>
                         <para>
                             Signal rise time in multiple of 12.5 ns.
                         </para>
                         <para>
                             (From MDPP-32 SCP documentation) It determines the flat top of trapezoidal shape.
                             0 -> For Si-detectors, constant rise time detectors: shorted dead time.
                             For germanium detectors with position dependent rise time set
                             to largest possible signal rise time.
                             This results in highest resolution and ballistic loss correction.
                         </para>
                         <para>
                             The parameter provided must be a list of 8 integers.
                             The value of an element at <literal>index[0-7]</literal> is applied
                             to the channels <literal>[4*index, 4*index+3]</literal>.
                         </para>
                         <para>
                             By default, the value is <literal>[list 0 0 0 0  0 0 0 0]</literal>,
                             which is 0 (0*12.5=0ns) for all channels.
                         </para>
                     </listitem>
                 </varlistentry>
<!--                 <varlistentry>
                     <term><option>-resettime</option> <replaceable></replaceable></term>
                     <listitem>
                         <para>

                         </para>
                     </listitem>
                 </varlistentry>-->
                 <varlistentry>
                     <term><option>-printregisters</option> <replaceable>0 | 1</replaceable></term>
                     <listitem>
                         <para>
                             Print out register values from the module. The values are not from the user input,
                             but from the actual register values read from the module after processing the input.
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </refsect1>
         <refsect1>
             <title>EXAMPLES</title>
             <example>
                 <title>Sample MDPP-32 SCP commands</title>
                 <programlisting>
set tfintdiff         [list 100 16 16 16  16 16 16 16]
set pz                [list 0xFFFF 0xFFFF 0xFFFF 0xFFFF  0xFFFF 0xFFFF 0xFFFF 0xFFFF \
                            0xFFFF 0xFFFF 0xFFFF 0xFFFF  0xFFFF 0xFFFF 0xFFFF 0xFFFF \
                            0xFFFF 0xFFFF 0xFFFF 0xFFFF  0xFFFF 0xFFFF 0xFFFF 0xFFFF \
                            0xFFFF 0xFFFF 0xFFFF 0xFFFF  0xFFFF 0xFFFF 0xFFFF 0xFFFF]
set gain              [list 200 200 200 200  200 200 200 200]
set threshold         [list 2000 2000 2000 2000  2000 2000 2000 2000 \
                            2000 2000 2000 2000  2000 2000 2000 2000 \
                            2000 2000 2000 2000  2000 2000 2000 2000 \
                            2000 2000 2000 2000  2000 2000 2000 2000]
set shapingtime       [list 100 100 100 100  100 100 100 100]
set blr               [list 2 2 2 2  2 2 2 2]
set signalrisetime    [list 0 none none none  none none none none]
set windowStart         16368
set windowWidth         32
set firstHit            1
set testPulser          0
set pulserAmplitude     400
set triggerSource       0x100
set triggerOutput       0x100
set monitorOn           0
set monitorCh           0
set monitorWave         0

mdpp32scp create scp -base 0x00030000
mdpp32scp config scp -tfintdiff $tfintdiff \
                     -pz $pz \
                     -gain $gain \
                     -threshold $threshold \
                     -shapingtime $shapingtime \
                     -blr $blr \
                     -signalrisetime $signalrisetime \
                     -windowstart $windowStart \
                     -windowwidth $windowWidth \
                     -firsthit $firstHit \
                     -testpulser $testPulser \
                     -pulseramplitude $pulserAmplitude \
                     -triggersource $triggerSource \
                     -triggeroutput $triggerOutput \
                     -monitoron $monitorOn \
                     -setmonitorch $monitorCh \
                     -setwave $monitorWave \
                     -printregisters 1
                 </programlisting>
             </example>
             <para>
                 Defines a module with base address <literal>0x00030000</literal>.
                 While many register values are defined with lists, not all of them are
                 used to configure the module.
             </para>
             <para>
                 If any of the parameters are not specified in <literal>config</literal>,
                 it uses the default values. It is recommeneded only define variables
                 need to change and omit others for taking default values.
             </para>
         </refsect1>
     </refentry>
      
	 <refentry id="vmusb3-CVMUSB">
	    <refentryinfo>
	      <author>
		  <personname>
		      <firstname>Ron</firstname>
		      <surname>Fox</surname>
		  </personname>
		  <personblurb><para></para></personblurb>
	      </author>
	      <productname>NSCLDAQ</productname>
	      <productnumber></productnumber>
	    </refentryinfo>
	  
       <refmeta>
          <refentrytitle id='vmusb3-CVMUSB-title'>CVMUSB</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
	  <refmiscinfo class='empty'></refmiscinfo>
       </refmeta>
       <refnamediv>
          <refname>CVMUSB</refname>
          <refpurpose>Interface with VM-USB controller.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
        #include &lt;CVMUSB.h&gt;

        class <ooclass><classname>CVMUSB</classname></ooclass> {
        
        <methodsynopsis>
          <modifier>static </modifier>
          <type>std::vector&lt;struct usb_device*&gt;</type>
          <methodname>enumerate</methodname>
          <void />
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static</modifier> <type>std::string</type>
            <methodname>serialNo</methodname>
            <methodparam>
                <type>usb_device*</type> <parameter>dev</parameter>
            </methodparam>
        </methodsynopsis>
        <constructorsynopsis>
           <methodname>CVMUSB</methodname>
           <methodparam>
                <type>struct usb_device*</type> <parameter>vmUsbDevice</parameter>
           </methodparam>
        </constructorsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeActionRegister</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readFirmwareID</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeGlobalMode</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint16_t</type> <methodname>readGlobalMode</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDAQSettings</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type>
            <methodname>readDAQSettings</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeLEDSource</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readLEDSource</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDeviceSource</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readDeviceSource</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDGG_A</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readDGG_A</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDGG_B</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readDGG_B</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDGG_Extended</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readDGG_Extended</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readScalerA</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readScalerB</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeVector</methodname>
            <methodparam>
                <type>int</type> <parameter>which</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readVector</methodname>
            <methodparam>
                <type>int</type> <parameter>which</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeIrqMask</methodname>
            <methodparam>
                <type>uint8_t</type> <parameter>mask</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint8_t</type> <methodname>readIrqMask</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeBulkXferSetup</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readBulkXferSetup</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeWrite32</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeRead32</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_tM</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t*</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeWrite16</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint16_t</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeRead16</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint16_t*M</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeWrite8</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeRead8</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t*</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeBlockRead</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>baseAddress</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>transferCount</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeFifoRead</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>int8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>transferCount</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeReadBlockCount8</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>mask</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeReadBlockCount16</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>mask</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeReadBlockCount32</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>addressM</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>mask</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeVariableBlockRead</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>maxCount</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeVariableFifoRead</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>maxCount</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>executeList</methodname>
            <methodparam>
                <type>CVMUSBReadoutList&amp;</type> <parameter>list</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>pReadBuffer</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>readBufferSize</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>bytesRead</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>loadList</methodname>
            <methodparam>
                <type>uint8_t</type> <parameter>listNumber</parameter>
            </methodparam>
            <methodparam>
                <type>CVMUSBReadoutList&amp;</type> <parameter>list</parameter>
            </methodparam>
            <methodparam>
                <type>off_t</type> <parameter>listOffset</parameter>
                <initializer> 0</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>usbRead</methodname>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>bufferSize</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>transferCount</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>timeout</parameter>
                <initializer>2000</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>setDefaultTimeout</methodname>
            <methodparam>
                <type>int</type> <parameter>ms</parameter>
            </methodparam>
        </methodsynopsis>
        
        class <ooclass><classname>CVMUSB::RegisterOffsets</classname></ooclass>  {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>FIDRegister</varname> <initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>GMODERegister</varname> <initializer>4</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DAQSetRegister</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>LEDSrcRegister</varname><initializer>0xc</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DEVSrcRegister</varname><initializer>0x10</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DGGARegister</varname><initializer>0x14</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DGGBRegister</varname><initializer>0x18</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ScalerA</varname><initializer>0x1c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ScalerB</varname><initializer>0x20</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ExtractMask</varname><initializer>0x24</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ISV12</varname><initializer>0x28</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ISV34</varname><initializer>0x2c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ISV56</varname><initializer>0x30</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ISV78</varname><initializer>0x34</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DGGExtended</varname><initializer>0x38</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>USBSetup</varname><initializer>0x3c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>USBVHIGH1</varname><initializer>0x40</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>USBVHIGH2</varname><initializer>0x44</initializer>
        </fieldsynopsis>

        };
        class <ooclass><classname>CVMUSB::ActionRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>startDAQ</varname><initializer>1</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>usbTrigger</varname><initializer>2</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>clear</varname><initializer>4</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>sysReset</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>scalerDump</varname><initializer>0x10</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL0</varname><initializer>0x100</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL1</varname><initializer>0x200</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL2</varname><initializer>0x400</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL3</varname><initializer>0x800</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL4</varname><initializer>0x1000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL5</varname><initializer>0x2000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL6</varname><initializer>0x4000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL7</varname><initializer>0x8000</initializer>
        </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::FirmwareRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>minorRevMask</varname><initializer>0x000000ff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>minorRevShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>majorRevMask</varname><initializer>0x0000ff00M</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>majorRevShift</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>betaVersionMask</varname><initializer>0x00ff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>betaVersionShift</varname><initializer>16</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>yearMask</varname><initializer>0x0f000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>yearShift</varname><initializer>24</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>monthMask</varname><initializer>0xf0000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>monthshift</varname><initializer>27</initializer>
        </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::GlobalModeRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLenMask</varname><initializer>0xf</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLenShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen13K</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen8K</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen4K</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen2K</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen1K</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen512</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen256</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen128</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen64</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLenSingle</varname><initializer>9</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>spanBuffers</varname><initializer>0x10</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>mixedBuffers</varname><initializer>0x20</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>doubleSeparator</varname><initializer>0x40</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>align32</varname><initializer>0x80</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>doubleHeader</varname><initializer>0x100</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>flushScalers</varname><initializer>0x200</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>busReqLevelMask</varname><initializer>0x7000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>busReqLevelShift</varname><initializer>12</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::DAQSettingsRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>readoutTriggerDelayMask</varname><initializer>0xff</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>readoutTriggerDelayShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerReadoutPeriodMask</varname><initializer>0xff00</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>>uint32_t</type>
        <varname>scalerReadoutPeriodShift</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerReadoutFrequenyMask</varname><initializer>0xffff0000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerReadoutFrequencyShift</varname><initializer>16</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::LedSourceRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowOutFifoNotEmpty</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowInFifoNotEmpty</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowScalerEvent</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowInFifoFull</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowDTACK</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowBERR</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowBusRequest</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowBusGranted</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowInvert</varname><initializer>0x8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowLatch</varname><initializer>0x10</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redEventTrigger</varname><initializer>(0 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redNimInput1</varname><initializer>(1 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redNimInput2</varname><initializer>(2 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redBusyM</varname><initializer>(3 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redDTACK</varname><initializer>(4 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redBERR</varname><initializer>(5 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redBusRequest</varname><initializer>(6 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redBusGranted</varname><initializer>(7 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redInvert</varname><initializer>(8 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redLatch</varname><initializer>(0x10 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenAcquire</varname><initializer>(0 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenStackNotEmpty</varname><initializer>(1 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenEventReady</varname><initializer>(2 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenEventTrigger</varname><initializer>(3 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenDTACK</varname><initializer>(4 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenBERR</varname><initializer>(5 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenBusRequest</varname><initializer>(6 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenBusGranted</varname><initializer>(7 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenInvert</varname><initializer>(8 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenLatch</varname><initializer>(0x10 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowNotArbiter</varname><initializer>(0 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowUsbTrigger</varname><initializer>(1 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowUSBReset</varname><initializer>(2 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowBERR1</varname><initializer>(3 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowDTACK</varname> <initializer>(4 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowBERR</varname><initializer>(5 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowBusRequest</varname><initializer>(6 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowBusGranted</varname><initializer>(7 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowInvert</varname><initializer>(8 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowLatch</varname><initializer>(0x10 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::DeviceSourceRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Busym</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Trigger</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1BusRequest</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1EventToBuffer</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1DGGA</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1DGGB</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1EndOfEvent</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1UsbTrigger</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Invert</varname><initializer>8M</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Latch</varname><initializer>0x10</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2UsbTrigger1</varname><initializer>(0 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2VMEExecuting</varname><initializer>(1 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2VMEAS</varname><initializer>(2 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DataToUsbFIFO</varname><initializer>(3 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DGGA</varname><initializer>(4 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DGGB</varname><initializer>(5 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2EndOfEvent</varname><initializer>(6 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2UsbTrigger</varname><initializer>(7 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2Invert</varname><initializer>(8 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2Latch</varname><initializer>(0x10 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    
    <!-- Scaler A -->
    
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerADGGA</varname><initializer>(0   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerANIMI1</varname><initializer>(1   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerANIMI2</varname><initializer>(2   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAEvent</varname><initializer>(3   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAEnable</varname><initializer>(8   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAReset</varname><initializer>(0x10 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBCarryA</varname><initializer>(0   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBNIMI1</varname><initializer>(1   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBNIMI2</varname><initializer>(2   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBEvent</varname><initializer>(3   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBEnable</varname><initializer>(8   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBReset</varname><initializer>(0x10 &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggADisabled</varname><initializer>(0   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggANIMI1</varname><initializer>(1   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggANIMI2</varname><initializer>(2   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAEventTrigger</varname><initializer>(3   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAEndOfEvent</varname><initializer>(4   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAUsbTrigger</varname><initializer>(5   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAPulser</varname><initializer>(6   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBDisabled</varname><initializer>(0   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBNIMI1</varname><initializer>(1   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBNIMI2</varname><initializer>(2   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBEventTrigger</varname><initializer>(3   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBEndOfEvent</varname><initializer>(4   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBUsbTrigger</varname><initializer>(5   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBPulser</varname><initializer>(6   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>freezeScalers</varname><initializer>0x80000000</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::DGGAndPulserRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggFineDelayMask</varname><initializer>0xffff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggFineDelayShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggGateWidthMask</varname><initializer>0xffff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggGateWidthShift</varname><initializer>16</initializer>
        </fieldsynopsis>
    
    };
    class <ooclass><classname>CVMUSB::DGGCoarseRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>ACoarseMask</varname><initializer>0xffff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>ACoarseShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BCoarseMask</varname><initializer>0xffff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BCoarseShift</varname><initializer>16</initializer>
        </fieldsynopsis>
    
    }; 
    class <ooclass><classname>CVMUSB::ISVRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AVectorMask</varname><initializer>= 0xff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AVectorShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AIPLMask</varname><initializer>0x700</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AIPLShift</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AStackIDMask</varname><initializer>0x7000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AStackIDShift</varname><initializer>12</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BVectorMask</varname><initializer>0xff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BVectorShift</varname><initializer>16</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BIPLMask</varname><initializer>0x7000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BIPLShift</varname><initializer>24</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BStackIDMask</varname><initializer>0x70000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BStackIDShift</varname><initializer>28</initializer>
        </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::TransferSetupRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>multiBufferCountMask</varname><initializer>0xff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>multiBufferCountShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>timeoutMask</varname><initializer>0xf00</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>timeoutShift</varname><initializer>8</initializer>
        </fieldsynopsis>
    };
    



};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CVMUSB</classname> encapsulates a VM-USB controller.
            Its methods are divided in to several categories:
          </para>
          <itemizedlist>
            <listitem>
                <para>Static methods for enumeration and selection</para>
            </listitem>
            <listitem>
                <para>Methods to access the VM-USB register set</para>
            </listitem>
            <listitem>
                <para>Methods to perform simple VME operations via the controller</para>
            </listitem>
            <listitem>
                <para>A method to execute immediate lists and get the data read
                by those stacks</para>
            </listitem>
            <listitem>
                <para>Methods to download lists and manage the module in
                data taking mode.
                </para>
            </listitem>
          </itemizedlist>
          <para>
            See METHODS below for descriptions of each of the methods.
          </para>
          <para>
            Register bits and field definitions are provided as nested classes
            see CONSTANTS below for a description of each of these classes.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            This section provides a description of each of the methods. Where
            appropriate reference is made to sections of the VM-USB manual.
          </para>
          <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static </modifier>
                      <type>std::vector&lt;struct usb_device*&gt;</type>
                      <methodname>enumerate</methodname>
                      <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This function returns a vector of <type>usb_device*</type>
                        pointers, one for each VM-USB powered up and attached
                        to the system.  <type>usb_device</type> is an opaque
                        type used by libusb to refer to a specific device
                        attached to the host via USB.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static</modifier> <type>std::string</type>
                        <methodname>serialNo</methodname>
                        <methodparam>
                            <type>usb_device*</type> <parameter>dev</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a <type>usb_device</type> pointer, typically]
                        gotten from <methodname>CVMUSB::enumerate</methodname>,
                        returns the serial number string of the device that
                        corresponds to it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                       <methodname>CVMUSB</methodname>
                       <methodparam>
                            <type>struct usb_device*</type> <parameter>vmUsbDevice</parameter>
                       </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a <classname>CVMUSB</classname> object given
                        a <type>usb_device</type> pointer typically gotten from
                        <methodname>CVMUSB::enumerate</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeActionRegister</methodname>
                        <methodparam>
                            <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writes <parameter>value</parameter> to the VM-USB
                        action register.  The action register is a write only
                        register that is used to control the overall behavior
                        of the VM-USB.  It allows you to enter or leave
                        data taking mode, reset the VME bus and trigger the
                        various downloaded VME lists.
                    </para>
                    <para>
                        The action register is described in section 3.1 of the
                        VM-UBS manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readFirmwareID</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Reads the firmware Id register.  The firmware Id is a
                        bit encoded readonly register that provides the date,
                        status (beta test or production), the major and minor
                        versions of the firmware.  The firmware Id register
                        is described by section 3.4.1 of the VM-USB manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeGlobalMode</methodname>
                        <methodparam>
                            <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                <listitem>
                    <para>
                        Writes <parameter>value</parameter> to the VM-USB
                        global mode regiseter.  The global mode register determiens
                        the bus request level, header options and the size of the
                        output buffer, as well as a few other buffer options.
                        It is described in setion 3.4.2 of the VM-USB manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint16_t</type> <methodname>readGlobalMode</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the global mode register.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDAQSettings</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                   <para>
                        Writes the data acquisition settings register with
                        <parameter>value</parameter>.  This register, described
                        in section 3.4.3 of the VM-USB manual, determines how
                        scaler buffers are read and the delay between a readout
                        trigger from <literal>IN1</literal> and the actual
                        start of VME list execution.  This is provided to
                        allow users to provide a common digitizer and VM-USB
                        trigger.  The delay, in that case allows digitizers to
                        complete their conversions prior to being read by the
                        readout list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type>
                        <methodname>readDAQSettings</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the data acquisition settings
                        register.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeLEDSource</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Write <parameter>value</parameter> to the VM-USB
                        LED source register.  The VM-USB has a set of four LEDs.
                        This register determines the conditions under which each
                        of those LEDs is lit.  The LED source register is described
                        in section 3.4.4 of the VM-USB manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readLEDSource</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the current value of the LED source register.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDeviceSource</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writes <parameter>value</parameter> to the VM-USB device
                        source register.  The VM-USB provides a pair of scalers
                        and gate and delay generators, as well as two front panel
                        NIM outputs.  This register defines the signal sources
                        for each of these devices (when scalers increment, what
                        starts a gate and delay generator and when the outputs
                        are asserted).
                    </para>
                    <para>
                        The Device Sources register is described in section
                        3.4.5 of the VM-USB manual.
                    </para>
                 </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readDeviceSource</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the Device source register.        
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDGG_A</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writes <parameter>value</parameter> to the Delay and
                        Gate Generator A control register. This register
                        contains the length of the output gateas well as the
                        low order bits of the delay.  The Delay and Gate register
                        setup is described in section 3.4.6 of the VM-USB
                        manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readDGG_A</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the DGG A control register.        
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDGG_B</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the Delay and
                            Gate Generator B control register. This register
                            contains the length of the output gateas well as the
                            low order bits of the delay.  The Delay and Gate register
                            setup is described in section 3.4.6 of the VM-USB
                            manual.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readDGG_B</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value of the DGG B control register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDGG_Extended</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes the DGG extended delay offset.  This register
                            contains the top 16 bits of the delay for both
                            A and B DGG's. It is describedin section 3.4.6
                            of the VM-USB manual.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readDGG_Extended</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the DGG extended delay register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readScalerA</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The VM-USB contains two scalers (counters) that
                            can be incremented as a result of several
                            conditions.  These scalers are named A and B and
                            are described in section 3.4.7 of the VM-USB manual.
                        </para>
                        <para>
                            This method returns the value of scaler A.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readScalerB</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            See <methodname>readScalerA</methodname> this method
                            returns the value of scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeVector</methodname>
                        <methodparam>
                            <type>int</type> <parameter>which</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The VM-USB allows stacks to be triggered as a result
                            of VME interrupts.  4 interrupt registers are provided
                            as described in section 3.4.8.  Each register
                            describes the IPL and Status ID of two interrupts
                            and associates each of those with a stack.
                            This method allows you to program the value of one
                            of those registers.
                        </para>
                        <para>
                            The <parameter>which</parameter>   parameter selects
                            which of the interrupt registers to write, numbered
                            from 1 through 4.  The <parameter>value</parameter>
                            parameter is written to the selected register.
                        </para>
                        <para>
                            An error message is thrown as an <type>std::string</type>
                            if <parameter>which</parameter> is illegal.
                        </para>
                        <para>
                            As essentially all VME interrupters in existence
                            use an 8 bit status ID for which the top
                            bits must be set, according to the VME standard,
                            These methods also write both Status/ID expansion
                            registers to <literal>0xffffffff</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readVector</methodname>
                        <methodparam>
                            <type>int</type> <parameter>which</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value of
                            one of the interrupt registers described
                            above.  <parameter>which</parameter> indicates
                            which one to read.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeIrqMask</methodname>
                        <methodparam>
                            <type>uint8_t</type> <parameter>mask</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes the IRQ mask register described in section
                            3.5 of the VM-USB manual.  The register is
                            set to <parameter>mask</parameter>. Each bit in the
                            mask represents a VME IPL.  <literal>0x01</literal>
                            represents IPL1, <literal>0x40</literal> represents
                            IPL 7.  If a bit is set to 1, interrupts at that IPL
                            will be ignored by the VM-USB.
                        </para>
                        <para>
                            This register only needs to be programmed when
                            the VM-USB is used with other interrupt handling
                            modules (e.g. CPU modules).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint8_t</type> <methodname>readIrqMask</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value last written to the
                            IRQ mask register.  The actual register is write-only.
                            The <classname>CVMUSB</classname> class therefore
                            remembers the most recently written value. This
                            <firstterm>shadow register value</firstterm> is what
                            is returned by this method.  Note as well that
                            the IRQ mask register is set to <literal>0xff</literal>
                            by the constructor so that it has a known intial
                            value.  This initial value <emphasis>disables</emphasis>
                            all
                            interrupt handling by the VM-USB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeBulkXferSetup</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the Bulk
                            Transfer setup register.  This register is described
                            in section 3.4.10 of the VM-USB manual.  It controls
                            several parameters that can optimize the bandwidth of
                            the USB.  Specifically you can set the number of buffers
                            that will be sent from the VM-USB to the host without
                            generating a USB Packet end frame and the timeout
                            after which the packet end frame will be sent
                            regardless of how many bufers were sent.
                        </para>
                        <para>
                            If the paragraph above is not meaningful to you,
                            and you read 3.4.10 and its still not meaningful, you
                            should probably not touch this register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readBulkXferSetup</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value of the Bulk Transfer Setup register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeWrite32</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes a 32 bit longword, <parameter>data</parameter>
                            to a vme <parameter>address</parameter> using
                            the VME Address modifier <parameter>aModifier</parameter>.
                        </para>
                        <para>
                            The function returns <literal>0</literal> on
                            success, <literal>-1</literal> if the USB write
                            failed, <literal>-2</literal> if the USB read of the
                            acknowledgement failed, and <literal>-3</literal>
                            if the acknowledgement packet indicated the
                            transfer failed due to a bus error.
                        </para>
                        <para>
                            For USB write and read failures, the resason for
                            the failure is available in <varname>errno</varname>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeRead32</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_tM</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t*</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a 32 bit longword read from
                            <parameter>address</parameter> using the VME bus
                            address modifier <parameter>aModifier</parameter>.
                            If successful, the data are stored in <parameter>data</parameter>.
                        </para>
                        <para>
                            The return value reflects a high level status of the
                            operation.
                            The function returns <literal>0</literal> on
                            success, <literal>-1</literal> if the USB write
                            failed, <literal>-2</literal> if the USB read of the
                            acknowledgement failed.
                        </para>
                        <para>
                            For USB write and read failures, the resason for
                            the failure is available in <varname>errno</varname>
                        </para>                            
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeWrite16</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint16_t</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Identical to <methodname>vmeWrite32</methodname>
                            however the data transfered is only a 16 bit
                            word wide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeRead16</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint16_t*M</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Identical to <methodname>vmeRead32</methodname>
                            however the data read are only a 16 bit word wide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeWrite8</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeWrite32</methodname> however
                            the data written are an 8 bit byte in width.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeRead8</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t*</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeRead32</methodname> however
                            the data read are an 8 bit byte in width.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeBlockRead</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>baseAddress</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>transferCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>countTransferred</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a block read from the VME bus.  VME block
                            reads the requestor to only send an initial VME
                            base address followed by a new address every time
                            the address crosses a 256 byte boundary.  Subsequent
                            addresses are assumed  to represent a contiguous
                            block of storage.  Not all devices support block
                            transfers.  Block transfers also require specific
                            block transfer address modifiers.  When used properly,
                            block transfers allow higher throughput by
                            reducing the number of address cycles.
                        </para>
                        <para>
                            The base address of the block transfer is
                            <parameter>baseAddress</parameter>.  The address
                            modifier used is <parameter>aModifier</parameter>
                            the caller is responsible for ensuring that
                            <parameter>aModifier</parameter> is a valid
                            block transfer address modifier. <parameter>data</parameter>
                            is a buffer that will receive the data read.
                            <parameter>transferCount</parameter> is the number
                            of longwords (32 bit items) to transfer.  All transfers
                            will be 32 bit wide transfers.  <parameter>countTransferred</parameter>
                            will be the actual number of longwords transferred.
                        </para>
                        <para>
                            For some devices it is possible to transfer fewer
                            items thatn the number of items requested.  An example
                            of this is the use of CAEN V785's in chained block
                            mode.  In that case, the read will transfer data
                            until the ADC's have no more data left at which time
                            the modules will return a bus error on the next transfer
                            and the VM-USB will insert a <literal>0xffffffff</literal>
                            marker in the data stream when the bus error occured.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeFifoRead</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>transferCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>countTransferred</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This function is the same as <methodname>vmeBlockRead</methodname>
                            except that all address cycles use the same <parameter>address</parameter>
                            value.  This makes the function suitable to read FIFO
                            registers in modules that support block reads.
                        </para>
                   </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeReadBlockCount8</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>mask</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The VM-USB supports variable sized block reads.
                            These operate by first performing a
                            read of the block count from some register and providing
                            a mask that indicates what part of that data
                            contains the transfer count.
                            The block count read must at some point be
                            folowed by a call to
                            <methodname>vmeVariableBlockRead</methodname>
                            to actually perform the block read.
                        </para>
                        <para>
                            This method does an 8 bit transfer to read the
                            block count for the next
                            <methodname>vmeVariableBlockRead</methodname>
                            call. <parameter>address</parameter> is the
                            byte address of the location that contains the
                            count field.  The addressed module must support
                            byte addressing at this location.  <parameter>mask</parameter>
                            is the mask that defines the bit field containing
                            the count.
                            <parameter>amod</parameter> is the address modifier
                            for the transfer of the transfer count.
                        </para>
                        
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeReadBlockCount16</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>mask</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeReadBlockCount8</methodname>
                            but the block count transfer is 16 bits wide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeReadBlockCount32</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>addressM</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>mask</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeReadouBlockCount8</methodname>
                            except the block count is read with a 32 bit transfer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeVariableBlockRead</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>maxCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>countTransferred</parameter>
                        </methodparam>
                    </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Do a variable length block transfer.  This
                                transfer must have been
                                set up by doing a call to one of the
                                <methodname>vmeReadBlockCountxx</methodname> functions.
                                furthermore, no other block transfer can have
                                taken place since that
                                operation.  It is <emphasis>strongly</emphasis>
                                recommended that unless prohibited by the
                                hardware, a vmeReadBlockCountxx be
                                <emphasis>immediately</emphasis> followed by a
                                variable block read or variable fifo read.
                            </para>
                            <para>
                                <parameter>address</parameter> is the starting
                                address of the block read.  <parameter>amod</parameter>
                                is the VME address modifier.  <parameter>data</parameter>
                                is a buffer into which data will be stored and
                                <parameter>maxCount</parameter> the size of that buffer
                                in 32bit longwords.  <parameter>countTransferred</parameter>
                                will be filled in with the total number of longwords
                                actually transferred.
                            </para>
                            <para>
                                The total transfer count is the minimum of the
                                variable block read gotten by the
                                <methodname>vmeReadBlockCountxx</methodname>
                                method, the value of the <parameter>maxCount</parameter>
                                parameter to this call and the number of transfers
                                actually performed prior to and including the
                                transfer that caused a bus error if any.
                            </para>
                            <para>
                                As usual, in the event the transfer terminated
                                with a bus error, that operation inserts a
                                <literal>0xffffffff</literal> in the buffer.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeVariableFifoRead</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>maxCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>countTransferred</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeVariableBlockRead</methodname>
                            but all addresses cycles
                            provide <parameter>address</parameter> rather than
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>executeList</methodname>
                        <methodparam>
                            <type>CVMUSBReadoutList&amp;</type> <parameter>list</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>pReadBuffer</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>readBufferSize</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>bytesRead</parameter>
                        </methodparam>
                    </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This function executes a list of operations.
                                The <parameter>list</parameter> parameter
                                is an instance of a
                                <classname>CVMUSBReadoutList</classname>
                                class.  See the documentation for that
                                class for a description of how to build up
                                lists of VM-USB operations.
                            </para>
                            <para>
                                <parameter>pReadBuffer</parameter> points to
                                a buffer into which the results of all
                                VME read operations will be put.
                                The buffer must be <parameter>readBufferSize</parameter>
                                8 bit bytes long.  <parameter>bytesRead</parameter>
                                will be written with the number of bytes actually
                                transferred to <parameter>pReadBuffer</parameter>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>loadList</methodname>
                        <methodparam>
                            <type>uint8_t</type> <parameter>listNumber</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CVMUSBReadoutList&amp;</type> <parameter>list</parameter>
                        </methodparam>
                        <methodparam>
                            <type>off_t</type> <parameter>listOffset</parameter>
                            <initializer> 0</initializer>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Loads a list for triggered execution in data taking
                            mode.  <parameter>listNumber</parameter> is the
                            number of the list to load (stack Number).  Tis
                            is a value in the range <literal>[0..7]</literal>.
                            <parameter>list</parameter> is a list of operations
                            built up by instantiating a <classname>CVMUSBReadoutList</classname>
                        </para>
                        <para>
                            <parameter>listOffset</parameter> is the starting
                            offset in  VM-USB memory at which the list
                            should be loaded.  When computing where to load
                            multiple stacks you need to know that each
                            stack requires:
                            <informalexample>
                                <programlisting>
list.size() * sizeof(uint32_t)/sizeof(uint16_t) + 4
                                </programlisting>
                            </informalexample>
                            locations.
                        </para>
                    </listitem>
                </varlistentry>
                    <varlistentry>
                        <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>usbRead</methodname>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>bufferSize</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>transferCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int</type> <parameter>timeout</parameter>
                            <initializer>2000</initializer>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a bulk read on the VM-USB.
                            <parameter>data</parameter> provides a buffer
                            into which the data will be read.
                            <parameter>bufferSize</parameter> is the number
                            of bytes of space pointed to by <parameter>data</parameter>
                            <parameter>transferCount</parameter>
                            will be written with the
                            number of transfers that actually were performed.
                        </para>
                        <para>
                            The return value is <literal>0</literal> on success
                            or <literal>-1</literal> on failure.  On failure,
                            zero will be stored in the <parameter>transferCount</parameter>
                            and <varname>errno</varname> will have the reason
                            for the failure.
                        </para>
                        <para>
                            If no data are available by <parameter>timeout</parameter>
                            milliseconds, the read will fail with an
                            <varname>errno</varname> value of
                            <literal>ETIMEDOUT</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>setDefaultTimeout</methodname>
                        <methodparam>
                            <type>int</type> <parameter>ms</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the timeout used for transactions that
                            don't provide a timeout value.  <parameter>ms</parameter>
                            is the number of milliseconds these methods will
                            wait for a response from the VM-USB.
                        </para>
                        <para>
                            Almost all actions with the VM-USB require the
                            host to send a USB packet to the VM-USB and receive
                            a packet in return.  This function sets the timeout
                            that will be used for the <methodname>usbRead</methodname>
                            call to get the return packets.
                        </para>
                    </listitem>
                </varlistentry>        
          </variablelist>
       </refsect1>
        <refsect1>
           <title>CONSTANTS</title>
           <para>
                This class defines a large number of nested classes.  Each nested
                class defines symbolic constants for a register.  The
                SYNOPSIS section shows these definitions.  
           </para>
           <para>
            For example, the <classname>CVMUSB::ActionRegister</classname>
            provides bit definitions fro the Action register.
           </para>
        </refsect1>
     </refentry>
         
	 <refentry id="vmusb3-CVMUSBReadoutList">
	    <refentryinfo>
	      <author>
		  <personname>
		      <firstname>Ron</firstname>
		      <surname>Fox</surname>
		  </personname>
		  <personblurb><para></para></personblurb>
	      </author>
	      <productname>NSCLDAQ</productname>
	      <productnumber></productnumber>
	    </refentryinfo>
	  
       <refmeta>
          <refentrytitle id='vmusb3-CVMUSBReadoutList-title'>CVMUSBReadoutList</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
	  <refmiscinfo class='empty'></refmiscinfo>
       </refmeta>
       <refnamediv>
          <refname>CVMUSBReadoutList</refname>
          <refpurpose>Construct VM-USB stacks</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
            <synopsis>
#include &lt;CVMUSBReadoutList.h&gt;

class <ooclass><classname>CVMUSBReadoutList</classname></ooclass>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <void />
       
    </constructorsynopsis>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <methodparam>
            <type>std::vector&lt;uint32_t&gt;&amp;</type> <parameter>list</parameter>
       </methodparam>
       
    </constructorsynopsis>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <methodparam>
            <modifier>const</modifier> <type>CVMUSBReadoutList&amp;</type>
            <parameter>rhs</parameter>
       </methodparam>
       
    </constructorsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>clear</methodname>
      <void />
      <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>size_t</type>
      <methodname>size</methodname>
      <void />
      <modifier>const</modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>std::vector&lt;uint32_t&gt;</type>
      <methodname>get</methodname>
      <void />
      <modifier>const</modifier>
    </methodsynopsis>                    
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRegisterRead</methodname>
      <methodparam>
        <type>unsigned int</type> <parameter>address</parameter>
      </methodparam>
      <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRegisterWrite</methodname>
      <methodparam>
        <type>unsigned int</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type> <parameter>data</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addWrite32</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type> <parameter>datum</parameter>    
      </methodparam>
      <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addWrite16</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>uint16_t</type> <parameter>datum</parameter>
      </methodparam>
      <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addWrite8</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>datum</parameter>   
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRead32</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRead16</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRead8</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockRead32</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>baseAddress</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>size_t</type><parameter>transfers</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addFifoRead32</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>baseAddress</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>size_t</type><parameter>transfers</parameter>
      </methodparam>    
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addFifoRead16</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>baseAddress</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>size_t</type><parameter>transfers</parameter>
      </methodparam>    
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockWrite32</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>baseAddress</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>void*</type><parameter>data</parameter>
      </methodparam>
      <methodparam>
        <type>size_t</type><parameter>transfers</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockCountRead8</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type><parameter>mask</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockCountRead16</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type><parameter>mask</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockCountRead32</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type><parameter>mask</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>addMaskedCountBlockRead32</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>addMaskedCountFifoRead32</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>    
        <modifier></modifier>
        <type>void</type>
        <methodname>addDelay</methodname>
        <methodparam>
            <type>uint8_t</type><parameter>clocks</parameter>
        </methodparam>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>addMarker</methodname>
        <methodparam>
            <type>uint16_t</type><parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier>
        <type>uint8_t</type> <varname>a32UserData</varname>
        <initializer>0x09</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a32UserProgram</varname><initializer>0xa</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier>
        <type>uint8_t</type><varname>a32UserBlock</varname>
        <initializer>0x0b</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint8_t</type>
        <varname>a32PrivData</varname><initializer>0x0d</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier>
        <type>uint8_t</type><varname>a32PrivProgram</varname><initializer>0x0e</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint8_t</type>
        <varname>a32PrivBlock</varname><initializer>0x0f</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a16User</varname><initializer>0x29</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a16Priv</varname><initializer>0x2d</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24UserData</varname><initializer>0x39</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24UserProgram</varname><initializer>0x3a</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24UserBlock</varname><initializer>0x3b</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24PrivData</varname><initializer>0x3d</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24PrivProgram</varname><initializer>0x3e</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24PrivBlock</varname><initializer>0x3f</initializer>
    </fieldsynopsis>

</synopsis>

       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This object is used to build up lists (stacks) of VME commands.
            The normal procedure is to create an instance of a
            <classname>CVMUSBReadoutList</classname> and invoke its member
            functions to build up the list of operations desired.  The resulting
            list is then passed either to
            <classname>CVMUSB</classname>::<methodname>executeList</methodname>,
            which executes the operations in the list immediately and returns
            any data read.  Alternatively, if the list is being created for
            use as a data acquisition mode stack, it is passed to
            <classname>CVMUSB</classname>::<methodname>loadList</methodname>
            to load it into the VM-USB stack memory.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            This section desribes the methods provide by the
            <classname>CVMUSBReadoutList</classname> class and objects.  Several
            parameters are common throughout and will only be explained here.
          </para>
          <para>
            <type>uint8_t</type> <parameter>amod</parameter> is always a VME Bus
            address modifier.  See CONSTANTS below for a list of the address
            modifiers.
          </para>
          <para>
            <type>uint32_t</type><parameter>address</parameter> is the VME
            address that is the source or target of an operation.  
          </para>
          <para>
            <type>uint32_t</type><parameter>baseAddress</parameter> is the
            starting address of a block transfer operation.
          </para>
          <variablelist>
        <varlistentry>
            <term>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <void />
    </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    This is the constructor you will normally use.  It produces
                    an empty VM-USB stack which can be built up using
                    the remaining methods described in this section.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <methodparam>
            <type>std::vector&lt;uint32_t&gt;&amp;</type> <parameter>list</parameter>
       </methodparam>
    </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    This constructor builds a VM-USB list that is intially
                    stocked with the stack contained in <parameter>list</parameter>.
                    This list can be built either by hand or could have been
                    gotten by a call to <methodname>get</methodname> on a
                    previously existinglist.
                    </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <methodparam>
            <modifier>const</modifier> <type>CVMUSBReadoutList&amp;</type>
            <parameter>rhs</parameter>
       </methodparam>
       
    </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Copy constructor.   The existence of this constructor
                    also allows lists to be passed by value to other functions.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                  <modifier></modifier>
                  <type>void</type>
                  <methodname>clear</methodname>
                  <void />
                  <modifier></modifier>
                </methodsynopsis>
                </term>
            <listitem>
                <para>
                    Clears the stack.  This allows a <classname>CVMUSBReadoutList</classname>
                    to be re-used once it has been either loaded or executed.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>size_t</type>
              <methodname>size</methodname>
              <void />
              <modifier>const</modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the number of stack lines. The VM-USB manual
                    defines a stack line as a 32 bit datum.  Most instructions
                    require at least two lines.  Some are even longer.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>std::vector&lt;uint32_t&gt;</type>
              <methodname>get</methodname>
              <void />
              <modifier>const</modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the undelying std::list that is used to store
                    the stack as it is being built.  The return value from
                    this method is also usable in a constructor.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRegisterRead</methodname>
              <methodparam>
                <type>unsigned int</type> <parameter>address</parameter>
              </methodparam>
              <modifier></modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to read a VM-USB internal register.
                    In this case <parameter>address</parameter> is a VM-USB
                    register rather than a VME address. The register addresses
                    are listed in the table in section 3.4 of the VM-USB
                    manual.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRegisterWrite</methodname>
              <methodparam>
                <type>unsigned int</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type> <parameter>data</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to do a write to a VM-USB internal
                    register.  <parameter>data</parameter> is the data to be
                    written.  As with <methodname>addRegisterRead</methodname>,
                    <parameter>address</parameter> is a register file address
                    from the table in section 3.4 of the VM-USB manual.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addWrite32</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type> <parameter>datum</parameter>    
              </methodparam>
              <modifier></modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a command to write a 32 bit <parameter>datum</parameter>
                    to the VME bus.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addWrite16</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>uint16_t</type> <parameter>datum</parameter>
              </methodparam>
              <modifier></modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a command to write a 16 bit <parameter>datum</parameter>
                    to the VME bus.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addWrite8</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>datum</parameter>   
              </methodparam>
            </methodsynopsis>
              </term>
              <listitem>
                <para>
                    Adds an instruction to perform an 8 bit write
                    of <parameter>datum</parameter> to the VME-Bus.
                </para>
              </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRead32</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to do a 32 bit read from the VME
                    bus to the stack.  The data read are either placed in the
                    buffer handed to
                    <classname>CVMUSB</classname>::<methodname>executeList</methodname>
                    or, if the stack is triggered in data taking mode, to the
                    event read for the trigger.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRead16</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to perform a 16 bit read from
                    the VME bus to the stack.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRead8</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to perform an 8 bit read from the VME
                    bus to the stack.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockRead32</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>baseAddress</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>size_t</type><parameter>transfers</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a block read of 32 bit wide quantities to the stack.
                    <parameter>transfers</parameter> is the maximum number of
                    transfers that will be performed.   The transfer will also
                    terminate if VME bus reports a bus error.  In that case,
                    a 32 bit <literal>0xffffffff</literal> will be put in the
                    buffer to mark termination.
                </para>
                <para>
                    If the <parameter>amod</parameter> is a VME block transfer
                    address modifier, the block transfer will only provde an
                    address cycle at the beginning of the transfer and whenever
                    the address crosses a 256 byte boundary as provided for
                    in the VME bus specification for block transfers.  This can
                    significantly improve performance.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addFifoRead32</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>baseAddress</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>size_t</type><parameter>transfers</parameter>
              </methodparam>    
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addBlockRead32</methodname>, however
                    all address cycles will assert
                    <parameter>baseAddress</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addFifoRead16</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>baseAddress</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>size_t</type><parameter>transfers</parameter>
              </methodparam>    
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addFifoRead32</methodname>, however
                    the transfers will be 16 bits wide.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockWrite32</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>baseAddress</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>void*</type><parameter>data</parameter>
              </methodparam>
              <methodparam>
                <type>size_t</type><parameter>transfers</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a block write to the list.  <parameter>data</parameter>
                    is a buffer containing <parameter>transfers</parameter>
                    worth of 32 bit data to transfer.  If a block transfer
                    <parameter>amod</parameter> is used, the controller will
                    only perform address cycles atthe start of the transfer
                    and as the address crosses 256-byte boundaries as provided
                    for in the VME bus block transfer specification. There must
                    be at least 2 transfers for this to succeed. 
                  </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockCountRead8</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type><parameter>mask</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    The VM-USB provides a set of instructions that
                    allow you to perform variable length block transfers.
                    This is done in two steps.   The first step readss the
                    length of the transfer from somewhere on the VME bus
                    (usually this is a module register).  The second step is
                    to actually perform the variable block transfer.
                </para>
                <para>
                    This method adds a stack instruction to perform
                    an 8 bit data transfer from the VME
                    bus and place the result in the output buffer or event.
                    The set of bits in that data defined by <parameter>mask</parameter>
                    are used to set the transfer count for the next variable length
                    block transfer.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockCountRead16</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type><parameter>mask</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addBlockCountRead8</methodname> however
                    the datum transferred from the VME bus is 16 bits wide rather
                    than 8.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockCountRead32</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type><parameter>mask</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addBlockCountRead16</methodname>, however
                    the datum transferred from the VME bus is 32 bits wide
                    rather than 16.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>void</type>
                <methodname>addMaskedCountBlockRead32</methodname>
                <methodparam>
                    <type>uint32_t</type><parameter>baseAddress</parameter>
                </methodparam>
                <methodparam>
                    <type>uint8_t</type><parameter>amod</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    This method adds an instruction to use the transfer count
                    register loaded by one of the <methodname>addBlockCountRead</methodname>xx
                    methods as the transfer count for a block read that is 32 bits wide.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>void</type>
                <methodname>addMaskedCountFifoRead32</methodname>
                <methodparam>
                    <type>uint32_t</type><parameter>address</parameter>
                </methodparam>
                <methodparam>
                    <type>uint8_t</type><parameter>amod</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addMaskedCountBlockRead32</methodname>
                    however all address cycles provide <parameter>address</parameter>
                    on the bus.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>    
                <modifier></modifier>
                <type>void</type>
                <methodname>addDelay</methodname>
                <methodparam>
                    <type>uint8_t</type><parameter>clocks</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a delay of <parameter>clocks</parameter> FPGA cycles
                    to the stack.  Each cyle is 12.5ns long.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>void</type>
                <methodname>addMarker</methodname>
                <methodparam>
                    <type>uint16_t</type><parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to put the literal <parameter>value</parameter>
                    into the output buffer.
                </para>
            </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
        <refsect1>
           <title>CONSTANTS</title>
           <para>
            The class defines a set of constants that are symbolic definitions of
            the VME address modifiers.  Remember that since these constants
            are defined within <classname>CVUSBReadoutList</classname> the
            classname must be used to scope uses of those definitions.
            For example <programlisting>CVMUSBReadoutList::a32UserData</programlisting>.
           </para>
           <variablelist>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier>
                    <type>uint8_t</type> <varname>a32UserData</varname>
                    <initializer>0x09</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME bus standard this is referred to
                        as <firstterm>Extended Non-privileged Data Access</firstterm>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a32UserProgram</varname><initializer>0xa</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME bus standard thisis referred to as
                        <firstterm>Extended Non-privileged program access</firstterm>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier>
                    <type>uint8_t</type><varname>a32UserBlock</varname>
                    <initializer>0x0b</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME bus standard this is referred to as
                        <firstterm>Extended Non-privileged Block Transfer</firstterm>
                        Block transfer address modifiers only require address
                        cycles on the first cycle, to establish the base address
                        and whenver the address would cross a 256 byte boundary.
                        Using block transfers where possible provides a measurable
                        performance improvement.
                    </para>
                    <para>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier> <type>uint8_t</type>
                    <varname>a32PrivData</varname><initializer>0x0d</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME bus standard refers to this as
                        <firstterm>Extended Supervisory Data</firstterm>.
                        Supervisory data accesses are considered to be from
                        a privileged state.
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier>
                    <type>uint8_t</type><varname>a32PrivProgram</varname><initializer>0x0e</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME bus standard refers to this as
                        <firstterm>Extended Supervisory Program access</firstterm>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier> <type>uint8_t</type>
                    <varname>a32PrivBlock</varname><initializer>0x0f</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME bus standard refers to this as
                        <firstterm>Extended Supervisory Block Transfer</firstterm>.
                        Transfers using block transfer modifiers are assumed to
                        go over a contiguous address block.  The bus master only
                        needs to perform an address cycle at the beginning of the
                        transfer and again as the address crosses 256 byte
                        boundaries.
                    </para>
                    <para>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a16User</varname><initializer>0x29</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME standard this is referred to as
                        <firstterm>Short Non-privileged</firstterm>.
                        Short addresses are those that only use 16 bits of
                        address. The address space is assumed to be used for
                        devices.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a16Priv</varname><initializer>0x2d</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME standard this is referred to as
                        <firstterm>Short Supervisory</firstterm>.
                      Short addresses are those that only use 16 bits of
                        address. The address space is assumed to be used for
                        devices.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>  
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24UserData</varname><initializer>0x39</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME standard, this is referred to as
                        <firstterm>Standard Non-privileged Data</firstterm>.
                        Standard address modifiers pay attention to 24 bits of'
                        address.
                    </para>
                    <para>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>      
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24UserProgram</varname><initializer>0x3a</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standard refers to this a
                        <firstterm>Standard Non-Privileged Program</firstterm>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24UserBlock</varname><initializer>0x3b</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standad refers to this as
                        <firstterm>Standard Non-privileged Block</firstterm>.
                        Block transfer address modifiers allow the master to
                        improve performance by only requiring an address cycle
                        at the start of the first transfer and as the block
                        transfer crosses 256 byte address boundaries.
                    </para>
                    <para>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24PrivData</varname><initializer>0x3d</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standard refers to ths as
                        <firstterm>Standard Supervisory Data</firstterm>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24PrivProgram</varname><initializer>0x3e</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standard refers to this as
                        <firstterm>Standard Supervisory Program</firstterm>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24PrivBlock</varname><initializer>0x3f</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standard refers to this as
                        <firstterm>Standard Supervisory Block</firstterm>.
                        Block transfer address modifiers allow the master to
                        improve performance by only requiring an address cycle
                        at the start of the first transfer and as the block
                        transfer crosses 256 byte address boundaries.
                    </para>
                    <para>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
     </refentry>
<!-- /manpage -->
