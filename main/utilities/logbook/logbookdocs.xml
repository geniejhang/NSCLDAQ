<?xml version="1.0" encoding="UTF-8"?>

<!-- chapter utilities -->

<chapter>
   <title>NSCLDAQ Logbook facility</title>
   <para>
    This chapter will describe a new (as of NSCLDAQ-12.0) NSCLDAQ logbook facility.
    The logbook facility:
   </para>
   <itemizedlist>
    <listitem>
       <para>
          Provides for automatic logging of run state transitions as well
          as documenting the current shift on duty when these happen.
       </para>
    </listitem>
    <listitem>
       <para>
          The creation of arbitrary rich content notes that can either be
          associated with a run or independent of a run.
       </para>
    </listitem>
    <listitem>
       <para>
         Provides open interfaces for extension and export by sophisticated
         users programming in any of C++, Tcl or Python.
       </para>
    </listitem>
    <listitem>
       <para>
          Stores its data in a single sqlite3 database file allowing it to be
          easily transported to collaborators who  may either browse it or
          use it as a starting point for documenting the flow and progress of
          experimental analysis.
       </para>
    </listitem>
   </itemizedlist>
   <para>
      The remainder of this chapter will provide tutorial material that describes
      the logbook facility.  Reference material can bge found in the
      <literal>1daq</literal>, <literal>3daq</literal>, and <literal>5daq</literal>
      sections of the manpages. 
   </para>
   <para>
      The tutorial material is organized as follows:
   </para>
   <itemizedlist>
      <listitem>
         <para>
            <link linkend='sec.lg_inventory' endterm='sec.lg_inventory.title' />
            Describes the components of the logbook system and how they all
           fit together.  The discussion will be brief and is intended to
            help you locate reference material when you're ready for it.
         </para>
      </listitem>
      <listitem>
         <para>
            <link linkend='sec.lg_setup' endterm='sec.lg_setup.title' />
           describes the tasks you need to perform to use the NSCL Logbook
            subsystem in an experiment.
         </para>
      </listitem>
      <listitem>
         <para>
            <link linkend='sec.lg_usage' endterm='sec.lg_usage.title' />
            Describes how to use the logbook system in an experiment and beyond.
         </para>
      </listitem>
      <listitem>
         <para>
            <link linkend='sec.lg_export' endterm='sec.lg_export.title' />
            describes what you need to do to export a logbook to another
            location and how collaborators can use the logbook utility at their
            remote facility.
         </para>
      </listitem>
      <listitem>
         <para>
            <link linkend='sec.lg_programming' endterm='sec.lg_programming.title' />
            demonstrates how to use the APIs at various levels to write programs
            to access the database.  This is oriented towards how to build and
            run these programs rather than a detailed description of the
            APIs themselves which are deferred to the reference material.
         </para>
      </listitem>
   </itemizedlist>
   <section id='sec.lg_inventory'>
      <title id='sec.lg_inventory.title'>Components of the NSCL logbook system</title>
      <para>
         In this section we're going to describe what the logbook facility is
         it components and how they all fit together.   
      </para>
      <para>
         First, what is a logbook and what does it hold?  Put simply, a logbook
         is an sqlite3 database file.  Sqlite3 is a file based SQL compliant
         database which provides ACID access without the need for administrative
         actions to create and serve out the database.  Sqlite3
         is described in the web pages in
         <ulink url='https://www.sqlite.org' />.
      </para>
      <para>
         At the physical level, a logbook is, therefore, just a single file
         that contains an Sqlite3 database. The database schema (tables
         and relations between those tables), provide the database with the
         ability to store:
      </para>
      <variablelist>
         <varlistentry>
            <term>People</term>
            <listitem>
                <para>
                  People, are collaborators that work on the experiment.
                  People may run shifts, participate in the analysis or have
                  other roles in the experiment.  The reason people are
                  named and stored in the database is to allow operations
                  and artefacts stored in the logbook to be attributed to them
                  either as individuals or groups of individuals.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>Shifts</term>
            <listitem>
                <para>
                  A shift is a named container for people.  Shifts are intended to
                  capture how experiments are run during data taking.
                  Run state changes in the experiment, which can be automatically
                  logged, are attributed to the shift that's on-duty at the time
                  the transition occurs.  
               </para>
               <para>
                  Shifts should be setup at the beginning of an experiment, but
                  once an experiment starts taking data they should be thought of
                  as read-only.  If necessary, you can create additional shifts.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>Runs</term>
            <listitem>
                <para>
                  A run is a segment of data taking.  Runs have numbers and
                  titles and state transitions (e.g.they begin and they end).
                  The logbook facility has the ability to automatically create
                  runs and log their state transitions.
               </para>
                <para>
                  Run state transitions are logged as having occured during a
                  shift and the shift is stored along with the transition.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>Notes</term>
            <listitem>
                <para>
                  Notes are rich text artifacts that you can enter into the system.
                  In a paper logbook what we call notes are by fare the most
                  common entry.  Notes can be associated with a run or
                  be independent of a run.  Notes have a single author.
               </para>
                <para>
                  Notes are rich text in the sense that they can include
                  figures/graphics that will be stored in the database and associated
                  with their note.  When a note is rendered for view, graphics
                  are rendered inline where they were included.  The
                  contents of the actual files
                  containing the graphics are loaded into the database making
                  the database file all inclusive.
                </para>
                <para>
                  Notes are written using Markdown for formatting.
                  See <ulink url='http://markdownguide.org' /> for more information
                  about markdown.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>Key Value pairs</term>
            <listitem>
                <para>
                  Key value pairs are just a key that points to a textual value.
                  One use of them is to document the experiment the database
                  is a logbook of.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         So now we know what a logbook is and what it can contain, let's look at
         the components of the system.  Logbook system is built in a layered fashion.
         The rough layering is shown in the line drawing below.
      </para>
      <figure>
         <title>Logbook component layering.</title>
         <programlisting>
            
            +-------------------+----------------+
            | ReadoutGUI bundle   cmd utilities  |
            +-------------------+----------------+
            |  Python bindings  | Tcl bindings   |
            +-------------------+----------------+
            | C++ Logbook API                    |
            +------------------------------------+
            | C++ Encapsulation of Sqlite3 API   |
            +------------------------------------+
            |  Sqlite3 API                       |
            +------------------------------------+
         </programlisting>
      </figure>
      <para>
         Note that NSCLDAQ expects an installation of <filename>libsqlite3</filename>
         and its development files to be present.   All other software
         in the figure above are built and distributed into NSCLDAQ.
      </para>
      <para>
         In most cases you will only need to interact with the top level of this
         layer diagram.  If you wish to extend access to the database or provide
         other mechanisms for data entry, you can do that at any of the layers
         shown down to and inluding the raw Sqlite API.  We recommend, however
         you program the data base at the highest level of the diagram that provides
         you with capabilities you need.
      </para>
      <para>
         In addition to the software shown above, and the database file, a
         hidden directory <filename>~/.nscl-logbook</filename> is used
         by the system to pull image files from the database as needed and to
         generate HTML files used for online browsing of the logbook.  The
         contents of this directory can be  cleaned up without affecting proper
         operation of the logbook.  Finally the high level software has the concept
         of a currently selected logbook.  The path to this logbook file is stored
         in
         <filename>~/.nscl-logbook-current</filename>.  If you remove this file,
         You'll need to select the logbook you're operating on using e.g. the
         <filename>$DAQBIN/lg_current</filename> command utility.
      </para>
      <para>
         The ReadoutGUI bundle is a callback bundle for the ReadoutGUI.  When
          it is incorporated into the user's <filename>ReadoutCallouts.tcl</filename>
          file, run transitions will be automatically logged into the currently
          selected database.
      </para>
      <para>
         Several command utilities are provided.  Reference material for these
         are provided in the <literal>1daq</literal> man pages.  Here we
         just gloss over their names what they are and what they do.  All
         command utilities get installed in $DAQBIN and have names starting
         with <literal>lg_</literal>.
      </para>
      <variablelist>
         <varlistentry>
            <term><command>lg_create</command></term>
            <listitem>
                <para>
                  Used to create a new logbook.  When logbooks are created,
                  the filename of the new logbook must be supplied and information
                  about the experiment.  The new logbook can optionally be made
                  current.
                  See
                  <link linkend='daq1.lg_create' endterm='daq1.lg_create.title' />
                  for more information.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>lg_current</command></term>
            <listitem>
                <para>
                  Selects the current logbook database file.  This is the
                  logbook that will be operated on by the remaining
                  <command>lg_*</command> commands and admin level Tcl bindings.
                  See
                  <link linkend='daq1.lg_current' endterm='daq1.lg_current.title' />
                  for more information.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>lg_ls</command></term>
            <listitem>
                <para>
                  Outputs the name of the logbook that is current.
                  See
                  <link linkend='daq1.lg_ls' endterm='daq1.lg_ls.title' />
                  for more information.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>lg_addperson</command></term>
            <listitem>
                <para>
                  Makes a new person known to the logbook. People are stored
                  as salutation, last name and first name.  People are used
                  as authors and are members of shifts.
                  See
                  <link linkend='daq1.lg_addperson' endterm='daq1.lg_addperson.title' />
                  for more information
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>lg_lspeople</command></term>
            <listitem>
                <para>
                  Lists the people that have been defined to the database.
                  See
                  <link linkend='daq1.lg_lspeople' endterm='daq1.lg_lspeople.title' />
                  for more information
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>lg_mkshift</command></term>
            <listitem>
                <para>
                  Creates new shifts.  A shift is a collection of people that
                  are working on a running experiment at the same time.  You
                  can create as many shifts as you want and compose them any way
                  you want.  The people that are in shifts must have previously
                  been added to the log book via <command>lg_addperson</command>
                  See
                  <link linkend='daq1.lg_mkshift' endterm='daq1.lg_mkshift.title' />
                  for more information
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>lg_mgshift</command></term>
            <listitem>
                <para>
                  Provides the capability of managing your shifts.  This
                  command provides three functions:
               </para>
                <itemizedlist>
                  <listitem>
                     <para>
                        The ability to create new shifts and assign people to them. 
                     </para>
                  </listitem>
                  <listitem>
                     <para>
                        The ability to edit existing shifts, adding and removing
                        people from them.
                     </para>
                  </listitem>
                  <listitem>
                     <para>
                        The  ability to list the shifts and their members.
                     </para>
                  </listitem>
                </itemizedlist>
                <para>
                  Note that shifts should be set up prior to starting to run the
                  experiment.  Once a named shift has been on duty and started/stopped
                  runs, it must not be modified.  This is because run transition
                  records in the logbook
                  don't carry along with them references to the people on shift,
                  but references to the on-duty shift.
                </para>
                <para>
                  Thus if a shift is edited mid-experiment, the documentation
                  of the on-duty shift associated with a run state transition will
                  be correct but the members of that shift will reflect the most
                  recent editing of the shift.  This can attribute a transition
                  to the wrong set of people, and that's not desirable.
                </para>
                <para>
                  See
                  <link linkend='daq1.lg_mgshift' endterm='daq1.lg_mgshift.title' />
                  for more information
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>lg_selshift</command></term>
            <listitem>
                <para>
                  Selects the on-duty shift.  In order for the logbook callback
                  bundle to allow run state transitions an on-duty shift must
                  be selected.  The transition is then attributed to the
                  members of the on-duty shift.
               </para>
                <para>
                  See
                  <link linkend='daq1.lg_selshift' endterm='daq1.lg_selshift.title' />
                  for more information
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>lg_kvstore</command></term>
            <listitem>
                <para>
                  The key-value store (kvstore) is just a set of key/value pairs.
                  This command allows you, at the level of a command shell, to determine
                  test for the existence of a key, get the value of a key, set the value
                  of an existing or new key, or create a new key value pair.
               </para>
                <para>
                  See
                  <link linkend='daq1.lg_kvstore' endterm='daq1.lg_kvstore.title' />
                  for more information
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>lg_wrnote</command></term>
            <listitem>
                <para>
                  Provides a composer for notes.  Notes have an author and optionally
                  are associated with a run.  Notes are rich text items via
                  markdown format.   Images can be incorporated into notes
                  using an image selector or by manually inputting
                  markdown image links.  Image files for a note are sucked
                  into the database and retrieved as needed when a note is
                  rendered.
               </para>
                <para>
                  See
                  <link linkend='daq1.lg_wrnote' endterm='daq1.lg_wrnote.title' />
                  for more information
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>lg_browse</command></term>
            <listitem>
                <para>
                  Provides a visual logbook browser.
               </para>
                <para>
                  See
                  <link linkend='daq1.lg_browse' endterm='daq1.lg_browse.title' />
                  for more information
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>lg_print</command></term>
            <listitem>
                <para>
                  Allows all or part of a logbook to be rendered in PDF,
                  presumably for later printing.
               </para>
                <para>
                  See
                  <link linkend='daq1.lg_print' endterm='daq1.lg_print.title' />
                  for more information
                </para>
            </listitem>
         </varlistentry>
      </variablelist>
   </section>
   <section id='sec.lg_setup'>
      <title id='sec.lg_setup.title'>Setting up a logbook for use.</title>
      <para>
         This section will go over the tasks you need to perform to setup a
         logbook for use in an upcoming experiment. We will describe:
      </para>
      <itemizedlist>
         <listitem>
            <para>
               How to create a logbook database file and make it current. 
            </para>
         </listitem>
         <listitem>
            <para>
               How to add people to your logbook.  People added to a logbook
               can have items (notes, run transitions) associated with them.
               You should add everyone who is working on your experiment to your
               logbook.
            </para>
         </listitem>
         <listitem>
            <para>
               How to create shifts which indicate which groups of people
               will be on duty simultaneously during data collection.
               Run state transitions (e.g. begin run actions) are attributed
               to the current shift, and by extension the members of that current
               shift.
            </para>
         </listitem>
         <listitem>
            <para>
               How to setup your ReadoutCallouts.tcl file to automate
               run state transition logging.
            </para>
         </listitem>
      </itemizedlist>
   
      <section>
         <title>Creating a logbook and making it current.</title>
         <para>
            The <command>lg_create</command> command (in <filename>$DAQBIN</filename>),
            allows you to create a new logbook and optionally make it current.
            When you create a logbook you must not only provide the filename
            into which the logbook will be stored, but information about
            what they logbook is for that will be stored in the key value store
            of the logbook.  Specifically  you need to provide:
         </para>
         <variablelist>
            <varlistentry>
               <term>Experiment-id</term>
               <listitem>
                   <para>
                     The experiment this logbook is used for.  This is normally
                     an experiment id assigned by the facility in which the
                     experiment is being performed.  For example
                     <literal>e17011</literal> is an NSCL/FIRB experiment
                     approved by the 2017 PAC.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Spokesperson</term>
               <listitem>
                   <para>
                     The name of the experiment's spokesperson or other responsible
                     person.  This, as with all values in the key value store
                     is free form text.  The system doesn't care
                     if, for example, I use <literal>Mr. Ron Fox</literal>,
                     or <literal>Fox, Ron</literal>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Purpose</term>
               <listitem>
                   <para>
                     Should be a brief statement of the purpose of the logbook.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            The command line for <command>lg_create</command> requires that
            you provide the filename and, if you want to make the logbook
            current, the -current flag. All other parameters are
            graphically prompted if not supplied.  If you issue the
            <command>lg_create</command> command by itself, its usage
            will be output.  The example below shows how to create a
            logbook for an experiment and make it the current logbook.
         </para>
         <example>
            <title>Creating a logbook and making it current</title>
            <programlisting>
$DAQBIN/lg_create -filename ~/e17011.logbook -current 1 \
   -experiment e17011 -spokesperson "Ben Crider" -exp-purpose "Beta decay in 80Ge"
            </programlisting>
         </example>
      </section>
      <section>
         <title>Organizing the people on an experiment</title>
         <para>  
            It seems obvious to say so but experiments are run by people. During
            data taking, those people are organized into shifts.  When runs
            undergo state transitions (start, stop, pause, resume), it's important,
            not only, to log that this happened, but which shift was on duty
            at the time.
         </para>
         <para>
            The NSCLDAQ logbook facility provides the following facilities to
            manage the members of an experiment.
         </para>
         <itemizedlist>
            <listitem>
               <para>
                   People can be added to the experiment logbook.
               </para>
            </listitem>
            <listitem>
               <para>
                  Shifts can be created which contain an arbitrary number
                  of people that are known to the logbook
               </para>
            </listitem>
            <listitem>
               <para>
                  The <firstterm>current shift</firstterm> can be specified.
                  The current shift is the shift that's on duty and, therefore,
                  will be associated with data taking state transition log entries.
               </para>
            </listitem>
         </itemizedlist>
         <para>
            Shifts should be static once data taking has started.  This is because
            it is a shift that's associated with a run state transition, not the
            current members of that shift.   Consider the following case as an example.
         </para>
         <para>
            Suppose I have an experiment with three members, A, B, C. Suppose,
            I make a shift called S which and add members A and B to it, and make
            that the current shift.  Now I start a run.  That's associated with
            shift S. I end the run.  If I then edit shift S to remove person B
            and add person C, the run I just take, is still associated with
            shift S and therefore thinks data taking was during a shift that
            involved person A and C rather than person A, and B -- because shift
            S was edited out from underneath that run.
         </para>
         <para>
            You can make new shifts at any time.  If shift membership changes
            during the run, just make a new shift and and add the proper members
            to it.
         </para>
         <section>
            <title>Adding People.</title>
            <para>
               People are added to the currently selected logbook using
               <command>lg_addperson</command>.  People are defined by a
               last name, a first name and an optional salutation (e.g. Prof. or Ms.).
               The examples below add people to the current logbook
            </para>
            <example>
               <title>Using <command>lg_addperson to add people to the logbook</command></title>
               <programlisting>
$DAQBIN/lg_addperson Fox Ron  Mr.         # Mr. Ron Fox
$DAQBIN/lg_addperson Cerizza Giordano Dr. # Dr. Giordano Cerizza
$DAQBIN/lg_addperson Student Graduate     # Graduate Student (no salutation)
$DAQBIN/lg_addperson                      # Graphically prompt for person.
               </programlisting>
            </example>
         </section>
         <section>
            <title>Using <command>lg_mkshift</command> to create and poopulate shifts</title>
            <para>
               The example below shows how to use <command>lg_mkshift</command>
               both to create and empty shift, that can be edited using
               the shift manager, <command>lg_mgshift</command> and create
               a shift stocking it with an initial set of people.
            </para>
            <example>
               <title>Using <command>lg_mkshift</command></title>
               <programlisting>
$DAQBIN/lg_mkshift  swing           # Make empty shift named swing.
$DAQGIN/lg_mkshift                  # Bring up shift editor.
               </programlisting>
            </example>
            <para>
               The second form of the <command>lg_mkshift</command> command
               brings up a graphical editor that allows you to create a shift
               and stock it with people.  This editor is shown in
               <link linkend="fig.lg_shifteditor" endterm='fig.lg_shifteditor.title' />
               below.
            </para>
            <figure id='fig.lg_shifteditor'>
                <title id='fig.lg_shifteditor.title'>The shift editor</title>
                <graphic fileref='shifteditor.jpg' />
            </figure>
            <para>
               In this figure, the left list contains the list of people known
               to the logbook. You can select one or more of them and click the
               <guibutton>-&gt;</guibutton> button to add those people to the shift.
               The list on the right contains the members of the shift you are
               building to this point. You can remove members from the shift
               by selecting them and clicking the <guibutton>&lt;-</guibutton>.
               Finally, the entry at the lower left is where you should enter the
               shift's name.  Click <guibutton>Ok</guibutton> to attempt to create
               the shift and <guibutton>Cancel</guibutton> to abandon shift creation.
            </para>
            
         </section>
         <section>
            <title>Using <command>lg_mgshift</command> and <command>lg_selshift</command></title>
            <para>
               <command>lg_mgshift</command> is a shift management program.  It
               allows you to create, edit and list members of shift.
            </para>
            <para>
               If you created an empty shift using <command>lg_mkshift</command>,
               you can use <command>lg_mgshift</command> to stock it with people.
            </para>
            <para>
               Here are examples of <command>lg_mgshift</command> in use.
            </para>
            <example>
               <title>Using <command>lg_mgshift</command> to manage shifts</title>
               <programlisting>
$DAQBIN/lg_mgshift create              # Create/edit shift
$DAQBIN/lg_mgshift create newshift     # Create/edit with newshift as the shiftname.
$DAQBIN/lg_mgshift edit                # Select a shift from a list of shifts then edit it.
$DAQBIN/lg_mgshift edit oldshift       # Edits with oldshift as the shiftname.
$DAQBIN/lg_mgshift list                # Lists all shift and their members.
$DAQBIN/lg_mgshift list owl            # Lists the members of the owl shift.
               </programlisting>
            </example>
            <para>
               Note that <command>lg_mgshift</command> makes use of the
               same shift editor
               (<link linkend='fig.lg_shifteditor' endterm='fig.lg_shifteditor.title' />)
               as <command>lg_mkshift</command>.  It is perfectly reasonable to
               create a shift from an existing shift.  Use the <command>edit</command>
               subcommand and specify the existing shift.  Change the shift name
               to the new shift and modify the shift membership.
            </para>
            <para>
               <command>lg_selshift</command> (Select shift) allows you to select
               the current (on duty shift).  This shift will be associated with
               any data taking state transitions until the next invocation
               of <command>lg_selshift</command> changes the current shift.
            </para>
            <para>
               You can invoke this command in one of two ways:
            </para>
            <example>
               <title>Using <command>lg_selshift</command> to select the current shift</title>
               <programlisting>
$DAQBIN/lg_selshift owl                # Set the current shif to the owl shift.
$DAQBIN/lg_selshift                    # Bring up the graphical shift selector.
               </programlisting>
            </example>
            <para>
               The shift selector is shown in
               <link linkend='fig.lg_selshift' endterm='fig.lg_selshift.title' />
               below.
            </para>
            <figure id='fig.lg_selshift'>
                <title id='fig.lg_selshift.title'>The shift selector.</title>
                <graphic fileref='shiftselector.jpg' />
            </figure>
            <para>
               In the shift selector, the top part of the selector shows the
               current shift, if any, and a list of its members.
               The list box at the bottom left contains a list of the shifts
               that have been defined.  Clicking one will list its members in the
               list box at the bottom right.
            </para>
            <para>
               When you've selected the shift you want to be current, just
               click <guibutton>Apply</guibutton> and that shift will be made
               current and the top of the selector will update.  When the
               shift you want to make current is current, click the
               <literal>X</literal> at the top right if you want to exit.
            </para>
            <para>
               It's quite normal to leave the selector up throughout data taking
               so that shift changes can be easily made without needing to invoke
               <command>lg_selshfit</command> again.
            </para>
         </section>
      </section>
   </section>
   <section id='sec.lg_usage'>
      <title id='sec.lg_usage.title'>Using the logbook in an experiment</title>
      <para>
         Before you start data taking, you should add the logbook subsystem
         to the readout GUI.  This is done by adding the following line to your
         <filename>ReadoutCallouts.tcl</filename> file:
      </para>
      <example>
         <title>Enabling automatic recording of run state transitions</title>
         <programlisting>
package require logbookbundle
         </programlisting>
      </example>
      <para>
         Simple as that.   Since the logbook subsystem makes use of the callback
         bundle facility of the readout GUI, you don't need to add any code
         to any of your <literal>Onxxx</literal> procs.
      </para>
      <para>
         For all runs with recording enabled, the logbook will log all state
         transitions associated with a data taking run.  These include Begin runs,
         End Runs, Pause runs and Resume runs.  Furthermore, when the ReadoutGUI
         starts and the <literal>logbookbundle</literal> is pulled in, the bundle
         checks for a run in progress (from the database point of view).  This can
         happen if the previous run was improperly ended and the ReadoutGUI needed
         to be restarted.  
      </para>
      <para>
         If there is a currently active run, the logbook will log an
         <literal>EMERGENCY_END</literal> state transition for that active run.
         This makes the run inactive and creates a log entry that lets you know,
         when you review that run later on, it was improperly ended.
      </para>
      <para>
         Since the logbook bundle will immediately access the database,
         and since it may also need to log a state transition, prior to starting
         the ReadoutGUi you must:
      </para>
      <orderedlist>
         <listitem>
            <para>
               Ensure you've selected the correct current logbook using
               <command>lg_current</command>.
            </para>
         </listitem>
         <listitem>
            <para>
               Set the current shift using
               <command>lg_selshift</command>
            </para>
         </listitem>
      </orderedlist>
      <para>
         If you neglect to do so you will get errors reported by the
         ReadoutCallouts.tcl.
      </para>
      <section>
         <title>Creating notes</title>
         <para>
            If all the logbook could do is manage shifts and log run state transitions
            it would be pretty worthless.  The notes feature of the logbook
            is what makes it worthwhile.  In this section we'll learn:
         </para>
         <itemizedlist>
            <listitem>
               <para>
                  What a note  is 
               </para>
            </listitem>
            <listitem>
               <para>
                  How to create notes 
               </para>
            </listitem>
            <listitem>
               <para>
                  How to format notes with rich content (including figures). 
               </para>
            </listitem>
         </itemizedlist>
         <para>
            Note that in the next section
            <link linkend='sec.lg_browsing' endterm='sec.lg_browsing.title' />
            we'll talk about what we can do to look at the contents of our logbook
            and how to render it for printing.
         </para>
         <section>
            <title>What is a note?</title>
            <para>
               A note is a formatted chunk of text.  My formatted I mean that
               it can have titles, subtitles, bulleted lists, numbered lists,
               code samples, referencdes to the web and inline images.  We'll cover
               formatting notes in
               <link linkend='sec.lg_mdownprimer' endterm='sec.lg_mdownprimer.title' />
            </para>
            <para>
               All notes are written by someone.  That is, they are associated
               with one, and exactly one person that is known to the logbook.
            </para>
            <para>
               Notes <emphasis>may</emphasis>, or may not be, associated with
               a run.  When choosing if a note should be associated with a run,
               think about wether the content of the note has to do with the
               run or is a more general statement that spans the course of
               more than one run.
            </para>
            <para>
               Notes also have a timestamp associated with them that logs when
               they were created. 
            </para>
            <para>
               While author selection and run association are done manually
               by the person editing and saving the note, the timestamp is generated
               automatically when the note is saved.
            </para>
            <para>
               As with most entities in the logbook (other than shift membership),
               notes are write-once, read-many. As with a paper lab notebook, you're not
               allowed to modify or delete a note once it's been written.
            </para>
         </section>
         <section>
            <title>How can I create a note?</title>
            <para>
               Notes are created using the note editor.  This can be brought up
               either inside the browser (see
               <link linkend='sec.lg_browsing' endterm='sec.lg_browsing.title' />),
               or via the the <command>lg_wrnote</command> command.
            </para>
            <para>
               You can invoke <command>lg_wrnote</command> in one of two ways:
            </para>
            <example>
               <title>Invoking <command>lg_wrnote</command></title>
               <programlisting>
$DAQBIN/lg_wrnote   5            # Note editor initially associated with run 5.
$DAQBIN/lg_wrnote                # Note editor with no initial run association.
               </programlisting>
            </example>
            <para>
               Note carefully, in the above, the word <emphasis>initially</emphasis>.
               The note editor provides a mechanism to set, or for that matter,
               remove association with a run.
               <link linkend='fig.lg_noteeditor' endterm='fig.lg_noteeditor.title' />
               shows what the note editor looks like.
            </para>
            <figure id='fig.lg_noteeditor'>
                <title id='fig.lg_noteeditor.title'>The note editor GUI.</title>
                <graphic fileref='noteeditor.jpg' />
            </figure>
            <para>
               Current author and run association is shown at the top of the
               window.  Author association is a pulldown menu activated by the
               down arrow to the right of it.  Select your name as it's know to the
               database from the list of authors.  Initially no author is shown
               as associated with the note.  If you try to save the note without
               selecting an author an error will be thrown.
            </para>
            <para>
               To the right of the author assocationis the run assocation. In the
               figure, the note we are composing will be associated with run 5.
               To change the run assocation, select a run from the list in the list
               box at the left of the editor window.  For convenience, the first
               few characters of the title are provided to the right of the
               run number.  Simply double click the run the note is to be associated
               with to change the associated run.  If you don't wann a run associated
               with this note, just double click the empty line at the top of the
               listbox.
            </para>
            <para>
               The largest area of the  editor is the big frame at the right. Edit
               the text of your note in this area.  We'll talk a bit more about
               what you can put there besides ordinary text in
               <link linkend='sec.lg_mdownprimer' endterm='sec.lg_mdownprimer.title' />.
            </para>
            <para>
               Image references can be manually inserted but, not only is the
               markdown for that a bit tricky to remember, but you may want
               to browse for the image file to insert.  If you right click in the
               editor window a context menu will be posted. The
               <guimenuitem>Image...</guimenuitem>  menu
               command will bring up a dialog that allows you to specify the image file
               (must be an image file or rendering of the note will fail), and a
               caption for the image:
            </para>
            <figure id='fig.lg_imagesel'>
                <title id='fig.lg_imagesel.title'>The image selector dialog</title>
                <graphic fileref='imageselector.jpg' />
            </figure>
            <para>
               Use the file browser to select the image file and enter any desired
               caption in the caption entry at the bottom of the dialog.
               Click <guibutton>Ok</guibutton>, and the correct image
               link will be inserted at the cursor position in the editor.
               Click <guibutton>Cancel</guibutton> to cancel creation of the image
               link.
            </para>
            <para>
               When the note has been formatted as you want it, click
               <guibutton>Save</guibutton> to save it to the logbook or
               <guibutton>Cancel</guibutton> to abandon the note.
            </para>
            <para>
               Note that the images in image links are loaded into the database
               so it's not necessary to retain the image files in the filesystem
               after the note has been <emphasis>saved</emphasis>.
            </para>
         </section>
         <section id='sec.lg_mdownprimer'>
            <title id='sec.lg_mdownprimer.title'>How do I use Markdown to format my notes?</title>
            <para>
               This section is a non-exhaustive primer on markdown format.
               Markdown is a simple, plain text, formatting system. It allows you
               to easily create rich content. Markdown is used in many wikis,
               as well as in gitlab and github to support formatted text.
            </para>
            <para>
               The full description of Markdown is beyond the scope of this
               document.
               <ulink url='http://https://www.markdownguide.org/' />
               describes Markdown fully.  We use two markdown processors to
               render content:
            </para>
            <variablelist>
               <varlistentry>
                  <term>Tcllib's <literal>Markdown</literal> package</term>
                  <listitem>
                   <para>
                     This simple package is used to render HTML output which is
                     then opened in a web-browser.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term>pandoc</term>
                  <listitem>
                   <para>
                     This program converts markdown to several formats.  We use
                     it to convert Markdown to PDF format. Note that pandoc,
                     generates input for LaTeX which actually produces
                     the PDF via its processing chain.
                   </para>
                </listitem>
               </varlistentry>
            </variablelist>
            <para>
               But I digress. Let's dig into markdown format. First of all,
               text that begins in column 1 is just rendered, for the most part
               as is.   Here are some things in column 1, however that
               can modify this
            </para>
            <variablelist>
               <varlistentry>
                  <term>Headings</term>
                  <listitem>
                   <para>
                     A number of pound symbols <literal>#</literal> specifies
                     the text on the same line to be a heading one pound is
                     a top level heading, two a second level heading, and
                     so on.
                   </para>
                   <para>
                     An alternate syntax for level 1 and two headings:
                     A line of text with a bunch of <literal>=</literal> underneath it
                     is a level 1 heading.
                     A line of text with a bunch of <literal>-</literal> underneath it
                     is a level 2 heading. 
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term>Inline formatting (emphasis).</term>
                  <listitem>
                      <para>
                        Text surrounded by pairs of <literal>*</literal>
                        will be rendered as bold face. For example
                        <literal>**this is bold face**</literal>.
                      </para>
                      <para>
                        Text surrounded by single <literal>*</literal> will be
                        rendered as italic.  For examplle
                        <literal>*this text is italic*</literal>.
                      </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term>Lists</term>
                  <listitem>
                      <para>
                        Both bulleted and numbered lists are supported.
                     </para>
                     <para>
                        If a series of lines are each preceded by a number and period
                        they are rendered like a numbered list for example:
                     </para>
                     <literallayout>
The list starts below:

1. List element 1
2. List element 2  

And is over here.
                     </literallayout>
                     <para>
                        If a series of lines are ech preceded by a <literal>-</literal> they are
                        elements of a bulleted list for example:
                     </para>
                     <literallayout>
List starts below

- First bullet
- second bullet

List ends.
                     </literallayout>
                     <para>
                        Note that many markdown processors require an empty line
                        before and after lists.
                     </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term>Weblinks</term>
                  <listitem>
                   <para>
                     A link to some bit of the web requires both link text and
                     the actual URL.  These are specified as follows:
                     <literal>[link text](URL) For example:</literal>
                   </para>
                   <literallayout>
                     
There's a lot of (information about markdown)[http://google.com/search?q=markdown]

                   </literallayout>
                   <para>
                     Will generate link text <literal>information about markdown</literal>
                     that, when clicked will give google results for <literal>markdown</literal>.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term>Image links</term>
                  <listitem>
                  <para>
                     I strongly suggest letting the note editor produce these for you,
                     but for completeness, an image link  has the form:
                     <literal>![some text](image-file)</literal>
                     The use of the stuff in <literal>[]</literal> depends on the
                     output format.  For web this is used as what is called
                     <firstterm>alt text</firstterm>, that is text that is shown
                     in browsers that are not capable of displaying images.
                     Do not count on this text being displayed.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term>Tables</term>
                  <listitem>
                   <para>
                     The simplest format for a table in markdown uses pipes.
                     For example, this markdown:
                   </para>
                   <literallayout>
You should put a blank line fore:

| Animal | Species |
| -------|---------|
| Wolf   | canis lupus |
| Cat    | felis domesticus |
| Golden Hamster | mesocricetus auratus |

and aft.

                   </literallayout>
                   <para>
                     Note that the table doesn't have to line up nicely. The
                     markdown above generates something like:
                   </para>
                   <informaltable>
                     <tgroup cols='2'>
                        <tbody>
                           <row>
                              <entry>Animal</entry><entry>Species</entry>
                           </row>
                           <row>
                              <entry>Wolf</entry><entry>canis lupus</entry>
                           </row>
                           <row>
                              <entry>Cat</entry><entry>felis domesticus</entry>
                           </row>
                           <row>
                              <entry>Golden Hamster</entry><entry>mesocricetus auratus</entry>
                           </row>
                        </tbody>
                     </tgroup>
                   </informaltable>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term>Footnotes</term>
                  <listitem>
                  <para>
                     A link to a footnote isof the form
                     <literal>[^n]</literal> where n is a footnote
                     number (e.g. <literal>[^1]</literal> for footnote).
                     The footnote text itself (for footnote 1 e.g.) is
                     entered as follows:
                   </para>
                  <literallayout>
I would put a blank line fore:

[^1]:  See the NSCL radiation safety  manual for more

And, if appropriate aft.
                  </literallayout>
                  <para>
                     In the web, the footnote text will, most likely, render in position
                     in the document while LaTeX will determine where it
                     shows up in PDF rendering.
                  </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term>Internal document links</term>
                  <listitem>
                   <para>
                     A heading can have an identifier attached to it and links
                     to that identifier for example:
                   </para>
                   <literallayout>
Table of contents:

...
[Some Section](#Some-section)
...

## Some Section {#Some-section
}
                   </literallayout>
                   <para>
                     Creates a link to a level 2 heading in the document named
                     <literal>Some Section</literal>.
                   </para>
                </listitem>
               </varlistentry>
            </variablelist>
            <para>
               Markdown can do much much more.  I encourage you to play with a toy
               logbook and browse through
               <ulink url='https://www.markdownguide.org/basic-syntax/' />
               for basic syntax supported by all markdown processors and
               <ulink url='https://www.markdownguide.org/extended-syntax/' />
               for syntax most markdown processors support.   I have not exhaustively
               checked which bits of extended markdown are supported by the Tcl
               <literal>Markdown</literal> package and <literal>pandoc</literal>.
               Play around and see what you get.
            </para>
         </section>
      </section>
      <section id='sec.lg_browsing'>
         <title id='sec.lg_browsing.title'>Browsing and rendering the logbook</title>
         <para>
            A logbook you can write in but can't look at is worthless.  This
            chapter describes the <command>lg_browse</command> command which provides
            a graphical browser for the logbook. 
         </para>
         <para>
            For now let's just look at the main features of the browser.
         </para>
         <figure id='fig.lg_browser'>
             <title id='fig.lg_browser.title'>Logbook Browser</title>
             <graphic fileref='lg_browser.jpg' />
         </figure>
         <para>
            In a bit we'll take deeper dives into the user interface.  For now
            note the tabs at the top of the interface:
         </para>
         <variablelist>
            <varlistentry>
               <term><literal>LogBook</literal></term>
               <listitem>
                   <para>
                     Allows you to browse the runs, notes associated with runs
                     and notes not associated with any run. 
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Shifts</term>
               <listitem>
                   <para>
                     Allow you to view the shifts you have created, as well as
                     the members of those shifts.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>People</term>
               <listitem>
                   <para>
                     Allows you to brows the people that you've added to the logbook.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <section>
            <title>People Tab</title>
            <para>
               Let's look at the contents of the <literal>People</literal> tab:
            </para>
            <figure>
                <title><command>lg_browse</command> <literal>People</literal></title>
                <graphic fileref='lg_peopletab.jpg' />
            </figure>
            <para>
               As you can see, this tab provides a list of the people that have
               been added to the logbook.  If you right click anywhere in the
               list, you'll bring up a context men. Clicking
               <guimenuitem>Add...</guimenuitem> on this menu will allow you
               to specify the first name, last name, and optional salutation
               of a person to add the logbook.
            </para>
         </section>
         <section>
            <title>Shifts Tab</title>
            <para>
               Let's have a look at the shift tab of the browser:
            </para>
            <figure>
                <title><command>lg_browse</command> <literal>Shifts</literal> tab</title>
                <graphic fileref='lg_shifttab.jpg' />
            </figure>
            <para>
               As you can see the shifts are listed.  Clicking on a shift opens it
               up (as has been done for the <literal>day</literal> shift) to
               list the members of that shift.  If there's a current shift,
               the word <literal>(current)</literal> is shown by its name.
            </para>
            <para>
               If a shift or one of its members has been selected, right clicking
               brings up a context menu with the following commands:
            </para>
            <variablelist>
               <varlistentry>
                  <term><guimenuitem>Add Shift...</guimenuitem></term>
                  <listitem>
                   <para>
                     Brings up the shift editor so that you can add a new shift
                     and populate it with members.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><guimenuitem>Edit...</guimenuitem></term>
                  <listitem>
                   <para>
                     Brings up the shift editor with the currently selected
                     shift loaded into it for editing or for use as a starting
                     point to create a new shift.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><guimenuitem>Set Current</guimenuitem></term>
                  <listitem>
                  <para>
                     Makes the selected shift the current shift.  That shift
                     will be associated with run state transitions.
                   </para>
                </listitem>
               </varlistentry>
            </variablelist>
         </section>
         <section>
            <title>LogBook Tab</title>
            <para>
               During and after a run, you will probably spend most of your time
               on the <literal>LogBook</literal> tab. This tab allows
               you to access all of the runs that have been recorded and notes that
               have been written.  The figure below shows this tab with some of
               the items expanded:
            </para>
            <figure>
                <title><command>lg_browse</command> command's <literal>LogBook</literal> tab</title>
                <graphic fileref='lg_logbooktab.jpg' />
            </figure>
            <para>
               First note that this tab, as with all tabs in the browser periodically
               updates its contents.  This is done in such a way as to preserve
               the open items.  Thus changes performed by other programs and other
               people are reflected dynamically by the browser.
            </para>
            <para>
               At the top of the list of items in this tab, is an entry
               labeled <literal>None</literal>.  If this is expanded you will
               see a list of the notes that were created that were not associated
               with any run.
            </para>
            <para>
               Below that, each numbered entry is a run.  The title for the run
               is shown on that line as well as the state of that run.  In this
               example, there are no active runs.  Expanding a run lists all of
               its transitions, when they occured and the remarks associated with
               each transition (in this case that they were automatically logged),
               and name of the active shift when the transition occured. Finally the
               transition time is aslo shown
            </para>
            <para>
               Each transition can be further expanded.  When that's done the
               list of people on that shift are listed.
            </para>
            <para>
               Entries are also shown for each note associated with the run.
               In this case the notes were added after the run ended (perfectly legal),
               The notes, however are normaly interleaved with the transitions so
               that everything that was done with a run is listed in
               chronological order.
            </para>
            <para>
               At any time a single item can be selected.  right clicking brings
               up a context menu with the following actions:
            </para>
            <variablelist>
               <varlistentry>
                  <term><guimenuitem>Compose Note...</guimenuitem></term>
                  <listitem>
                  <para>
                     Allows you to compose a new note.  If the selected item
                     is in a run (vs. in the <literal>None</literal>) item,
                     the initially selected associated run in the note editor
                     will be that run.  If you want to associate the note to
                     a different run or write a new note not associated with any
                     run, naturally, you can change this association in note
                     editor.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><guimenuitem>Make PDF from selected..</guimenuitem></term>
                  <listitem>
                   <para>
                     Creates a PDF file from the selected item.  If a run
                     or a transition within a a run is selected a PDF of all
                     of the items (transitions and notes) will be created.
                     If a note is selected only that selected note will be converted.
                   </para>
                   <para>
                     You will be prompted for the path of the PDF file to be
                     created.  Due to restrictions in the <command>pandoc</command>
                     markdown->PDF conversion software this file 
                     <emphasis>must</emphasis> have a <literal>.pdf</literal>
                     extension.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><guimenuitem>Make PDF from whole book...</guimenuitem></term>
                  <listitem>
                   <para>
                     Renders the entire logbook as a PDF. You will be prompted
                     for a PDF filename (extension must be <literal>.pdf</literal>).
                     The logbook will be rendered in the following order:
                     First the runs and their contents (transitions and notes)
                     will be rendered.  Finally, the notes not associated with
                     any runs will be rendered in chronological order.
                   </para>
                </listitem>
               </varlistentry>
            </variablelist>
            <para>
               Finally, double clicking a note will build an HTML rendering of the
               note and invoke your default web browser to view it.
            </para>

      </section>
      <section>
            <title><command>lg_print</command></title>
            <para>
               Sometimes you may want to produce PDF for a logbook, or a part of
               a logbook without bothering with the browser application.
               <command>lg_print</command> allows you to do that. The
               <command>lg_print</command> command can produce PDF for the
               entire logbook or specified parts of the logbook,  in the order
               you specify.
            </para>
            <para>
               <command>lg_print</command> requires a PDF filename
               which must have the extension <literal>.pdf</literal> in order
               to comply with the pandoc converter needs. The remaining command
               parameter specify run numbers or the text <literal>none</literal>.
               For each run number the run is rendered in PDF (as in <command>lg_browse</command>).
               If <literal>none</literal> is specified the notes not bound to
               any run are rendered in chronological order.
            </para>
            <para>
               Here are some examples:
            </para>
            <example>
               <title>Using <command>lg_print</command></title>
               <programlisting>
                  
$DAQBIN/lg_print logbook.pdf                    # print the whole logbook.
$DAQBIN/lg_print logbook.pdf none 1 2 3         # print unassoc notes,  runs 1 2 3
$DAQBIN/lg_print logbook.pdf none               # Print only unassoc notes.
$DAQBIN/lg_print logbook.pdf 1 2 3 10           # print runs 1 2 3 10.

               </programlisting>
            </example>
            <para>
               Invoking <command>lg_print</command> with no parameters will
               output simplified usage help text.
            </para>
         </section>
      </section>
   </section>
   <section id='sec.lg_export'>
      <title id='sec.lg_export.title'>Making logbooks available to collaborators</title>
      <para>
         This chapter will describe how to export a logbook for use outside
         of the NSCL.  While the logbook is a simple file and can easily
         be copied anywhere, you also need the logbook software in order to
         use it.
      </para>
      <para>
         This section will describe how to use the NSCL linux containers
         to install NSCLDAQ so that you can use the logbook facility with
         minimal hassle.  You will need a linux computer at your home institution
         that can run the singularityc container system.
      </para>
      <para>
         The remainder of this chapter will:
      </para>
      <itemizedlist>
         <listitem>
            <para>
               Describe how to obtain and the NSCL-linux singularity container. 
            </para>
         </listitem>
         <listitem>
            <para>
               How to get the NSCLDAQ binary distribution you need 
            </para>
         </listitem>
         <listitem>
            <para>
               How to install the container and NSCLDAQ binary installtion
               tree on your system
            </para>
         </listitem>
         <listitem>
            <para>
               How to run the singularity container so that you can
               use the logbook system.
            </para>
         </listitem>
      </itemizedlist>
      <section>
         <title>Obtaining a suitable NSCL-linux container</title>
         <para>
            First a bit about what a container image is and what singularity is.
         </para>
         <para>
            Container technology provides a light-weight scheme for executing
            user land software for one distribution of linux on the run-time
            environment of another distribution.  For example, At the NSCL,
            we use and have established reasonable methods for installing our software
            on Debian systems.  Your institution may run a Red Hat Enterprise
            Linux base distribution such as CentOS.  The names and availablility
            of packages needed to support NSCLDAQ may differ.
         </para>
         <para>
            Rather than trying to figure out how to install NSCLDAQ on all Linux
            distributions, wouldn't it be nice if you could run a simple program
            and your filesystem containing the Linux userland programs and libraries
            would be Debian?  This is what singularity container images provide.
         </para>
         <para>
            A singularity container image can be thought of as a part of a filesystem
            that gets overlaid on top of the running Linux system filesystem
            while you are running that container.  This allows us to provide
            you with a Debian environment that you can run on your e.g. CentOS
            environment.  Because singularity containers only play games with what
            the filesystem look like, the overhead for running a container is
            essentially nonexistent once a program starts.
         </para>
         <para>
            What you <emphasis>will</emphasis> need, however is the singularity
            container run-time environment.  For Debian like systems (e.g.
            Ubuntu, Kubuntu etc.), this is provided by the <literal>singularity-container</literal>
            package.  For RHEL based systems <command>yum</command> can be used
            to install the <literal>singularity</literal> package.  For
            general installation instructions that can be used to guide you through
            other linux distributions, see the singularity Admin guide for the
            appropriate version of singularity at
            <ulink url='https://sylabs.io/docs/' />.
         </para>
         <para>
            In order to keep our singularity image small, and to avoid re-making
            it for each NSCLDAQ or SpecTcl update (you can use Singularity to also
            install SpecTcl), our images only contain the linux packages needed
            to support our software and we use filesystem binding to keep
            our container images separate from the actual software installation
            trees.  This is why you need to get both an image and a corresponding
            binary installation tree.
         </para>
         <para>
            Our images are installed at the NSCL in <filename>/usr/opt</filename>
            with names like <filename>nscl-<replaceable>code-word</replaceable>.img</filename>
            where <replaceable>code-word</replaceable> is the linux distribution
            code-word.  For example, as I'm writing this, we have two images:
            <filename>/usr/opt/nscl-jessie.img</filename> which provides
            a Debian-8 (jessie) environment and
            <filename>/usr/opt/nscl-buster.img</filename> which  provides
            a Debian-10 (buster) environment.
         </para>
         <para>
            At NSCL/FRIB your experiment will, in general run in a container.
            For simplicity, choose the container you used for your experiment,
            and copy it to your institution.  While 'large', the images are not
            enormous clocking in at about 2GB for the buster image.
         </para>
      </section>
      <section>
         <title>Getting the NSCLDAQ binary distribution</title>
         <para>
            The simplest way to get this is to run the container you used
            for your experiment in the same way you ran it during the experiment.
            When you do, the evironment variable <literal>DAQROOT</literal>
            will point to the installation tree you'll need to grab.
         </para>
         <para>
            The following creates a <firstterm>tarball</firstterm> of that
            directory tree in your home directory:
         </para>
         <informalexample>
            <programlisting>
cd $DAQROOT
tar czf ~/nscldaq-install.tar.gz .
            </programlisting>
         </informalexample>
         <para>
            Pull the resulting tarball, <filename>~/nscldaq-install.tar.gz</filename>
            over to your home institution.  The resulting tarball should be
            smaller than 200Mbytes.  Also make note of the value of the
            <literal>DAQROOT</literal>
            environment variable.  You'll need it later.  
         </para>
      </section>
      <section>
         <title>Installing your container and NSCLDAQ tree.</title>
         <para>
            So you've got a container and a tarball of an NSCLDAQ installation
            tree.  You need to put the container image somewhere and
            unroll the <filename>nscldaq-install.tar.gz</filename> tarball
            somewhere where it's easy to coerce singularity to map that directory
            tree back to its original position in the directory tree.
         </para>
         <para>
            To do this, I'm going to assume you have some directory somewhere
            for simplicity, we'll call it <filename>/nscldaqinstall</filename>
            modify these instructions to match where you actually put this stuff.
            Note that centralizing this installation will allow anybody with read
            access to the container and the NSCLDAQ directory tree to use
            its software.
         </para>
         <para>
            first put your container (for simplicity I'm going to assume you
            grabbed <filename>nscl-buster.img</filename>) in
            <filename>/nscldaqinstall/nscl-buster.img</filename>.
         </para>
         <para>
            Next unwrap the tarball as follows (I'm going to assume DAQROOT claimed)
            it was <filename>/usr/opt/nscldaq/12.0-000</filename>), and that the
            tarball is now sitting in your home directory.
         </para>
         <informalexample>
            <programlisting>
mkdir /nscldaqinstall/opt-buster       # in case later you get a second container.
mkdir -p /nscldaqinstall/opt-buster/nscldaq/12.0-000  # We'll put tuff here.
(cd /nscldaqinstall/opt-buster; ln nscldaq daq);   # NSCL has this convenience link.
(cd /nscldaqinstall/opt-buster/nscldaq/12.0-000; tar xzf ~/nscldaq-install.tar.gz)

            </programlisting>
         </informalexample>
         <para>
            Ok, let's review what we've done and why. First we installed
            our container where we can get it.  Second we produced a directory tree
            that can be mapped on to /usr/opt in the container that mimics what
            NSCL does and put the contents of our tarball in the correct part of
            that directory tree.  If we wanted to haul SpecTcl 5.3-010 over, for example,
            we'd just need to add <filename>/nscldaq/opt-buster/spectcl/5.3-010</filename>
            grab a tarball as we did for NSCLDQAQ and unwrap it there.  Similarly
            if we need additional versions of NSCLDAQ or spectcl we can grab
            additional tarballs and drop them in appropriate parts of the
            <filename>/nscldaqinstall/opt-buster</filename> directory tree.
            We could even grab the installation of root in /usr/opt from NSCL
            and drop that in (we'd need that for SpecTcl and we might just want
            it in the container after all).
         </para>
      </section>
      <section>
         <title>Running the singularity container</title>
         <para>
            Now we're ready to get going. We're going to use the
            <command>singularity</command> command to overlay the
            filesystem in the container image we grabbed onto our linux userland
            filesystem and overlay, or in singularity terms <firstterm>bind</firstterm>
            <filename>/nscldaqinstall/opt-buster</filename> into <filename>/usr/opt</filename>
            in the container.
         </para>
         <para>
            Here's the singularity command to so so (assuming you grabbed
            nscl-buster.img):
         </para>
         <informalexample>
            <programlisting>
singularity shell --bind /nscldaqinstall/opt-buster:/usr/opt \
   /nscldaqinstall/nscl-buster.img
            </programlisting>
         </informalexample>
         <para>
            If you do this you should wind up with a shell and prompt that looks like:
            <literal>Singularity nscl-buster.img:~></literal> indicating you're
            executing inside the singularity container. Some things to note:
         </para>
         <itemizedlist>
            <listitem>
               <para>
                  Your home directory tree is available where it normally is. 
               </para>
            </listitem>
            <listitem>
               <para>
                  Your current default directory tree at the time you
                  started singularity is available as your
                  current default directory 
               </para>
            </listitem>
            <listitem>
               <para>
                  <filename>/usr/opt/daq</filename>, or
                  <filename>/usr/opt/nscldaq</filename>
                  should contain the
                  NSCLDAQ installation directory tree you pulled over from the
                  NSCL and you can e.g.
                  <command>. /usr/opt/daq/12.0-000/daqsetup.bash</command>
                  to setup  the full set of NSCLDAQ environment variables will
                  be created. 
               </para>
            </listitem>
   
         </itemizedlist>
         <para>
            When you start a container,  you can specify additional bindings
            from your host filesystem into your container.  bindports have the
            form <literal>source[:dest]</literal> where <literal>source</literal>
            is where the directory tree being bound is located in the host filesystem
            and the optional <literal>dest</literal> is where that directory tree
            should appear in the container filesystem.  If the destination
            is not supplied, the source is bound to the same location it appears
            in the host.
         </para>
         <para>
            Suppose, for example, you have a directory tree; <filename>/projects</filename>
            you want to appear as <filename>/projects</filename> you can start
            the container as:
         </para>
         <informalexample>
            <programlisting>
singularity shell --bind /nscldaqinstall/opt-buster:/usr/opt,/projects \
   /nscldaqinstall/nscl-buster.img
               
            </programlisting>
         </informalexample>
         <para>
            To make this happen.
         </para>
      </section>
   </section>
   <section id='sec.lg_programming'>
      <title id='sec.lg_programming.title'></title>
      <para>
         This section shows how to program the database via the API in the context
         of a very simple program.  Our goal is not so much an exhaustive coverage
         of the API, that's available in the reference pages.
         The goal is to show how to build and how to run software that
         makes use of the logbook API.
      </para>
      <para>
         In the following sections, we present a simple program that can
         extract the value of a key in the key value store and output it to
         stdout. The program will be presented in C++, Tcl and Python along
         with build instructions.  The source code for these examples are
         available in <filename>$DAQROOT/share/examples/logbook</filename>
      </para>
      <section>
         <title>Using the logbook API from C++</title>
         <para>
            Here's the C++ implementation of our toy program, kvexample.cpp:
         </para>
         <example>
            <title>C++ example using logbook API</title>
            <programlisting>
#include &lt;LogBook.h&gt;             <co id='lgcppapi_header' />
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdexcept&gt;

int main(int argc, char** argv)
{
  if (argc  != 3 ) {                 <co id='lgcppapi_usage' />
    std::cerr &lt;&lt; "kvexmple logbookdatabase key\n";
    exit(EXIT_FAILURE);
  }
  try {                              <co id='lgcppapi_try' />
    const char* key = argv[2];
    LogBook book(argv[1]);            <co id='lgcppapi_construct' />
    if (book.kvExists(key)) {         <co id='lgcppapi_exists' />
      std::cout &lt;&lt; key &lt;&lt; " : "
                &lt;&lt;  book.kvGet(key) <co id='lgcppapi_get' />
                &lt;&lt; std::endl;
    } else {
      std::cerr &lt;&lt; key &lt;&lt; " does not exist\n";
      exit (EXIT_FAILURE);
    }
  } catch (std::exception&amp; e) {    <co id='lgcppapi_catch' />
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    exit(EXIT_FAILURE);
  }
  exit(EXIT_SUCCESS);
}

            </programlisting>
         </example>
         <para>
            This program accepts two command line parameters.  The first is a logbook
            database file.  The concept of a selected logbook is only maintained
            by the <command>lg_xxxx</command> utilties and Tcl administrative
            API.  As an exercise for the reader, check for the file
            <filename>~/.nscl-logbook-current</filename> and read the logbook
            database filename from there.
         </para>
         <para>
            Let's break this down step by step:
         </para>
         <calloutlist>
            <callout arearefs='lgcppapi_header' >
                <para>
                  The <filename>LogBook.h</filename> file contains a definition
                  of much of the API.  Specifically, it contains the definition of
                  the <classname>LogBook</classname> class we'll need.
                </para>
            </callout>
            <callout arearefs='lgcppapi_usage' >
                <para>
                  This chunk of code ensures we have a logbook filename and
                  a key name to lookup.  If not we exit with a message
                  showing the user how to run the program.
                </para>
            </callout>
            <callout arearefs='lgcppapi_try' >
                <para>
                  Many API functions report errors by throwing a
                  <classname>LogBook::Exception</classname> object as an
                  exception.  Therefore the meat of our example is wrapped
                  in a try/catch block.
                </para>
            </callout>
            <callout arearefs='lgcppapi_construct' >
                <para>
                  The <classname>LogBook</classname> class provides the
                  top levels of the API to logbooks.  Instances of this
                  class are constructed on logbook database files. We construct one
                  here.  Methods of this instance then provide the
                  interface to the database.  If the file we provide does not
                  exist, an exception is thrown.
                </para>
            </callout>
            <callout arearefs='lgcppapi_exists' >
                <para>
                  The <classname>LogBook</classname>::<methodname>kvExists</methodname>
                  method returns <literal>true</literal> if the key passed to it
                  exists in the key/value store and <literal>false</literal>
                  if not.  We use this to determine if the key the user has
                  passed us actually exists.  If not we report an error.
                </para>
            </callout>
            <callout arearefs='lgcppapi_get' >
                <para>
                  If the key does exist we can feth its value using\
                  <classname>LogBook</classname>::<methodname>kvGet</methodname>,
                  which returns the value associated with the key from the key value store.
                  Note that, since this method throws an exception if the key
                  does not exist, we could have skipped the call to
                  <methodname>kvExist</methodname> if we were willing to
                  live with the error message in the exception that throws.
                </para>
            </callout>
            <callout arearefs='lgcppapi_catch' >
                <para>
                  The <classname>LogBook::Exception</classname> is derived from
                  <classname>std::exception</classname>.  Therefore catching
                  exceptions of that class will also catch errors thrown by the
                  LogBook API.  This catch block outputs the error message
                  encapsulated by statndard exception objects and then exits
                  with an error status.
                </para>
            </callout>
         </calloutlist>
         <para>
            To compile this toy program we need to include compiler options
            to find the <filename>LogBook.h</filename> header, locate and include
            the API libraries both at link-time and, since they are shared libraries,
            at run-time:
         </para>
         <example>
            <title>Compiling the C++ Logbook API example.</title>
            <programlisting>
g++ -o kvexample -I$DAQINC -L$DAQLIB -lLogbook kvexample.cpp -Wl,-rpath=$DAQLIB
            </programlisting>
         </example>
         <para>
            This produces an executable named <literal>kvexample</literal> which
            can be run directly.  The <literal>-I$DAQINC</literal> adds the
            NSCLDAQ header directory to the include file search path.  The
            <literal>-L$DAQLIB</literal> option adds the NSCLDAQ library directory
            to the link time library search path.  <literal>-lLogbook</literal>
            specifies that we need the logbook C++ API and
            the <option>-Wl,-rpath=$DAQLIB</option> part of this command
            adds the DAQ library directory to the search path for shared libraries
            at run time.
         </para>
      </section>
      <section>
         <title>Using the logbook API from Tcl</title>
         <para>
            There are two levels of Tcl API.  This section will demonstate both
            the low level Tcl bindings and discuss why care is when using them.
            We'll then write the program to use the so-called administrative
            level bindings which hide a lot of the complexity of the low-level
            bindings at the cost of some performance and a more restrictive interface.
         </para>
         <section>
            <title>Low Level Tcl bindiings</title>
            <para>
               This section describes kvexamplelow.tcl The kvexample program
               from thep revious section but written with the low level Tcl bindings.
            </para>
            <example id='ex.tclapilow'>
               <title id='ex.tclapilow.title' ><filename>kvexamplelow.tcl</filename> low level Tcl logbook API example</title>
               <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \  <co id='tclapilow_shell' />
exec tclsh "$0" ${1+"$@"}


##
#  kvexample for low level bindings.
#
lappend auto_path [file join $::env(DAQROOT) TclLibs]    <co id='tclapilow_libpath' />
package require logbook                                  <co id='tclapilow_require' />

if {[llength $argv] ne 2} {
    puts stderr "kvexamplelow.tcl filename key"         <co id='tclapilow_usage' />
    exit -1
}

set book [lindex $argv 0]
set key  [lindex $argv 1]

if {[catch {logbook::logbook open $book} instance]} {    <co id='tclapilow_open' />
    puts stderr "Could not open logbook $book : $instance"
    exit -1
}

if {[$instance kvExists $key]} {                        <co id='tclapilow_exist' />
    puts "$key : [$instance kvGet $key]"                <co id='tclapilow_get' />
    set status 0
} else {
    puts stderr "No such key: $key in $book"
    set status -1
}

$instance destroy                                      <co id='tclapilow_destroy' />
exit $status

               </programlisting>
            </example>
            <calloutlist>
               <callout arearefs='tclapilow_shell' >
               <para>
                  If you just set a Tcl script executable but
                  <command>tclsh</command>  is not considered a valid shell,
                  you won't be able to execute it.  These three four lines
                  make this script executable by <literal>sh</literal> and the last
                  of these four then chains off to the Tcl shell.
                </para>
               </callout>
               <callout arearefs='tclapilow_libpath' >
                <para>
                  This line adds the NSCLDAQ Tcl package library path to the
                  set of paths searched by <command>package require</command>.
                </para>
               </callout>
               <callout arearefs='tclapilow_require' >
                   
                <para>
                  Incorporates the low level Tcl API package,
                  <literal>logbook</literal> into the script. This defines
                  Tcl commands in the <literal>::logbook</literal> namespace.
                  As we will see the top level command is the
                  <command>logbook::logbook</command> command ensemble.
                </para>
               </callout>
               <callout arearefs='tclapilow_usage' >
                   <para>
                     Our script requires two parameters, the logbook filename
                     and a key in the key value store.  This ensures both are
                     present.
                </para>
               </callout>
               <callout arearefs='tclapilow_open' >
                   <para>
                     The <command>logbook::logbook open</command> command creates
                     a Tcl command ensemble that allows access to the logbook.
                     On failure the command raises an error.  This use of the
                     Tcl <command>catch</command> command returns <literal>1</literal>
                     on error with the error message in the variable
                     <varname>instance</varname>, or <literal>0</literal>
                     on success with the value returned from the command
                     (the name of the commane ensemble created) in
                     <varname>instance</varname>.
                </para>
               <para>
                  On failure, therefore, this block of code outputs the
                  error message to stderr and exits with an error status.
                  On success, the program continues with the logbook
                  instance command ensemble name in the <varname>instance</varname>
                  variable.
               </para>
               <para>
                  This use of object instance command ensembles to produce
                  an object oriented interface to the logbook that closely matches
                  the C++ API, while convenient, places the burden of object destruction
                  on the script author, one Tcl scripters are not used to.
                  It is this burden to explicitly destroy objects when no longer
                  needed that drove the construction of the administrative, or
                  high level API which takes care of this for the scripter
                  at the price of some performance loss (the destruction of
                  objects that could be recycled for future calls).
               </para>
               </callout>
               <callout arearefs='tclapilow_exist' >
                   <para>
                     The subcommands of a logbook instance command ensemble
                     are, essentially the same as methods for a C++
                     <classname>LogBook</classname> object.  So the
                     <command>$instance kvExists</command> command checks to see
                     if a key exsists in the key value store of the logbook
                     encapsulated by the command ensemble in the
                     <varname>instance</varname> variable, returning
                     boolean
                     <literal>true</literal> if so and <literal>false</literal>
                     if not.
                </para>
               </callout>
               <callout arearefs='tclapilow_get' >
                   <para>
                     Similarly a logbook instance command ensemble's
                     <command>kvGet</command> subcommand returns the value of a
                     key.
                </para>
               </callout>
               <callout arearefs='tclapilow_destroy' >
                   <para>
                     Having gotten an logbook instance "object" from the
                     API, we must destroy it.  This is true of all
                     object instance commands we get from the API.
                     For example, the logbook instance API subcomand
                     to list notes will create a list of note command ensembles,
                     <emphasis>all of which must eventually be manually destroyed</emphasis>.
                </para>
                <para>
                  All instance command ensembles include a <command>destroy</command>
                  subcommand that destroys the objects they represent.
                </para>
               </callout>
            </calloutlist>
            <para>
               Running the script is just a matter of setting up the NSCLDAQ
               environment variables, setting the script file to executable
               and running it as you would any other program.
            </para>
         </section>
         <section>
            <title>Using the high-level or administrative Tcl API</title>
            <para>
               As we've seen in the previous section, the low level Tcl API
               imposes a burden of manual object management.  This can be
               tricky even for experienced programmers.  It can be downright
               impossible to get right for most script writers that are not
               experienced at that issue.
            </para>
            <para>
               The administrative level or high level Tcl API does this 
               storage management for you by making objects that have only a very short,
               well defined 
               lifetime. All objects created during the execution of an API call
               are destroyed before that call exits or raises an error.
               This provides a much simpler procedural interface at the cost of
               excessive object construction/destruction (for example each
               call will open access to the database and destroy it),
            </para>
            <para>
               It is at this level, that the API provides the concept of a
               <firstterm>currently selected logbook</firstterm>, that we have
               seen in previous sections of this chapter.  The script we
               provide below will operate on the currently selected logbook
               rather than requiring a logbook on the command line.
               It will raise an error if there is not a currently selected
               logbook (any API call that requires a selected logbook will
               raise that error for us).
            </para>
            <para>
               Let's look at the resulting script:
            </para>
            <example>
               <title><filename>kvexamplehi.tcl</filename> Using the high level Tcl logbook API</title>
               <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}

lappend auto_path [file join $::env(DAQROOT) TclLibs   <co id='tclapihi_prev' />
    
package require logbookadmin

if {[llength $argv] != 1} {
    puts stderr "kvexamplehi.tcl  key"                <co id='tclapihi_1param' />
    exit -1
}

set key [lindex $argv 0]
if {[kvExists $key]} {                               <co id='tclapihi_exists' />
    puts "$key : [kvGet $key]"                       <co id='tclaphihi_get' />
} else {
    puts stderr "There is no key named $key"
    exit -1
}
exit 0

               </programlisting>
            </example>
            <calloutlist>
               <callout arearefs='tclapihi_prev' >
                   <para>
                     This code appeared in
                     <link linkend='ex.tclapilow' endterm='ex.tclapilow.title' />.
                     We won't explain it again here.  Refer to that example
                     if you need to understand it.
                </para>
               </callout>
               <callout arearefs='tclapihi_1param' >
                   <para>
                     Unlike <link linkend='ex.tclapilow' endterm='ex.tclapilow.title' />,
                     we refer to the current logbook.  Therefore we only need one
                     parameter, the key to retrieve.
                </para>
               </callout>
               <callout arearefs='tclapihi_exists' >
                   <para>
                     This checks that the key exists.  It does this by creating
                     a logbook instance for the current logbook, asking if the
                     key exists and destroying that instance.
                     In doing this, at the cost of some inefficiency (the logbook instance
                     could be recycled), resource leaks are prevented at the
                     level of your script.
                </para>
               </callout>
               <callout arearefs='tclaphihi_get' >
                   <para>
                     The <function>kvGet</function> proc returns the value of
                     a key if it exists.
                </para>
               </callout>
            </calloutlist>
            <para>
               As you can see it's much simpler to program against the high level
               Tcl interface.  If that API does not provide everything you need
               you can certainly mix high and low level calls.
            </para>
         </section>
      </section>
      <section>
         <title>Using the logbook API from Python</title>
         <para>
            The Python API provides an object oriented Python interface to the
            Logbook API.  Unlike the Tcl low level API, Python's object reference
            counting and garbage collection can, and are, used to do the storage
            management the Tcl low level API burdens you with.
         </para>
         <para>
            Here is the equivalent program in python.  Since we can't access
            the current logbook directly (an excersise for the reader is to
            pull the logbook filename from <filename>~/.nscl-logbook-current</filename>)
            rather than from the command line.
         </para>
         <para>
            Note that the API is supported for Python 3 not Python 2. You must
            use that interpreter when running your scripts.
         </para>
         <example>
            <title><filename>kvexample.py</filename> programming the Python logbook API</title>
            <programlisting>
import sys                              <co id='lgpyapi_sys' />
from  LogBook import LogBook            <co id='lgpyapi_import '/>

if len(sys.argv) != 3 :
    print("kvexample.py logbook key")  <co id='lgpyapi_args' />
    exit()

bookfile = sys.argv[1]                 <co id='lgpyapi_filename' />
key      = sys.argv[2]                 <co id='lgpyapi_key' />

book = LogBook.LogBook(bookfile)       <co id='lgpyapi_construct' />
if book.kv_exists(key) :               <co id='lgpyapi_exists' />
    print(key + " : " + book.kv_get(key)) <co id='lgpyapi_get' />
else :
    print(key + " does not exist")

exit()

            </programlisting>            
         </example>
         <calloutlist>
            <callout arearefs='lgpyapi_sys' >
                <para>
                  This package provides access to the raw command line words
                  via the <varname>sys.argv</varname> array.
                </para>
            </callout>
            <callout arearefs='lgpyapi_import' >
                <para>
                  Brings in the LogBook class from the LogBook module.
                  This class is the top level API class.  It allows us to
                  create, and access logbooks and their contents.
                </para>
            </callout>
            <callout arearefs='lgpyapi_args' >
                <para>
                  The <varname>sys.args</varname> array is exactly the
                  C++ argv parameter to main.  Its first element is the name
                  of the script, as fed to <command>Python</command> interpreter.
                  The following two parameters must be the logbook filename
                  and key we want to retrieve from it.
                </para>
            </callout>
            <callout arearefs='lgpyapi_filename' >
                <para>
                  As described above we fish the logbook filename from the
                  command arguments.
                </para>
            </callout>
            <callout arearefs='lgpyapi_key' >
                <para>
                  As described above, we fish the key to retrieve from the
                  command arguments.
                </para>
            </callout>
         </calloutlist>
         <para>
            Running this script takes a bit of effort. Here's a sample
            command line that prints the name of the experiment from the KV
            store:
         </para>
         <example>
            <title>Running Python scripts that use the logbook API</title>
            <programlisting>
               
PYTHONPATH=$DAQROOT/pythonLibs/nscldaq python3 kvexample.py junk.log experiment

            </programlisting>
         </example>
         <itemizedlist>
            <listitem>
               <para>
                  The definition of <literal>PYTHONPATH</literal>  on the
                  command line tells python to look for importable modules
                  in the DAQ python module directory tree.
               </para>
            </listitem>
            <listitem>
               <para>
                  Note the explicit invocation of <command>python3</command>.
                  Our logbook modules for Python are only available for Python
                  version 3.   At the time I'm writing this many Linux distributions
                  install both but make Python version 2 the interpreter
                  invoked by the <command>python</command> command.
               </para>
            </listitem>
         </itemizedlist>
      </section>
   </section>
</chapter>

<!-- /chapter -->

<!-- manpage 1daq -->

<refentry id="daq1.lg_create">
   <refmeta>
      <refentrytitle id="daq1.lg_create.title">lg_create</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_create</refname>
      <refpurpose>Create a new logbook database.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_create <option>-filename</option> file <optional><option>-current</option> <replaceable>bool</replaceable></optional>
   <optional><option>-experiment</option> <replaceable>experiment-id</replaceable></optional>
   <optional><option>-spokesperson</option> <replaceable>experiment-spokesperson</replaceable></optional>
   <optional><option>-purpose</option> <replaceable>experiment-purpose</replaceable></optional>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            <command>lg_create</command> creates a new logbook database file.
            The <option>-filename</option> is mandatory and is used to provide
            the name of a file to create.  It is an error to attempt to create
            a logbook into an existing file.  The remaining options are
            optional.  With the exception of <option>-current</option> they
            provide information about the logbook that will be put in the
            database's key value store.  
          </para>
          <para>
            <option>-current</option> requires a boolean parameter.  If this
            parameter is true, after creating the logbook, it is made the current
            logbook.  Boolean values can be any legal Tcl boolean value.
          </para>
          <para>
            The key value options are:
          </para>
          <variablelist>
            <varlistentry>
               <term><option>-experiment</option></term>
               <listitem>
                   <para>
                     Provides the experiment ID. This is normally assigned by
                     the facility at which the experiment is run.  The value
                     of this option will be stored as the key
                     <literal>experiment</literal>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-spokesperson</option></term>
               <listitem>
                   <para>
                     Provides the experiment's spokesperson.  This value is stored
                     in the <literal>spokesperson</literal> key of the database's
                     key value store.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-purpose</option></term>
               <listitem>
                   <para>
                     Provides a brief description of the purpose of the experiment.
                     This must be quoted if there are any white-space characters.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          <para>
            If any of the experiment description parameters are omitted,
            the <command>lg_create</command> command will switch into GUI
            mode and display a dialog form that allows you to fill in the
            remaining parameters.  All of the above parameters are mandatory this
            facility is just provided to make the command line a bit less
            unwieldy.
         </para>
    </refsect1>
</refentry>

<refentry id='daq1.lg_current'>
   <refmeta>
      <refentrytitle  id='daq1.lg_current.title'>lg_current</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_current</refname>
      <refpurpose>Set the current logbook database</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_create <optional><replaceable>databasefile</replaceable></optional>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Sets the current datadatabase for the other
            <command>lg_*</command> commands and for the Tcl logbook high level
            interface.  If <parameter>databasefile</parameter> is not provided,
            the command switches to GUI mode and prompts for it.
          </para>
          
    </refsect1>
    <refsect1>
      <title>FILES</title>
      <variablelist>
         <varlistentry>
            <term><filename>~/.nscl-logbook-current</filename></term>
            <listitem>
                <para>
                  The logbook selected is written into this file and this is
                  then used in subsequente <command>lg_*</command>
                  commands as the current database file.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>

<refentry id='daq1.lg_ls'>
   <refmeta>
      <refentrytitle  id='daq1.lg_ls.title'>lg_ls</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_ls</refname>
      <refpurpose>Show current logbook.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_ls
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Lists the name of the current selected logbook database file to
            stdout or else indicates that none has been selected.
          </para>
    </refsect1>
</refentry>

<refentry id='daq1.lg_addperson'>
   <refmeta>
      <refentrytitle id='daq1.lg_addperson.title'>lg_addperson</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_addperson</refname>
      <refpurpose>Add a person to the logbook.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_addperson <optional>
   <replaceable>lastname firstname</replaceable>
   <optional><replaceable>salutation</replaceable></optional>
</optional>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Since experiments are staffed by people and artifacts in the logbook
            are associated with people, the people that can create artifacts
            must be made known to the database. This command adds a person
            to the database.
          </para>
          <para>
            A person is identified by their <parameter>lastname</parameter>,
            <parameter>firstname</parameter> and an optional
            <parameter>salutation</parameter>.
          </para>
          <para>
            If none of these are provided to the command, it switches to GUI
            mode and pops up a dialog box that allows people to be added to the
            database.  The dialog provides entries for the three fields that
            define a person (salutation can be left blank).  The
            <guibutton>Add</guibutton> button adds the person described and the
            <guibutton>Done</guibutton> button exits the dialog.
            Thus GUI Mode allows more than one person to be added in a
            single invocation of the command.
          </para>
    </refsect1>
</refentry>

<refentry >
   <refmeta>
      <refentrytitle id='daq1.ls_people.title'>lg_lspeople</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_lspeople</refname>
      <refpurpose>List the people defined in the logbook.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_lspeople
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Provides a formatted list of the people that are known to the
            logbook e.g:
          </para>
          <informalexample>
            <programlisting>

$DAQBIN/lg_lspeople a b v
Salutation First Name Last Name
Mr         Ron        Fox
Prof.      Sean       Liddick
Dr.        Giordano   Cerizza
           Bryn       Forbes
Mr.        Tristan    Warmels

            </programlisting>
          </informalexample>
    </refsect1>
</refentry>

<refentry id='daq1.lg_mkshift'>
   <refmeta>
      <refentrytitle id='daq1.lg_mkshift.title'>lg_mkshift</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_mkshift</refname>
      <refpurpose>Create a logbook shift</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_mkshift <optional><replaceable>shift-name</replaceable></optional>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Shifts are collections of people.  Shifs are  intended to capture
            the concept that when experiment data taking is in progress,
            data taking time is normally divided in time blocks and each time
            block is manned by some subset of the people involved in data taking.
            When data taking state changes occur (e.g. a run starts), that
            state change is associated with the shift that was on duty at the
            time.
          </para>
          <para>
            Creates a new shift.  If the <parameter>shift-name</parameter>
            command parameter is created, an empty shift with that name
            is created.  If the <parameter>shift-name</parameter> is not
            provided, <command>lg_mkshift</command> switches to GUI mode
            and displays a dialog that allows you to both create a shift and
            stock it with members.  See the tutorial information on the logbook
            for a description of this dialog and how to use it.
          </para>
          <warning>
            <para>
               Once data taking has begun, shift membership should not be
               modified.  This is because state changes are associated with a
               shift name not with the collection of people that are members
               of that shift at the time of the state change.  Therefor editing
               shift members for a shift associated with a state change will
               also edit the set of people associated with that state change.
            </para>
          </warning>
    </refsect1>
</refentry>

<refentry id='daq1.lg_mgshift'>
   <refmeta>
      <refentrytitle id='daq1.lg_mgshift.title'>lg_mgshift</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_mgshift</refname>
      <refpurpose>Manage shifts and memberships</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_mgshift create <optional><replaceable>shift-name</replaceable></optional>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
lg_mgshift edit <optional><replaceable>shift-name</replaceable></optional>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
lg_mgshift list <optional><replaceable>shift-name</replaceable></optional>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This command provides three operations that allow you  to manage shifts
            and their membership.  The first, and mandatory, parameter is a verb
            that indicates the action you want the command to take:
          </para>
          <variablelist>
            <varlistentry>
               <term><command>create</command></term>
               <listitem>
                   <para>
                     Creates a shift and brings up the shift editing dialog,
                     which allows you to populate the shift with people. If the
                     optional <parameter>shift-name</parameter> is provided,
                     The shift editing dialog is loaded into the shift name
                     slot of the dialog.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>edit</command></term>
               <listitem>
                   <para>
                     Edits an existing shift using the shift editor dialog.
                     If the <parameter>shift-name</parameter> is not specified,
                     a shift selection dialog allows you to select the shift
                     to edit from the existing shifts.  The shift edit dialog
                     will reflect the current shift membership.
                   </para>
                   <para>
                     You can also use this subcommand to create a new shift
                     from the members of an existing shift. Simply edit the
                     shift you want to use as a starting point and set a new name
                     in the shift name box of the editor.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>list</command></term>
               <listitem>
                   <para>
                     Without a <parameter>shift-name</parameter> lists all
                     shifts and their members. If <parameter>shift-name</parameter>
                     is provided only the the named shift is listed.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
    </refsect1>
</refentry>

<refentry id='daq1.lg_selshift'>
   <refmeta>
      <refentrytitle id='daq1.lg_selshift.title'>lg_selshift</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_selshift</refname>
      <refpurpose>Select the current shift</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_selshift <optional><replaceable>shift-name</replaceable></optional>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            The <command>lg_*</command> family of commands have the concept
            of a <firstterm>current shift</firstterm> (or on duty shift).
            All automatically logged state changes attribute the shift to
            the on-duty shift.  This command provides a mechanism to set the
            current shift.  If <parameter>shift-name</parameter> is not supplied,
            a shift selection dialog is displayed. Note that this dialog can
            remain displayed after the current shift is selected, providing for
            a permanently visible shift change dialog.
          </para>
    </refsect1>
</refentry>

<refentry id='daq1.lg_kvstore'>
   <refmeta>
      <refentrytitle id='daq1.lg_kvstore.title'>lg_kvstore</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_kvstore</refname>
      <refpurpose>Manipulate the key value store.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_kvstore exists <replaceable>key</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
lg_kvstore get <replaceable>key</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
lg_kvstore set <replaceable>key value</replaceable>            
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
lg_kvstore create <replaceable>key value</replaceable>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            The logbook database provides a generic key value store.  This key
            value store contains information provided when the database is
            created but can also be used to associate arbitrary values with keywords.
            A sort of persistent array with textual indices.  The
            <command>lg_kvstore</command> command provides a command line
            utility to manipulate that store.
          </para>
          <para>
            The first, and mandatory parameter is a verb that tells the command
            what it is supposed to do:
          </para>
          <variablelist>
            <varlistentry>
               <term><command>exists</command></term>
               <listitem>
                   <para>
                     Accepts one more parameter, a key.  If the key exists
                     in the store, the exit status of the command will be 1.
                     If not it will be 0.  This allows shell scripts to test
                     for the existence of keys in the store.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>get</command></term>
               <listitem>
                   <para>
                     Accepts one more parameter, a key.  The value of the key
                     is output to stdout.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>set</command></term>
               <listitem>
                   <para>
                     Requires two parmeters, in order a key and value.
                     If the key already exists, its value is modified to value.
                     If the key does not exist, it is created with the
                     specified value.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>create</command></term>
               <listitem>
                   <para>
                     Requires two parameters, in order a key and value.  The
                     key must not exist in the key value store.  If it does
                     an error is returned.  If it does not, it is created with
                     the specified value.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
    </refsect1>
</refentry>

<refentry id='daq1.lg_wrnote'>
   <refmeta>
      <refentrytitle id='daq1.lg_wrnote.title'>lg_wrnote</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_wrnote</refname>
      <refpurpose>Write logbook notes</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_wrnote <optional><replaceable>run-number</replaceable></optional>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This graphical utility brings up the note editor.  If the
            <parameter>run-number</parameter> is specified, the note is
            initially associated with that run. If not the not is initially
            not associated with a run.  Note that the note editor allows
            the user to select a run with which to associate the note or
            to explicitly specify that no run is associated with the note.
          </para>
    </refsect1>
</refentry>

<refentry id='daq1.lg_browse'>
   <refmeta>
      <refentrytitle id='daq1.lg_browse.title'>lg_browse</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_browse</refname>
      <refpurpose>Logbook browser</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_browse
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Provides a graphical logbook browser.
          </para>
    </refsect1>
</refentry>

<refentry id='daq1.lg_print'>
   <refmeta>
      <refentrytitle id='daq1.lg_print.title'>lg_print</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_print</refname>
      <refpurpose>Convert part or all of the logbook to PDF.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_print <replaceable>pdf-filename</replaceable> <optional><replaceable>item...</replaceable></optional>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Uses the <command>pandoc</command> markup processor to convert
            part or all of the logbook to a pdf. <parameter>pdf-filename</parameter>,
            is required by <command>pandoc</command> to have the extension
            <literal>.pdf</literal>.  If no additional command line parameters are
            supplied the runs and their associated notes are converted.  If
            items are provided they can be either run numbers or the literal
            text <literal>none</literal>.  For each run number on the command
            line that run, its transitions and associated notes are rendered in
            chronological order to the output file. If <literal>none</literal>
            is specified, the notes that are not associated with any run are rendered.
          </para>
          <para>
            The order of the items specifies the order in which they are rendered to
            pdf. For example:
          </para>
          <informalexample>
            <programlisting>
$DAQBIN/lg_print logbook.pdf none 1 2 3 10 4
            </programlisting>
          </informalexample>
          <para>
            Renders first the notes that are not associated with any run followed
            by the transitions and notes associated with, in order
            runs 1,2,3,10, and 4.
          </para>
    </refsect1>
</refentry>

<refentry id='daq1.lg_lspeople'>
   <refmeta>
      <refentrytitle id='daq1.lg_lspeople.title'>lg_lspeople</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_lspeople</refname>
      <refpurpose>List people that are defined</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
lg_lspeople
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            List the people that have been defined in the database.
          </para>
    </refsect1>
</refentry>

<!-- /manpage -->

<!-- manpage 3daq -->

<refentry id='daq1.logbook'>
   <refmeta>
      <refentrytitle id='daq1.logbook.title'>LogBook</refentrytitle>
      <manvolnum>3daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>LogBook</refname>
      <refpurpose>Top Level Logbook C++ API</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
#include &lt;LogBookh&gt;

class LogBook
{
public:
    class Exception : public std::exception{
    public:
        Exception(const char* message) noexcept;
        Exception(const std::string&amp; message) noexcept;
        Exception(const CSqliteExceptionamp; reason, const char* doing) noexcept;
        Exception(const CSqliteException&amp; reason, const std::string&amp; doing) noexcept;
        
        Exception(const Exception&amp; rhs) noexcept;
        Exception&amp; operator=(const Exception&amp; rhs) noexcept;
        
        virtual ~Exception();
        virtual const char* what() const noexcept;
        
        static void rethrowSqliteException(CSqliteException&amp; e, const char* doing);
        static void rethrowSqliteException(CSqliteException&amp; e, std::string doing);
    };
    
public:
    static std::string m_tempdir;
public:
    static void create(
       const char* pFilename, const char* pExperiment,
       const char* pSpokesperson, const char* purpose
    );
    
    LogBook(const char* pFilename);
    virtual ~LogBook();


public:
 // Api for person
    LogBookPerson* addPerson(const char* lastName, const char* firstName, const char* salutation);
    std::vector&lt;LogBookPerson*&gt; findPeople(const char* where=nullptr);
    std::vector&lt;LogBookPerson*&gt; listPeople();
    LogBookPerson* getPerson(int id);
    
    // Api for shifts:
    
    LogBookShift* getShift(int id);
    void          addShiftMember(LogBookShift* pShift, LogBookPerson* pPerson);
    void          removeShiftMember(LogBookShift* pShift, LogBookPerson* pPerson);
    LogBookShift* createShift(const char* name);
    LogBookShift* createShift(
      const char* name, const std::vector&lt;LogBookPerson*&gt;&amp; members
    );
    std::vector&lt;LogBookShift*&gt; listShifts();
    LogBookShift*   findShift(const char* name);
    void setCurrentShift(LogBookShift* pShift);
    LogBookShift* getCurrentShift();
    
    // API for runs:
    
    LogBookRun* getRun(int id);
    int         runId(int runNumber);
    LogBookRun* currentRun();
    LogBookRun* begin(int number, const char* title, const char* remark=nullptr);
    void        end(LogBookRun*&amp; pRun, const char* remark = nullptr);
    void        pause(LogBookRun*&amp; pRun, const char* remark = nullptr);
    void        resume(LogBookRun*&amp; pRun, const char* remark = nullptr);
    void        emergencyStop(LogBookRun*&amp; pRun, const char* remark = nullptr);
    std::vector&lt;LogBookRun*&gt; listRuns();
    LogBookRun* findRun(int number);
    
    // API for notes:
    
    LogBookNote*  createNote(
        LogBookPerson&amp; author, const char* note, const std::vector&lt;std::string&gt;&amp; imageFiles,
        const std::vector&lt;size_t&gt;&amp; imageOffsets,
        LogBookRun* pRun = nullptr
    );
    LogBookNote* createNote(LogBookPerson&amp; author, const char* note, LogBookRun* pRun = nullptr);
    LogBookNote* getNote(int id);
    std::vector&lt;LogBookNote*&gt; listAllNotes();
    std::vector&lt;LogBookNote*&gt; listNotesForRunId(int runId);
    std::vector&lt;LogBookNote*&gt; listNotesForRun(int runNumber);
    std::vector&lt;LogBookNote*&gt; listNotesForRun(const LogBookRun* pRun);
    std::vector&lt;LogBookNote*&gt; listNonRunNotes();
    LogBookRun* getNoteRun(LogBookNote&amp; note);
    LogBookPerson* getNoteAuthor(LogBookNote&amp; note);
    
    // API for key value store
    
    bool kvExists(const char* key);
    std::string kvGet(const char* key);
    void kvSet(const char* key, const char* value);
    void kvCreate(const char* key, const char* value);
    

};


      </programlisting>
      <cmdsynopsis><command>
         
... -I$DAQINC -L$DAQLIB -lLogbook -Wl,-rpath=$DAQLIB

      </command></cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
      <title>DESCRIPTION</title>
      <para>
        This class represents the top level C++ API for the logbook.
        In addition to providing the API, it encapsulates a nested
        public class: <classname>LogBook::Exception</classname> used
        to report errors via exceptions. 
      </para>
      <para>
        In addition, for some operations,
        the logbook subsystem requires a directory in which to export
        data from the logbook database into the file system.  For example,
        when rendering a note as markup text with image references, the images
        themselves must live in the filesystem.  The member variable
        <classname>LogBook</classname>::<varname>m_tempdir</varname>
        contains the name of this directory.  Note that currently this is
        initially <filename>~/.nscl-logbook</filename>, however it is
        perfectly legal for a client program to alter that value to point
        to any other existing directory in the filesystem.
      </para>
      <para>
        The remainder of this manpage will first document the
        <classname>LogBook::Exception</classname> class and its methods
        and then the <classname>LogBook</classname> class itself.
      </para>
    </refsect1>
    <refsect1>
      <title><classname>LogBook::Exception</classname> METHODS</title>
      <para>
         All errors detected by the logbook system are reported by throwing
         <classname>LogBook::Exception</classname> exceptions.  This exception
         is derived from <classname>std::exception</classname>.
         This section describes the methods (most importantly the
         mechanisms for constructing instancde) of this class.
      </para>
      <variablelist>
         <varlistentry>
            <term>
               <constructorsynopsis>
                  <modifier>noexcept</modifier>
                   <methodname>Exception</methodname>
                   <methodparam>
                       <type>const char* </type><parameter>message</parameter>
                   </methodparam>
                   
               </constructorsynopsis>
            </term>
            <listitem>
                <para>
                  Constructs an instance with the specified message.  The
                  message text is copied into internal object storage so the
                  lifetime of the message is not an instance as the call-stack
                  is unrolled.  This method is most convenient when the message
                  text is hard coded.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <constructorsynopsis>
                  <modifier>noexcept</modifier>
                   <methodname>Exception(</methodname>
                <methodparam>
                    <type>const std::string&amp;</type><parameter> message</parameter>
                </methodparam>
               </constructorsynopsis>
            </term>
            <listitem>
                <para>
                  Constructs the exception given a reference to a
                  <classname>std::string</classname> object.  This is convenient
                  to use when the error message is programmatically constructed.
                  For example, within the library, a common pattern is to
                  instantiate an <classname>std::stringstream</classname> object
                  and write into that both constant text and parameters of the
                  failing call.  From this stream a <classname>std::string</classname>
                  is constructed and that string  used, in turn to construct
                  a <classname>LogBook::Exception</classname> object which is
                  then thrown.
               </para>
                <para>
                  In all cases, the final exception text (returned by the
                  <methodname>what</methodname> method) is stored internally to
                  avoid life-time issues.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <constructorsynopsis>
                  <modifier>noexcept</modifier>
                   <methodname>Exception</methodname>
                  <methodparam>
                      <type>const CSqliteExceptionamp; </type><parameter>reason</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>doing</parameter>
                  </methodparam>
               </constructorsynopsis>
            </term>
            <listitem>
                <para>
                  Constructs an instance creating the error text from
                  that encapsulated within a <classname>CSqliteException</classname>
                  object and a character string.  This is used to
                  map failures reported by the Sqlite class library, the logbook
                  facility is built on, to <classname>LogBook::Exception</classname>
                  objects when the additional string (which usually describes
                  what the library was trying to do) is a constant.
               </para>
                <para>
                  See, as well the overloaded
                  <methodname>rethrowSqliteException</methodname> methods
                  which both construct and then throw the resulting
                  <classname>LogBook::Exception</classname> object.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <constructorsynopsis>
                  <modifier>noexcept</modifier>
                   <methodname>Exception</methodname>
                  <methodparam>
                      <type>const CSqliteException&amp; </type><parameter>reason</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const std::string&amp; </type><parameter>doing</parameter>
                  </methodparam>
               </constructorsynopsis>
            </term>
            <listitem>
                <para>
                  Same as the previous constructor but the additiona text is
                  provided as a reference to a <classname>std::string</classname>
                  which in general provides mechanisms for a more dynamic
                  construction of that message.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>virtual const char* </type>
                  <methodname>what</methodname>
                  <void />
                  <modifier>const noexcept</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  This method must be provided by all
                  classes derived from
                  <classname>std::exception</classname>, it
                  provides a pointer to the error message encapsulated
                  by exception classes.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static void </type>
                  <methodname>rethrowSqliteException</methodname>
                  <methodparam>
                      <type>CSqliteException&amp; </type><parameter>e</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>doing</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Convenience method that constructs a
                  <classname>LogBook::Exception</classname> and throws it.
                  This is used within the library to convert exceptions thrown
                  by the C++ encapsulation of the Sqlite3 API into
                  <classname>LogBook::Exception</classname> throws.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static void </type>
                  <methodname>rethrowSqliteException</methodname>
                  <methodparam>
                      <type>CSqliteException&amp; </type><parameter>e</parameter>
                  </methodparam>
                  <methodparam>
                      <type>std::string </type><parameter>doing</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Same as above convenience method used to convert a caught
                  <classname>CSqliteException</classname> object into a
                  <classname>LogBook::Exception</classname> throw.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title><classname>LogBook</classname> METHODS</title>
      <para>
         The <classname>LogBook</classname> methods are divided
         into several sub-categories, each dealing with a subset of the
         responsibilities of the logbook subsystem.  This section will
         describe, in turn, the methods that make up each of the
         sub-categories.
      </para>
      <refsect2>
         <title>ADMINISTRATIVE METHODS</title>
         <para>
            These methods are responsible for creating and accessing
            logbook databases:
         </para>
         <variablelist>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>static void </type>
                     <methodname>create
                     </methodname>
                     <methodparam>
                         <type>const char* </type><parameter>pFilename</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char*</type><parameter> pExperiment</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>pSpokesperson</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>purpose</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Creates a new database file initialized to hold a logbook.
                     <parameter>pFilename</parameter> is the path to the file
                     that will be created.  It is an error for that file to already
                     exist. <parameter>pExperiment</parameter> provides the
                     experiment identifier.  This value is stored in the
                     key value store with the key <literal>experiment</literal>
                   </para>
                   <para>
                     <parameter>pSpokesperson</parameter> is intended to
                     provide the name of the spokesperson of the experiment.
                     Note that at this point there are no entries in the
                     People subsection of the logbook.  This is therefore, just
                     free text.  The value is stored in the key value store with the
                     key <literal>spokesperson</literal>
                   </para>
                   <para>
                     <parameter>purpose</parameter> is intended to provide
                     the purpose of the experiment.  This is stored in the key value
                     store under the key <literal>purpose</literal>
                   </para>
                   <para>
                     An additional key is created: <literal>version</literal>.
                     This is intended to future proof the database by allowing
                     us to detect and, hopefully adapt to, future database
                     schema.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <constructorsynopsis>
                      <methodname>LogBook</methodname>
                    <methodparam>
                        <type>const char* </type><parameter>pFilename</parameter>
                    </methodparam>
                  </constructorsynopsis>
               </term>
               <listitem>
                   <para>
                     Constructs an instance of <classname>LogBook</classname>.
                     The methods of that class allow us access to the logbook
                     stored in the file whose path is <parameter>pFilename</parameter>.
                     Note that <parameter>pFilename</parameter> must exist and
                     have come into being by calling
                     <methodname>LogBook::create</methodname>.
                   </para>
                </listitem>
            </varlistentry>           
         </variablelist>
      </refsect2>
      <refsect2>
         <title>PEOPLE METHODS</title>
         <para>
            This set of methods defines, retrieves and searches for people in the
            logbook database.
            Persons are encapsulated in
            <classname>LogBookPerson</classname> instances. This calss and its
            methods are described in
            <link linkend='daq3.logbookperson' endterm='daq3.logbookperson.title' />
         </para>
         <para>
            Methods that return pointers to
            <classname>LogBookPerson</classname> object either individually or
            as vectors of pointers are returning pointers to dynamically allocated
            objects.  It's important to <literal>delete</literal> all of these
            objects after use in order top prevent memory leaks. 
         </para>
         <para>
            Note that these methods can throw
            <classname>LogBook::Exception</classname> objects and a well constructed
            program must be capable of, at some level, handling those.
         </para>
         <variablelist>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookPerson* </type>
                     <methodname>addPerson</methodname>
                     <methodparam>
                         <type>const char* </type><parameter>lastName</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>firstName</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>salutation</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     This method creates a new person with the attributes provided.
                     Note that normally a <parameter>salutation</parameter>
                     is considered optional.  Provide a pointer to an empty string
                     if that's what you want
                   </para>
                   <para>
                     The method returns a pointer to a <classname>LogBookPerson</classname>
                     object that encapsulates the new person in the database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>std::vector&lt;LogBookPerson*&gt; </type>
                     <methodname>findPeople</methodname>
                     <methodparam>
                         <type>const char* </type><parameter>where</parameter>
                         <initializer>nullptr</initializer>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Does a generic find for persons in the database.
                     The <parameter>where</parameter> parameter is valid
                     Sqlite3 <literal>WHERE</literal> clause (without the
                     <literal>WHERE</literal> keyword) that qualifies the search.
                     If it is <literal>nullptr</literal>, the call is functionally
                     equivalent to <methodname>listPeople</methodname>.
                   </para>
                   <para>
                     The fields you can include in the <parameter>where</parameter>
                     clause are:
                   </para>
                   <variablelist>
                     <varlistentry>
                        <term><literal>id</literal></term>
                        <listitem>
                            <para>
                              The person's primary key (an autoincrementing
                              integer).
                           </para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term><literal>lastname</literal></term>
                        <listitem>
                            <para>
                              The person's last name.
                           </para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term><literal>firstname</literal></term>
                        <listitem>
                            <para>
                              The person's first name.
                           </para>
                        </listitem>
                     </varlistentry>
                     <varlistentry>
                        <term><literal>salutation</literal></term>
                        <listitem>
                            <para>
                              The salutation of the people you want.
                           </para>
                        </listitem>
                     </varlistentry>
                   </variablelist>
                   <para>
                     The <parameter>where</parameter> clause can be
                     arbitrarily complex as it will just be appended
                     (after a <literal>WHERE</literal>) to the prepared statement
                     used to return the data needed to construct the
                     vector of <classname>LogBookPerson</classname> objects
                     whose pointers are returned.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>std::vector&lt;LogBookPerson*&gt; </type>
                     <methodname>listPeople</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns a vector of pointers to
                     <classname>LogBookPerson</classname> objects encapsulating
                     all people defined to the logbook.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookPerson* </type>
                     <methodname>getPerson</methodname>
                     <methodparam>
                         <type>int </type><parameter>id</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns a pointer to a <classname>LogBookPerson</classname>
                     object that encapsulates the entry for a person with the
                     primary key <parameter>id</parameter>.  This is like
                     doing a <methodname>findPeople</methodname> call with
                     <parameter>where</parameter> =
                     <literal>id=<parameter>id</parameter></literal>
                     (the second id in the text above is the value of the
                     <parameter>id</parameter> parameter to this call).
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
      <refsect2>
         <title>SHIFT API</title>
         <para>
            Shifts are collections of people.  In addition there's the concept
            of a current, or on-duty shift that, during data taking is associated
            with data taking state transitions.  Shifts are encapsulated by
            <classname>LogBookShift</classname> objects.
            <classname>LogBookShift</classname> is documented in
            <link linkend='daq3.logbookshift' endterm='daq3.logbookshift.title' />
         </para>
         <para>
            Pointer to <classname>LogBookShift</classname> object returned by
            these methods, either individually or in vectors, point to
            dynamically allocated
            objects.  As such when no longer needed, they must be
            <literal>delete</literal>d in order to prevent memory leaks.
         </para>
         <variablelist>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookShift* </type>
                     <methodname>getShift</methodname>
                     <methodparam>
                         <type>int</type><parameter> id</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the shift with the primary key <parameter>id</parameter>
                   </para>
                   <para>
                     The primary key is a sequentially assigned unique integer.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>void</type>
                     <methodname>addShiftMember</methodname>
                     <methodparam>
                         <type>LogBookShift* </type><parameter>pShift</parameter>
                     </methodparam>
                     <methodparam>
                         <type>LogBookPerson* </type><parameter>pPerson</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Adds a member to an existing shift <parameter>pShift</parameter>
                     is a pointer to that shift and <parameter>p</parameter>
                     pPerson is a pointer to the person to add.  
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>void          </type>
                     <methodname>removeShiftMember</methodname>
                     <methodparam>
                         <type>LogBookShift* </type><parameter>pShift</parameter>
                     </methodparam>
                     <methodparam>
                         <type>LogBookPerson*</type><parameter> pPerson</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Removes a person represented by <parameter>pPerson</parameter>
                     from a shift represented by <parameter>pShift</parameter>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookShift* </type>
                     <methodname>createShift</methodname>
                     <methodparam>
                         <type>const char* </type><parameter>name</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Creates a new shift named <parameter>name</parameter>.
                     The shift, thus created, has no members.  Use
                     <methodname>addShiftMember</methodname> to populate the
                     shift or, alternatively  use the overload of this
                     method that provides the ability to pass in members.
                   </para>
                   <para>
                     The return value is a pointer to the object encapsulating
                     the shift that was coreated.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookShift* </type>
                     <methodname>createShift</methodname>
                     <methodparam>
                         <type>const char* </type><parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const std::vector&lt;LogBookPerson*&gt;&amp; </type><parameter>members</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Creates a new shift named <parameter>name</parameter>.
                     The shift is initially stocked with the members encapsulated
                     by the object pointed to in the vecto
                     <parameter>members</parameter>.
                   </para>
                   <para>
                     The return value is a pointer to a <classname>LogBookShift</classname>
                     that encapsulates the new shift.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>std::vector&lt;LogBookShift*&gt; </type>
                     <methodname>listShifts</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns a vector containing pointers to all of the shifts
                     that have been defined.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookShift*   </type>
                     <methodname>findShift</methodname>
                     <methodparam>
                         <type>const char* </type><parameter>name</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     If there is a shift named <parameter>name</parameter>,
                     returns  a pointer to an object that encapsulates it.
                     If there is no matching shift, this returns a
                     <literal>nullptr</literal>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>void </type>
                     <methodname>setCurrentShift</methodname>
                     <methodparam>
                         <type>LogBookShift* </type><parameter>pShift</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Sets the current shift to the shift pointed to by
                     <parameter>pShift</parameter>.  Until the current shift
                     is set again, all run state transitions logged will be
                     attributed to this shift. 
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookShift* </type>
                     <methodname>getCurrentShift</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns a pointer to the current shift.  If no current
                     shift has ever been set, this returns a
                     <literal>nullptr</literal>/
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
      <refsect2>
         <title>RUNS API</title>
         <para>
            This section of the API provides methods for creatin runs and
            cycling them through legal state transitions.  Furthermore, runs can
            be retrieved and searched for by run number.
         </para>
         <para>
            Runs are encapsulated by instances of
            <classname>LogBookRun</classname>.   This class is descdribed in
            <link linkend='daq3.logbookrun' endterm='daq3.logbookrun.title' />.
            All pointers to <classname>LogBookRun</classname> objects point
            to dynamically allocated objects. When you are done using them
            you must destroy them using <literal>delete</literal> to avoid
            application memory leaks.
         </para>
         <para>
            There is a coupling between shifts and runs.  Several of the
            methods in this section of the API log run state transitions.
            In order to succeed a current shift must have been
            established.  The current shift is associated with the state
            transition log entries.
         </para>
         <variablelist>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookRun* </type>
                     <methodname>getRun</methodname>
                     <methodparam>
                         <type>int</type><parameter> id</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns a pointer to the run whose primary key is
                     <parameter>id</parameter>.  The primary key for runs
                     is a unique integer for each run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>int</type>
                     <methodname>runId</methodname>
                     <methodparam>
                         <type>int </type><parameter>runNumber</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the primary key of the run whose run number is
                     <parameter>runNumber</parameter>.  If there is no such run
                     a <classname>LogBook::Exception</classname> is thrown.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookRun* </type>
                     <methodname>currentRun</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns a pointer to an encapsulation of thecurrent run.
                     If there is no current run a <literal>nullptr</literal>
                     is returned.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookRun* </type>
                     <methodname>begin</methodname>
                     <methodparam>
                         <type>int </type><parameter>number</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>title</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>remark</parameter>
                         <initializer>nullptr</initializer>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Logs the beginning of a new run.
                     There must be no active (current) run.
                     The new run is assigned the run number
                     <parameter>number</parameter>.  There must not be a run
                     with that number.
                   </para>
                   <para>
                     The <parameter>title</parameter> is associated with the run
                     as its title.  <parameter>remark</parameter> is an additional
                     remark that is associated with the run.
                   </para>
                   <para>
                     The returned value is a pointer to an object that encapsulates
                     the run.  If any of the preconditions described above were
                     not met a <classname>LogBook::Exception</classname>
                     is thrown.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>void </type>
                     <methodname>end</methodname>
                     <methodparam>
                         <type>LogBookRun*&amp; </type><parameter>pRun</parameter>
                     </methodparam>
                     <methodparam>
                         <type> const char* </type><parameter>remark</parameter>
                         <initializer>nullptr</initializer>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Logs an end to the run that is encapsulated by <parameter>pRun</parameter>.
                     <parameter>remark</parameter> provides an optional remark
                     associated with the transition. To be ended a run must be
                     either active or paused.  If that's not the case,
                     a <classname>LogBook::Exception</classname> is thrown.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>void </type>
                     <methodname>pause</methodname>
                     <methodparam>
                         <type>LogBookRun*&amp; </type><parameter>pRun</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>remark </parameter>
                         <initializer>nullptr</initializer>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Logs a pause to  the run encapsulated by
                     <parameter>pRun</parameter>.   The logbook state of the
                     run must be active or else an exception is thrown.
                     The optional
                     <parameter>remark</parameter> provides a remark to be
                     associated with the state change.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>void  </type>
                     <methodname>resume</methodname>
                     <methodparam>
                         <type>LogBookRun*&amp; </type><parameter>pRun</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>remark</parameter>
                         <initializer>nullptr</initializer>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Logs a resume run for the run pointed to
                     by <parameter>pRun</parameter>. The run must be in the
                     paused state or an exception will be thrown.  The
                     <parameter>remark</parameter> is text that will be
                     associated with the state change.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>void   </type>
                     <methodname>emergencyStop</methodname>
                     <methodparam>
                         <type>LogBookRun*&amp;</type><parameter> pRun</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>remark</parameter>
                         <initializer> nullptr</initializer>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Logs an emergency stop for the run identified by
                     <parameter>pRun</parameter>.  The run must be either active or
                     paused.  Emergency stops are intended to end runs that ended
                     improperly (e.g. data acquisition failures).  An emergency stop
                     indicates something very wrong happened to a run to prevent it
                     from having a properly logged end.
                     <parameter>remark</parameter> is remark text that's
                     associated with the transition.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>std::vector&lt;LogBookRun*&gt; </type>
                     <methodname>listRuns</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns all of the runs that have been logged in the logbook.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookRun* </type>
                     <methodname>findRun</methodname>
                     <methodparam>
                         <type>int </type><parameter>number</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Given the run number <parameter>number</parameter>,
                     returns an encapsulation of that run.  If there is no
                     such run, <literal>nullptr</literal> is returned.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
      <refsect2>
         <title>NOTES methods</title>
         <para>
            Notes consist of:
         </para>
         <itemizedlist>
            <listitem>
               <para>
                  Metadata that includes an author reference, an authorship time,
                  and optionally an associated run.
               </para>
            </listitem>
            <listitem>
               <para>
                  The note text, which is in markdown format. 
               </para>
            </listitem>
            <listitem>
               <para>
                  A list of zero or more embedded images and where their
                  links are in the note text.
               </para>
            </listitem>
         </itemizedlist>
         <para>
            The note API is one of the more complext bits of interface in
            the <classname>LogBook</classname> class.  Note that,
            as with other parts of the API, a class has been designed to
            encapsulate notes; <classname>LogBookNote</classname>;
            which is documented in
            <link linkend='daq3.logbooknote' endterm='daq3.logbooknote.title' />.
         </para>
         <para>
            API elements that return <classname>LogBookNote*</classname>
            values or containers are returning pointers to dynamically allocated
            objects that must be disposed of when no longer needed using
            <literal>delete</literal>.
         </para>
         <variablelist>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookNote*</type>
                     <methodname>createNote</methodname>
                     <methodparam>
                         <type>LogBookPerson&amp; </type><parameter>author</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>note</parameter>
                     </methodparam>
                     <methodparam>
                         <type> const std::vector&lt;std::string&gt;&amp; </type><parameter>imageFiles</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const std::vector&lt;size_t&gt;&amp; </type><parameter>imageOffsets</parameter>
                     </methodparam>
                     <methodparam>
                         <type>LogBookRun* </type><parameter>pRun </parameter>
                         <initializer>nullptr</initializer>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Fully creates a note.  The return value is
                     a pointer to an encapsulation of
                     the note created.
                   </para>
                   <para>
                     <parameter>author</parameter> is a pointer to an encapsulation
                     of the person who's written the note.  <parameter>note</parameter>
                     is a pointer to the note text.  The note is assumed to be
                     in markdown format. 
                   </para>
                   <para>
                     <parameter>imageFiles</parameter> is a vector of images file
                     paths that are referenced by image links in the markdown.
                     These images will be imported into the database.  This information
                     could be scraped by your application from the note text.
                     <parameter>imageOffsets</parameter> are the byte offsets
                     into the note text at which the first character of the
                     corresponding image link is.  Recall that image links look
                     like <literal>![somet text](image-path)</literal>.  These
                     offsets must be the offsets of the <literal>!</literal>.
                   </para>
                   <para>
                     If the note is associated with a run, <parameter>pRun</parameter>
                     points to the run object that encpapsulates the run.
                     If not, either omit the parameter or explicitly pass a
                     <parameter>nullptr</parameter> if your program flow makes that
                     impossible or contorted.
                   </para>
                   <para>
                     Once  the note is created, any image references you've passed
                     are no longer needed as the image file contents have been
                     sucked into the logbook database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookNote* </type>
                     <methodname>createNote</methodname>
                     <methodparam>
                         <type>LogBookPerson&amp; </type><parameter>author</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>note</parameter>
                     </methodparam>
                     <methodparam>
                         <type>LogBookRun* </type><parameter>pRun </parameter>
                         <initializer>nullptr</initializer>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Creates a note with no image links.  See
                     the prior overload for the parameters we do have.  They are
                     have the same meaning. In fact, this method just invokes
                     the previous methos passing empty vectors for the image
                     files and image file offset vectors.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookNote* </type>
                     <methodname>getNote</methodname>
                     <methodparam>
                         <type>int </type><parameter>id</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Retrieves an encapsulation fo the note with the
                     primary key value <parameter>id</parameter>.  The
                     primary key is a unique integer value assigned to each
                     note.  
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>std::vector&lt;LogBookNote*&gt; </type>
                     <methodname>listAllNotes</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns a vector containing pointers to encapsulations
                     of all of the notes entered in the database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>std::vector&lt;LogBookNote*&gt; </type>
                     <methodname>listNotesForRunId</methodname>
                     <methodparam>
                         <type>int </type><parameter>runId</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the notes that are associated with a run
                     given its primary key.  That is a value
                     that was returned from the <methodname>runId</methodname>
                     method e.g.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>std::vector&lt;LogBookNote*&gt; </type>
                     <methodname>listNotesForRun</methodname>
                     <methodparam>
                         <type>int </type><parameter>runNumber</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the notes associated with a run that has
                     the run number <parameter>runNumber</parameter>.
                   </para>
                </listitem>
            </varlistentry>        
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>std::vector&lt;LogBookNote*&gt; </type>
                     <methodname>listNonRunNotes</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the notes that are not associated with any run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookRun* </type>
                     <methodname>getNoteRun</methodname>
                     <methodparam>
                         <type>LogBookNote&amp; </type><parameter>note</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns a pointer to an encapsulated run object
                     for the run associated with <parameter>note</parameter>.
                     If there is no assciated run, <literal>nullptr</literal> is
                     returned.  Note that the returned value points to a
                     dynamically allocated object. When no longer needed it
                     must be disposed using <literal>delete</literal>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBookPerson* </type>
                     <methodname>getNoteAuthor</methodname>
                     <methodparam>
                         <type>LogBookNote&amp;</type><parameter> note</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the encapsulated author of the <parameter>note</parameter>.
                     This is a pointer to a dynamically allocated object.
                     When you no longer need the author, you must
                     use <literal>delete</literal> to dispose of it.
                   </para>
                </listitem>
            </varlistentry>          
         </variablelist>
      </refsect2>
      <refsect2>
         <title>KEY VALUE STORE api</title>
         <para>
            The logbook database includes a key value store.  A key value store
            is a table of keys and associated values.  They key value store
            is used to store metatdata about the logbook itself and can be
            used for simple application specific extension to the database to
            meet unanticipated use cases.  Key Value will be abbreviated KV below.
         </para>
         <variablelist>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>bool </type>
                     <methodname>kvExists</methodname>
                     <methodparam>
                         <type>const char* </type><parameter>key</parameter>
                     </methodparam>
                  </methodsynopsis>      
               </term>
               <listitem>
                   <para>
                     Returns <literal>true</literal> if there's an entry
                     with the key <parameter>key</parameter> in the KV store.
                     If not returns <literal>false</literal>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>std::string </type>
                     <methodname>kvGet</methodname>
                     <methodparam>
                         <type>const char* </type><parameter>key</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the value of the <parameter>key</parameter> in the
                     KV store if the key exists.  If not a
                     <classname>LogBook::Exception</classname> is thrown.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>void </type>
                     <methodname>kvSet</methodname>
                     <methodparam>
                         <type>const char* </type><parameter>key</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>value</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Sets a new
                     <parameter>value</parameter>
                     for the existing <parameter>key</parameter>. If there is
                     no key <parameter>key</parameter>, a new KV pair are created.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>void </type>
                     <methodname>kvCreate</methodname>
                     <methodparam>
                         <type>const char* </type><parameter>key</parameter>
                     </methodparam>
                     <methodparam>
                         <type>const char* </type><parameter>value</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Creates a new KV entry in the KV store.  The
                     key will be <parameter>key</parameter> and the
                     value will be <parameter>value</parameter>.  If
                     there is already a KV entry for <parameter>key</parameter>,
                     a <classname>LogBook::Exception</classname> is thrown.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
    </refsect1>
</refentry>
<refentry id='daq3.logbookperson'>
   <refmeta>
      <refentrytitle id='daq3.logbookperson.title'>LogBookPerson</refentrytitle>
      <manvolnum>3daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>LogBookPerson</refname>
      <refpurpose>Encapsulate a person registered in a logbook.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
#include &lt;LogBookPerson.h&gt;

class LogBookPerson
{

public:
    LogBookPerson(CSqlite&amp; db, int id);  
    LogBookPerson(const LogBookPerson&amp; rhs);
public:
    LogBookPerson&amp; operator=(const LogBookPerson&amp; rhs);
    int operator==(const LogBookPerson&amp; rhs) const;
    int operator!=(const LogBookPerson&amp; rhs) const;
    
    const char* lastName() const;
    const char* firstName() const;
    const char* salutation() const;
    int         id() const;
    
    static LogBookPerson* create(
        CSqlite&amp; db,
        const char* lastName, const char* firstName, const char* salutation
    );
    static std::vector&lt;LogBookPerson*&gt; find(CSqlite&amp; db, const char* where=nullptr);
    static std::vector&lt;LogBookPerson*&gt; list(CSqlite&amp; db);
};
      </programlisting>
      <cmdsynopsis>
         <command>
... -I$DAQINC -L$DAQLIB -lLogbook -Wl,-rpath=$DAQLIB
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            The <classname>LogBookPerson</classname> class encapsulates
            two use cases.  First it provides an encapsulation of a
            person that has been registered in the logbook.  Second, it hides
            operations on persons (creation, retrieval etc.) from the
            <classname>LogBook</classname> API class.
          </para>
          <para>
            As such, the documentation of the public methods in the section
            that follows (<literal>METHODS</literal>) will indicate methods
            that are not intended for actual client use but are
            intended for use by the
            <classname>LogBook</classname> class.  These methods can also be used
            in special applications that may need to use the lower levels of the
            API for unanticipated purposes.
          </para>
    </refsect1>
    <refsect1>
      <title>METHODS</title>
      <para>
         Before describing the full set of methods for
         <classname>LogBookPerson</classname> just a note that copy construction,
         equality/inequalty comparison and assignment
         are fully supported by this class and the methods needed
         to support that need not be described.
      </para>
      <variablelist>
         <varlistentry>
            <term>
               <constructorsynopsis>
                   <methodname>LogBookPerson</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>int </type><parameter>id</parameter>
                  </methodparam>
               </constructorsynopsis>
            </term>
            <listitem>
                <para>
                  The constructor, while public is not intended for general
                  use.  It is used to construct an encapsulation of a person
                  from an Sqlite++ database handle <parameter>db</parameter>
                  reference
                  and the primary key of the person.  This is the constructor,
                  used for
                  example. by <classname>LogBook::</classname><methodname>getPerson</methodname>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>const char* </type>
                  <methodname>lastName</methodname>
                  <void />
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the last name of the person whom this object
                  encapsulates.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>const char* </type>
                  <methodname>firstName</methodname>
                  <void />
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the first name of the person whom this object
                  encapsulates
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>const char* </type>
                  <methodname>salutation</methodname>
                  <void />
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the salution of the person whom this object
                  encapsulates.  Note that an empty string is used for
                  a person who does not have a salutation so client code
                  does not need to worry about this being a
                  <literal>nullptr</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>int</type>
                  <methodname>id</methodname>
                  <void />
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the primary key of the person whom this
                  object encapsulates.  The primary key is a unique
                  integer that's assigned each person.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static LogBookPerson* </type>
                  <methodname>create</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>lastName</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char*</type><parameter>firsName</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char*</type><parameter>salutation</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not intended for general use, this method creates a new
                  person entry in the database.  This is used by e.g.
                  <classname>LogBook::</classname><methodname>addPerson</methodname>.
               </para>
               <para>
                  <parameter>db</parameter> is a reference to an Sqlite++
                  database connection object and <parameter>lastName</parameter>,
                  <parameter>firstName</parameter> and <parameter>salutation</parameter>
                  provide the data from which the person is created.
                  Once created, a pointer to a dynamically constructed
                  encapsulation is returned to the caller.
               </para>
               <para>
                  While the saluation of a person is considered optional,
                  use a pointer to an empty string if one is not desired.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static std::vector&lt;LogBookPerson*&gt; </type>
                  <methodname>find</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>where</parameter>
                      <modifier>nullptr</modifier>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  This is not intended for general use.  It is used by
                  <classname>LogBook::</classname><methodname>findPeople</methodname>.
                  The method returns a vector 
                  pointers to dynamically allocated
                  <classname>LogBookPerson</classname> objects that match the
                  SQL where clause in <parameter>where</parameter>.  This
                  claus should omit the keyword <literal>WHERE</literal>.
                  
               </para>
                <para>
                  If <parameter>where</parameter> is a null pointer, as it is
                  by default, no filtering is done and the result is functionally
                  equivalent to that returned by <methodname>list</methodname>
                  below.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static std::vector&lt;LogBookPerson*&gt;</type>
                  <methodname> list</methodname>
                  <methodparam>
                      <type>CSqlite&amp;</type><parameter> db</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a list of pointers to dynamically allocated
                  <classname>LogBookPerson</classname> objects that
                  encapsulate all people that have been registered
                  in the logbook database.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<refentry id='daq3.logbookshift'>
   <refmeta>
      <refentrytitle id='daq3.logbookshift.title'>LogBookShift</refentrytitle>
      <manvolnum>3daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>LogBookShift</refname>
      <refpurpose>Encapsulates shifts in logbook databases</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
#include &lt;LogBookShift.h&gt;

class LogBookShift
{
public:
    int                               id() const;
    const char*                       name() const;
    const std::vector&lt;LogBookPerson*&gt;&amp; members() const;
    
    void addMember(CSqlite&amp; db, LogBookPerson* person);
    void removeMember(CSqlite&amp; db, LogBookPerson* person);
    void setCurrent(CSqlite&amp; db);

    static LogBookShift* create(
        CSqlite&amp; db,
        const char* shiftName, const std::vector&lt;LogBookPerson*&gt;&amp; people
    );
    static LogBookShift* create(CSqlite&amp; db, const char* shiftName);
    static std::vector&lt;LogBookShift*&gt; list(CSqlite&amp; db);
    static LogBookShift* find(CSqlite&amp; db, const char* name);
    static LogBookShift* getCurrent(CSqlite&amp; db);
};

      </synopsis>
      <cmdsynopsis>
         <command>
... -I$DAQINC -L$DAQLIB -lLogbook -Wl,-rpath=$DAQLIB
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This class encapsulates a shift.  A shift is a collection of people
            that work on an experiment together during data taking.  Shifts are
            used to organize work during the highly time critical use of beam-time.
            At any given time a shift can be on duty or off duty.  At most one
            shift can be on duty.  The on-duty shift is referred to in this
            documentation as the <firstterm>current shift</firstterm>.
          </para>
          <para>
            This class includes methods that are not intended for general use
            but are invoked by <classname>LogBook</classname> methods to hide
            implementation details from that class.  These methods will be
            pointed out and are documented in case there's an overlooked use
            case that crops up where they may be useful at the application level.
          </para>
    </refsect1>
    <refsect1>
      <title>METHODS</title>
      <variablelist>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>int</type>
                  <methodname>id</methodname>
                  <void />
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the primary key associated with the shift.
                  The primary key is a unique integer assigned to each shift.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>const char* </type>
                  <methodname>name</methodname>
                  <void />
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the name of the shift.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>const std::vector&lt;LogBookPerson*&gt;&amp; </type>
                  <methodname>members</methodname>
                  <void />
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the members of the shift.  The result is const reference
                  to a vector of <classname>LogBookPerson</classname> object.
                  Since you are getting a reference right into <classname>LogBookShift</classname>
                  member data you are not allowed to nor should you try to
                  figure out how to <literal>delete</literal> these objects.
                  They will be deleted when the <classname>LogBookShift</classname>
                  object is destroyed.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>void </type>
                  <methodname>addMember</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>LogBookPerson*</type><parameter> person</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  This method is not intended for general use.  It adds a new
                  <parameter>person</parameter> to the shift
                  represented by this object in the database
                  open on the Sqlite++ connection object <parameter>db</parameter>.
                  It is used e.g. by
                  <classname>LogBook::</classname><methodname></methodname>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>void </type>
                  <methodname>removeMember</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>LogBookPerson*</type><parameter> person</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  This method is not intended for general use.  It removes the
                  member <parameter>person</parameter> from the shift represented
                  by this object in the database open on the Sqlite++ connection
                  object referenced by <classname>db</classname>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>void </type>
                  <methodname>setCurrent</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not intended for general use, makes the shift represented by this
                  object the current shift.  The shift must live in the database
                  open on the Sqlite++ connection object <classname>db</classname>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static LogBookShift* </type>
                  <methodname>create</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>shiftName</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const std::vector&lt;LogBookPerson*&gt;&amp; </type>
                      <parameter>people</parameter>
                  </methodparam>
               </methodsynopsis>
               
            </term>
            <listitem>
                <para>
                  Not intended for general use, this method adds the
                  people in <parameter>people</parameter> to the shift named
                  <parameter>shiftName</parameter> in the database represented by
                  the Sqlite++ connection object <parameter>db</parameter>.
               </para>
               <para>
                  The returned value is a pointer to a dynamically allocated
                  <parameter>LogBookShift</parameter> object which must be
                  destroyed via <literal>delete</literal> once it is no longer
                  needed.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static LogBookShift* </type>
                  <methodname>create</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char*</type><parameter> shiftName</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  This method is not intended for general use
                  Creates a new shift named <parameter>shiftName</parameter> with
                  no members.  The shift is created in the database represented
                  by the Sqlite++ database connection object <parameter>db</parameter>.
                  The return value is a pointer to a dynamically created
                  <classname>LogBookShift</classname> object that encapsulates
                  that shift.  When that object is no longer needed, you must
                  destroy it using <literal>delete</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static std::vector&lt;LogBookShift*&gt; </type>
                  <methodname>list</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  This method is not intended for general use.
                  Returns a vector of pointers to encapsulations of all the
                  shifts in the database referenced by the Sqlite++
                  connection object <parameter>db</parameter>.
                  The objects pointed to are dynamically allocated and must
                  be destroyed using <literal>delete</literal> when they
                  are no longer needed.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static LogBookShift* </type>
                  <methodname>find</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char*</type><parameter> name</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  This method is not intended for general use.  Returns a pointer
                  to an encapsulation of the shift named <parameter>name</parameter>
                  in the logbook database referenced by the Sqlite++ database
                  connection object <parameter>db</parameter>.
                  If there is no match, <literal>nullptr</literal> is returned
                  instead.   The result points to a dynamically allocated object.
                  When your program no longer needs it it should be destroyed
                  with <literal>delete</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static LogBookShift* </type>
                  <methodname>getCurrent</methodname>
                  <methodparam>
                      <type>CSqlite&amp;</type><parameter> db</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  This method is not intended for general use.
                  If the logbook database referenced by the Sqlite++ database
                  connection object has a current shift, a pointer to an encapsulation
                  of that shift is returned.  If not, a <literal>nullptr</literal>
                  is returned in stead.  The returned object is dynamic and,
                  when no longer needed, <literal>delete</literal> must be
                  used to destroy it.
               </para>
            </listitem>
         </varlistentry>
    
      </variablelist>
    </refsect1>
</refentry>
<refentry id='daq3.logbookrun'>
   <refmeta>
      <refentrytitle id='daq3.logbookrun.title'>LogBookRun</refentrytitle>
      <manvolnum>3daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>LogBookRun</refname>
      <refpurpose>Encapsulates runs from logbooks.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
class LogBookRun {
public:
    typedef struct _RunInfo {
        int         s_id;
        int         s_number;
        std::string s_title;
    } RunInfo, *pRunInfo;
    typedef struct _Transition {
        int         s_id;
        int         s_transition;
        std::string s_transitionName;
        int         s_transitionTime;
        std::string s_transitionComment;
        LogBookShift* s_onDuty;
    } Transition, *pTransition;
    typedef struct _Run {
        RunInfo                 s_Info;
        std::vector&lt;Transition&gt; s_transitions;
    } Run, *pRun;
public:
    LogBookRun(CSqlite&amp; db, int id);

    const RunInfo&amp; getRunInfo() const;
    bool  isCurrent(CSqlite&amp; db) const;
    const Transition&amp; operator[](int n) const;
    size_t numTransitions() const;
    int    lastTransitionType() const;
    const char* lastTransition() const;
    bool isActive() const;
    void transition(CSqlite&amp; db, const char* type, const char* note);
    
    
    //
    static LogBookRun* currentRun(CSqlite&amp; db);
    static int runId(CSqlite&amp; db, int runNumber);
    static int begin(
        CSqlite&amp; db,  int number,
        const char* title, const char* remark=nullptr
    );
    static void  end (
        CSqlite&amp; db,  int runid,
        const char* remark=nullptr
    );
    static void  pause (
        CSqlite&amp; db,  int runid,
        const char* remark=nullptr
    );
    static void  resume (
        CSqlite&amp; db,  int runid,
        const char* remark=nullptr
    );
    static void  emergency_end (
        CSqlite&amp; db,  int runid,
        const char* remark
    );
    static std::vector&lt;LogBookRun*&gt; list(CSqlite&amp; db);
    static LogBookRun* find(CSqlite&amp; db, int runNumber);
    
    
    static bool isLegal(CSqlite&amp; db, int runId, int proposedTransition);
    
    
};
         
      </synopsis>
      <cmdsynopsis>
         <command>
 ... -I$DAQINC -L$DAQLIB -lLogbook -Wl,-rpath=$DAQLIB           
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Data taking is divided into time segments.  Each segment of data
            taking is called a <firstterm>run</firstterm>.  Runs and their
            state transitions (e.g. from active to ended) are logged in the
            logbook database.  This logging can be automated by using the
            <literal>logbookbundle</literal> package with the Readout GUI.
          </para>
          <para>
            In <link linkend='daq3.logbookshift' endterm='daq3.logbookshift.title' />
            we learned that shifts are collections of people and that a shift can
            be set to be the current shift.  When run state transitions are logged,
            the current shift is associated with that transition.  This allows
            us to know who was on duty during that segment of data taking.
          </para>
          <para>
            The <classname>LogBookShift</classname> encapsulates one run
            and its transition history in the logbook database.  We can think
            of a run as consisting of information about the run;
            the run number, run title, and a sequence of state transitions that
            each contain a transition type (e.g. begining the run), the time
            the transition was logged, the shift that was on-duty
            and, in the logbook, a short remark
            associated with the transition
          </para>
    </refsect1>
    <refsect1>
      <title>METHODS</title>
      <para>
         Some of the methods described in this section are not intended for
         general use but serve to hide implementation details from the
         <classname>LogBook</classname> top level API class. Nevertheless, they are
         documented here in case some unanticipated use case arises that
         necessitates an application making use of them in a time-scale too urgent
         to allow the needed capabilities to be put in the top level API.
         These methods will be noted as not intended for general use in the
         documentation below.
      </para>
      <variablelist>
         <varlistentry>
            <term>
               <constructorsynopsis>
                   <methodname>LogBookRun</methodname>
                <methodparam>
                    <type>CSqlite&amp; </type><parameter>db</parameter>
                </methodparam>
                <methodparam>
                    <type> int </type><parameter>id</parameter>
                </methodparam>
               </constructorsynopsis>
            </term>
            <listitem>
                <para>
                  This constructor is not intended for general use.  It is used
                  by the <classname>LogBook</classname> class to wrap an existing
                  run in the database referenced by the Sqlite++ database connection
                  object <parameter>db</parameter> that has the primary
                  key <parameter>id</parameter>.
               </para>
                <para>
                  All information about the run are fetched from the database
                  and loaded into the object under construction.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>const RunInfo&amp; </type>
                  <methodname>getRunInfo</methodname>
                  <void />
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a const reference to a struct within the object that
                  provides all information about the run.  The
                  <structname>RunInfo</structname> structure is documented in
                  <literal>DATA Types</literal> below.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>bool  </type>
                  <methodname>isCurrent</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not intended for general use but used to hide implementation
                  details from  the <classname>LogBook</classname> class
                  Returns <literal>true</literal> if the object represents
                  the current run in the logbook database referenced by the
                  Sqlite++ database connection object <parameter>db</parameter>,
                  otherwise returns <literal>false</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>const Transition&amp; </type>
                  <methodname>operator[]</methodname>
                  <methodparam>
                     <type>int </type>
                     <parameter>n</parameter>
                  </methodparam>
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a const reference to a
                  <structname>Transition</structname> struct that describes
                  the <parameter>n</parameter>'th transition (the Begin run
                  transition is number 0).  If <parameter>n</parameter>
                  is out of range, a <classname>std::out_of_range</classname>
                  error is thrown.   See <methodname>numTransitions</methodname>
                  below.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>size_t </type>
                  <methodname>numTransitions</methodname>
                  <void />
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the number of transitions the run has undergone.
                  <methodname>operator[]</methodname> can be used to
                  retrieve references to each transition.n
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>int    </type>
                  <methodname>lastTransitionType</methodname>
                  <void />
                  <modifier> const</modifier>
               </methodsynopsis>           
            </term>
            <listitem>
                <para>
                  Returns the integer code associated with the most recent
                  transition the run underwent.  See
                  <literal>DATA TYPES</literal> for a definition of the
                  transition code values.  It may be simpler, instead to
                  use <methodname>lastTransition</methodname> which returns
                  a string version of the transition.
                  Again see <literal>DATA TYPES</literal>.
               </para>
                <para>
                  It is the most recent transition that determines the current
                  state of the run as understood by the logbook.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>const char*</type>
                  <methodname> lastTransition</methodname>
                  <void />
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a text string that describes the most recent
                  transition the run had.  The most recent run state transition
                  determines the current state of the run.  See
                  <literal>DATA TYPES</literal> for information about the
                  possible values this can take.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>bool </type>
                  <methodname>isActive</methodname>
                  <void /><modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Examines the last state transition the run has undergone
                  and returns <literal>true</literal> if that transition
                  implies the run has not ended (note that <literal>PAUSED</literal>
                  runs are considered active too).  If not <literal>false</literal>
                  is returned
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>void </type>
                  <methodname>transition</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>type</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>note</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  This is not intended for general use.  It hides the implementation
                  details of runs and transitions  from the
                  <classname>LogBook</classname> class.
                  Attemtps to perform an arbitrary state transition. on
                  the run stored in the database connected to the
                  <parameter>db</parameter> Sqlite++ connection object.
               </para>
                <para>
                  The <parameter>type</parameter> parameter is a string
                  that identifies the type of transition to attempt.
                  See <literal>DATA TYPES</literal> for a list of legal strings.
                  <parameter>note</parameter> is a pointer to a character string
                  that is a remark to associate with the transition.  
                </para>
                <para>
                  Several error conditions are possible which all throw
                  <classname>LogBook::Exception</classname> exceptions:
                </para>
                <itemizedlist>
                  <listitem>
                     <para>
                        The transition name string does not designate a legal
                        transition name.
                     </para>
                  </listitem>
                  <listitem>
                     <para>
                        The transition requested is not legal because the
                        current state of the run forbids it. For example, a
                        run whose prior transition was <literal>BEGIN</literal>
                        cannot undertake a <literal>RESUME</literal> transition.
                     </para>
                  </listitem>
                  <listitem>
                     <para>
                        There is no current shift.  The current shift is associated
                        with the transition.  If there's no current shift,
                        no runs can undertake transitions.
                     </para>
                  </listitem>
                  <listitem>
                     <para>
                        Any error condition detected interacting with the
                        database.
                     </para>
                  </listitem>
                </itemizedlist>
                <para>
                  Note that if the state transition terminates the run
                  (<literal>END</literal> or <literal>EMERGENCY_END</literal>),
                  and the run is the current run, the database is told there is
                  no current run.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static LogBookRun* </type>
                  <methodname>currentRun</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not intended for general use.  If the logbook database
                  referenced by <parameter>db</parameter> has a current
                  run, it is wrapped in a dynamically created
                  <classname>LogBookRun</classname> and a pointer to that
                  object is returned.  If not <literal>nullptr</literal> is
                  returned.  It is the responsibility of the client to
                  dispose of the returned object via <literal>delete</literal>
                  when it is no longer needed.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static int runId</type>
                  <methodname></methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>int </type><parameter>runNumber</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not intended for general use.  This method returns
                  the primary key of the run numbered
                  <parameter>runNumber</parameter> from the logbook
                  database referenced by <parameter>db</parameter>.
                  If there is no run with that number a
                  <classname>LogBook::Exception</classname> is returned.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static int </type>
                  <methodname>begin</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type> int </type><parameter>number</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>title</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>remark</parameter>
                      <initializer>nullptr</initializer>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not intended for general use.  This method
                  creates a new run with the provided
                  <parameter>number</parameter> and <parameter>title</parameter>
                  in the database referenced by <parameter>db</parameter>
                  and <parameter>remark</parameter>.
                  It then uses
                  <methodname>transition</methodname> to initiate a
                  <literal>BEGIN</literal> state transition to log the
                  beginning of that run.  It then makes that
                  run the current run.  The following errors can be thrown
                  as <classname>LogBook::Exception</classname> objects:
               </para>
                <itemizedlist>
                  <listitem>
                     <para>
                        A run with this run number cannot already exist.
                     </para>
                  </listitem>
                  <listitem>
                     <para>
                        There cannot already be a current run. 
                     </para>
                  </listitem>
                </itemizedlist>
               <para>
                  The return value from this method is the primary key assigned
                  to the new run by the database when it was created.
               </para>
            </listitem>

         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static void  </type>
                  <methodname>end</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type> int </type><parameter>runid</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>remark</parameter>
                      <initializer>nullptr</initializer>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  This is not intended for general use.
                  Attempts an end run transition on the run identified
                  by the primary key <parameter>runid</parameter>
                  <parameter>db</parameter> is the Sqlite++ database
                  connection object connnected to the datasbase to be modified.
                  <parameter>remark</parameter> is the comment to be associated
                  with the transition.
               </para>
                <para>
                  In addition to any error the <methodname>transition</methodname>
                  method may throw, an exception is, of course, thrown if
                  there is no run with the primary key <parameter>runid</parameter>.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static void </type>
                  <methodname> pause </methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>int </type><parameter>runid</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>remark</parameter>
                      <initializer>nullptr</initializer>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Same as <methodname>end</methodname> but attempts a
                  <literal>PAUSE</literal> transition to log that the
                  on-going data taking run has been paused.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static void  </type>
                  <methodname>resume</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>int </type><parameter>runid</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>remark</parameter>
                      <initializer>nullptr</initializer>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  same as <methodname>end</methodname> however attempts
                  a <literal>RESUME</literal> transition.  That is a run,
                  whose data taking is in the paused state due to the most
                  recent transition being <literal>PAUSE</literal> is marked
                  as actively taking data again.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static void  </type>
                  <methodname>emergency_end</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>int </type><parameter>runid</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>remark</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Attemts an <literal>EMERGENCY_END</literal> transition.
                  This marks a run ended in a way that flags the end was not normal.
                  The most common use of <literal>EMERGENCY_END</literal> is
                  data acquisition system failure while a run was active.
                  When the system starts up, it then detects that there is a currently
                  active run in the logbook and forces an
                  <literal>EMERGENCY_END</literal> to ensure there's no active/current
                  run when the next <literal>BEGIN</literal> is attempted.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static std::vector&lt;LogBookRun*&gt; </type>
                  <methodname>list</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not for general use.  This method returns a vector of
                  pointer to <classname>LogBookRun</classname> objects that
                  encapsulate <emphasis>all</emphasis> runs in the logbook.
                  The objects pointed to are dynamically instantiated. Once
                  they are no longer needed, you must <literal>delete</literal>
                  them all in order to prevent memory/resource leaks.
               </para>
                <para>
                  <parameter>db</parameter> is the Sqlite++ database object
                  that is connected to the logbook database.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static LogBookRun* </type>
                  <methodname>find</methodname>
                  <methodparam>
                      <type>CSqlite&amp;</type><parameter> db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>int </type><parameter>runNumber</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not intended for general use. Locates the run with in
                  the database referenced by <parameter>db</parameter> with
                  the run number <parameter>runNumber</parameter> and
                  wraps the data associated with it in a
                  <classname>LogBookRun</classname> object returning a pointer to it.
                  If there is no match, a <literal>nullptr</literal> is returned
                  instead. 
               </para>
                <para>
                  Note that the pointer returned points to a dynamically allocated
                  object.  To prevent memory/resource leaks, when the program
                  no longer needs that object it should use
                  <literal>delete</literal> to destroy it.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static bool </type>
                  <methodname>isLegal</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>int </type><parameter>runId</parameter>
                  </methodparam>
                  <methodparam>
                      <type>int </type><parameter>proposedTransition</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not intended for general use.  Locates the run in the
                  database referenced by <parameter>db</parameter> with the
                  primary key <parameter>runId</parameter> and checks to see
                  if the current state of that run allows the
                  <parameter>proposedTransition</parameter> to occur.
                  If so <literal>true</literal> is returned otherwise
                  <literal>false</literal>.
               </para>
                <para>
                  This method can throw an
                  <classname>LogBook::Exception</classname> if, for example,
                  there is no matching run.
                </para>
            </listitem>
         </varlistentry>

      </variablelist>
    </refsect1>
    <refsect1>
      <title>DATA TYPES</title>
      <para>
         The <classname>LogBookRun</classname> class defines three public
         data types.  These data types, and their members are described
         in this section.
      </para>
   
    <refsect2>
      <title><structname>RunInfo</structname></title>
      <para>
         This struct provides the run metadata. It consists of the following
         fields:
      </para>
      <variablelist>
         <varlistentry>
            <term><type>int</type>  <structfield>s_id</structfield></term>
            <listitem>
                <para>
                  Contains the primary key of the run that is described
                  by this run metadata.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>int</type> <structfield>s_number</structfield></term>
            <listitem>
                <para>
                  Contains the run number of the run that's described by
                  this run metadata.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>std::string</type> <structfield>s_title</structfield></term>
            <listitem>
                <para>
                  Contains the title of the run described by this struct instance.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect2>
    <refsect2>
      <title>Transition</title>
      <para>
         The <structname>Transition</structname> structure provide information
         about a single transition the run has undergone. 
         <classname>LogBookRun</classname> instances contain a sequence of at least
         one transitions (a <literal>BEGIN</literal> transition is what brings
         a run into being).  
      </para>
      <para>
         <structname>Transition</structname> structs have the following fields:
      </para>
      <variablelist>
         <varlistentry>
            <term><type>int</type> <structfield>s_id</structfield></term>
            <listitem>
                <para>
                  Primary key of the transition in the transition table.
                  See the <link linkend='daq5.logbookschema' endterm='daq5.logbookschema.title' />
                  reference page for the full logbook schema.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>int</type> <structfield>s_transition</structfield></term>
            <listitem>
                <para>
                  An integer that describes the transition see
                  <link linkend='daq3.logbookrun.trantbl' endterm='daq3.logbookrun.trantbl.title' />
                  for the values this can take.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>std::string</type>  <structfield>s_transitionName</structfield></term>
            <listitem>
                <para>
                  Contains a text string that identifies the transition represented
                  by this struct. See
                  <link linkend='daq3.logbookrun.trantbl' endterm='daq3.logbookrun.trantbl.title' />
                  for information about the values this string can take.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>int</type> <structfield>s_transitionTime</structfield></term>
            <listitem>
                <para>
                  The time(2) at which this transition was logged. 
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>std::string</type> <structfield>s_transitionComment</structfield></term>
            <listitem>
                <para>
                  A remark that can be logged with the transition. This is
                  interpreted as plain text, however, if markdown is included,
                  it will be properly rendered by the logbook renderers.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>LogBookShift*</type>  <structfield>s_onDuty</structfield></term>
            <listitem>
                <para>
                  Pointer to a <classname>LogBookShift</classname> object
                  that encapsulates the shift that was on duty when this
                  transition was logged. For more on this object type, see
                  <link linkend='daq3.logbookshift' endterm='daq3.logbookshift.title' />
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <table id='daq3.logbookrun.trantbl'>
         <title id='daq3.logbookrun.trantbl.title'>State transition values</title>
         <tgroup cols='3'>
            <thead>
               <row>
                  <entry>s_transition value</entry>
                  <entry>s_transitionName value</entry>
                  <entry>Transition type</entry>
               </row>
            </thead>
            <tbody>
               <row>
                  <entry>1</entry><entry>BEGIN</entry>
                  <entry>Begin run. This is always the first transition</entry>
               </row>
               <row>
                  <entry>2</entry><entry>END</entry>
                  <entry>
                     End of run.  This or <literal>EMERGENCY_END</literal>
                     are always the last transition.
                  </entry>
               </row>
               <row>
                  <entry>3</entry><entry>PAUSE</entry>
                  <entry>
                     Pause run. Data taking is temporarly paused.
                  </entry>
               </row>
               <row>
                  <entry>4</entry><entry>RESUME</entry>
                  <entry>
                     Resume run. Indicates a paused run has resumed taking
                     data.
                  </entry>
               </row>
               <row>
                  <entry>5</entry><entry>EMERGENCY_END</entry>
                  <entry>Abnormal end of run.</entry>
               </row>
            </tbody>
         </tgroup>
      </table>
    </refsect2>
    <refsect2>
      <title>Run</title>
      <para>
         This struct contains all of the information about a run fetched from the
         database:
      </para>
      <variablelist>
         <varlistentry>
            <term><type>RunInfo</type>  <structfield>s_Info</structfield></term>
            <listitem>
                <para>
                  Contains the run metadata
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>std::vector&lt;Transition&gt;</type> <structfield>s_transitions</structfield></term>
            <listitem>
                <para>
                  Contains all of the information about all of the transitions
                  the run has undergone.  The elements of this arrary are
                  in chronological order.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect2>
   </refsect1>
</refentry>

<refentry id='daq3.logbooknote'>
   <refmeta>
      <refentrytitle id='daq3.logbooknote.title'>LogBookNote</refentrytitle>
      <manvolnum>3daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>LogBookNote</refname>
      <refpurpose>Encapsulate logbook notes.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
#include &lt;LogBookNote.h&gt;

class LogBookNote
{
public:
    typedef struct _NoteText {
        int        s_id;
        int        s_runId;     // Associated run.
        int        s_authorId;
        time_t     s_noteTime;
        std::string s_contents;
    } NoteText, *pNoteText;
    typedef struct _ImageInfo {
        std::string s_filename;
        size_t      s_offset;
    } ImageInfo, *pImageInfo;
    typedef struct _NoteImage {
        int         s_id;
        int         s_noteId;
        int         s_noteOffset;
        std::string s_originalFilename;
        size_t      s_imageLength;
        void*       s_pImageData;
    } NoteImage, *pNoteImage;
public:
    LogBookNote(CSqlite&amp; db, int noteId);
    
    LogBookRun* getAssociatedRun(CSqlite&amp; db) const;
    const NoteText&amp; getNoteText() const;
    size_t          imageCount() const;
    const NoteImage&amp; operator[](int n) const;
    std::string substituteImages();
    
    static LogBookNote* create(
        CSqlite&amp; db, LogBookRun* run, const char* string,
        LogBookPerson* pPerson,
        const std::vector&lt;ImageInfo&gt;&amp; images
    );
    
    static std::vector&lt;int&gt; listRunNoteIds(CSqlite&amp; db, int runId);
    static std::vector&lt;int&gt; listNonRunNotes(CSqlite&amp; db);
    static std::vector&lt;LogBookNote*&gt; getAllNotes(CSqlite&amp; db);
    static std::vector&lt;LogBookNote*&gt; getRunNotes(CSqlite&amp; db, int runId);
    static std::vector&lt;LogBookNote*&gt; getNonRunNotes(CSqlite&amp; db);
    std::string exportImage(const NoteImage&amp; image);
    
};

      </synopsis>
      <cmdsynopsis>
         <command>
            
... -I$DAQINC -L$DAQLIB -lLogbook -Wl,-rpath=$DAQLIB

         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Instances of <classname>LogBookNote</classname> encapsulate data
            in the database stored for a single note. Notes are considered to be
            a soup of rich text in Markdown format
            (see <ulink url='https://https://www.markdownguide.org/' />).
            A note has metadata that consists of an author, a timestamp that
            indicates when it was submitted to the database and optionally
            a run with which it's associated.
          </para>
          <para>
            As the Markdown syntax supports image file references, and we want
            our logbook databases to be self-contained, when a note is submitted,
            it is the authoring software's responsibility to submit the markdown
            along with a set of image filenames and the byte offset into the
            note text at which the image file reference begins.
            (the byte offset of the <literal>!</literal> in e.g.
            <literal>![some text](/image/file/path.jpg)</literal>).
          </para>
          <para>
            Methods are provided to obtain the note text, re-exporting the images
            into the logbook temporary directory and fixing up image references
            so that they work properly.  Image formats are not restricted by
            this software but only by the software used to view renderings of
            the markdown code (e.g. the web-browser for HTML renderings or
            acceptable LaTeX image formats for PDF).
          </para>
          <para>
            It is important to note that this class's rendering is limited to
            provding fixed-up markdown text. The problem of rendering this
            markdown into PDF or HTML and viewing it is pushed out onto
            user level software (e.g. <command>lg_print</command>
            or <command>lg_browse</command>).  Reasonable well developed Tcl
            support software has been developed and will be described in
            pages in the <literal>3tcl</literal> reference section.
          </para>
    </refsect1>
    <refsect1>
      <title>METHODS</title>
      <para>
         Some of the methods described here are provide to hide implementation
         details from the <classname>LogBook</classname> class and not intended
         for general use.  These will be pointed out but documented for
         programmers of the logbook support software and to allow for
         use cases not-foreseen.
      </para>
      <variablelist>
         <varlistentry>
            <term>
               <constructorsynopsis>
                   <methodname>LogBookNote</methodname>
                <methodparam>
                    <type>CSqlite&amp; </type><parameter>db</parameter>
                </methodparam>
                <methodparam>
                    <type>int </type><parameter>noteId</parameter>
                </methodparam>
               </constructorsynopsis>
            </term>
            <listitem>
                <para>
                  Not intended for general use.  Locates the note with the
                  primary key <parameter>noteId</parameter> from the
                  database indicated by <parameter>db</parameter> and
                  loads the data associated with that note, wrapping it in a
                  newly constructed <classname>LogBookNote</classname> instance.
               </para>
                <para>
                  This constructor is intended to hide note implementation details
                  from the <classname>LogBook</classname> API class.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBookRun* </type>
                  <methodname>getAssociatedRun</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  If this note in the database <parameter>db</parameter>,
                  the data associated with that run is wrapped into a new
                  <classname>LogBookRun</classname> object and a pointer
                  to that object returned.  As the
                  <classname>LogBookRun</classname> object is a dynamically
                  created object, when it is no longer needed your
                  program must destroy it with <literal>delete</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>const NoteText&amp; </type>
                  <methodname>getNoteText</methodname>
                  <void />
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a <structname>NoteText</structname> reference
                  to the data that describe the note.   See
                  <literal>DATA TYPES</literal> for a description of the
                  <structname>NoteText</structname> data structure.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>size_t</type>
                  <methodname>imageCount</methodname>
                  <void />
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the number of image referenes that are claimed to
                  be embedded in to the note Markdown text.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>const NoteImage&amp; </type>
                  <methodname>operator</methodname>
                  <methodparam>
                      <type>int </type><parameter>n</parameter>
                  </methodparam>
                  <modifier>const</modifier>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns information about the <parameter>n</parameter>'th
                  image reference in the note text.  The
                  <structname>NoteImage</structname> data structure
                  is described in <literal>DATA TYPES</literal>.  If
                  <parameter>n</parameter> is out of range of the number
                  of images actually associated with the note text,
                  a <classname>std::out_of_range</classname> exception is
                  thrown.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>std::string </type>
                  <methodname>substituteImages</methodname>
                  <void />
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Iterates over the images associated with the note.
                  For each image reference, the image data in the database is
                  exported into a file in the logbook temporary directory,
                  the image reference in the logbook text is then fixed up to
                  properly reference the exported image.  
               </para>
                <para>
                  The return value is the text of the note after all images
                  have been exported and their references fixed up.
                  Note that the original text in the database is not modified.
                </para>
                <para>
                  <classname>LogBook::Exception</classname> is thrown if the
                  byte offset of an image reference does not point to a valid
                  markdown image reference.  Note that image export does not
                  imply that the data are necessarily a valid image format.
                  The code just exports the bytes it has.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static LogBookNote* </type>
                  <methodname>create</methodname>
                  <methodparam>
                      <type>CSqlite&amp;</type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>LogBookRun* </type><parameter>run</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const char* </type><parameter>string</parameter>
                  </methodparam>
                  <methodparam>
                      <type>LogBookPerson* </type><parameter>pPerson</parameter>
                  </methodparam>
                  <methodparam>
                      <type>const std::vector&lt;ImageInfo&gt;&amp; </type>
                      <parameter>images</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  This method is not intended for general use.
                  It creates a new note in the database indicated by
                  <parameter>db</parameter>.   <parameter>run</parameter> is
                  a pointer to a run encapsulation for a run that will be associated
                  with the note.  If there is no associated run, this should be
                  a <literal>nullptr</literal>.  <parameter>string</parameter> are
                  the contents of the note. <parameter>pPerson</parameter>
                  is a pointer to an encapsulation of the person who is authoring
                  the note.  <parameter>images</parameter> are a vector
                  of image files paths and where their references appear in the
                  <parameter>string</parameter>.  The
                  <structname>ImageInfo</structname> struct is documented in
                  <literal>DATA TYPES</literal>
               </para>
                <para>
                  On success a new note has been created and a new
                  <classname>LogBookNote</classname> wrapped around its data.
                  A pointer to that note is then returned.   The
                  <classname>LogBookNote</classname> object is dynamically
                  created and, therefore, when no longer needed must be
                  destroyed with <literal>delete</literal>/
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static std::vector&lt;int&gt; </type>
                  <methodname>listRunNoteIds</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>int </type><parameter>runId</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not intended for general use.  Given a logbook database;
                  <parameter>db</parameter> and the primary key of a run
                  in that database, returns a vector of all of the note ids
                  associated with that run.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static std::vector&lt;int&gt; </type>
                  <methodname>listNonRunNotes</methodname>
                  <methodparam>
                      <type>CSqlite&amp;</type><parameter> db</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not for general use.  Given a logbook database;
                  <parameter>db</parameter> returns the ids of all notes
                  that are not associated with any run.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static std::vector&lt;LogBookNote*&gt; </type>
                  <methodname>getAllNotes</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not intended for general use.
                  Given a logbook database; <parameter>db</parameter>,
                  returns a vector of pointers to
                  <classname>LogBookNote</classname> encapsulations of all notes.
                  The <classname>LogBookNote</classname> objects are all dynamically
                  created so when  no longer needed, the program must destroy them
                  with <literal>delete</literal> to avoid resourcde leaks.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static std::vector&lt;LogBookNote*&gt; </type>
                  <methodname>getRunNotes</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
                  <methodparam>
                      <type>int </type><parameter>runId</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Not intended for general use. Given a
                  database <classname>db</classname> connection object
                  and the primary key of a run; <parameter>runId</parameter>,
                  for each note associated with that run, encapsulates it in
                  a <classname>LogBookRun</classname> object. A vector containing
                  pointer to all those objects is then returned.
                  the objects are dynamically created and must be destroyed
                  using <literal>delete</literal> when no longer needed.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>static std::vector&lt;LogBookNote*&gt; </type>
                  <methodname>getNonRunNotes</methodname>
                  <methodparam>
                      <type>CSqlite&amp; </type><parameter>db</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Given a logbook database; <parameter>db</parameter>,
                  encapsulates all notes that are not associated with a run
                  in <classname>LogBookNote</classname> objects and return a
                  vector of pointers to those objects.
                  Since the objects are dynamically created and must be destroyed
                  using <literal>delete</literal> when no longer needed.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>std::string</type>
                  <methodname>exportImage</methodname>
                  <methodparam>
                      <type>const NoteImage&amp; </type><parameter>image</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Given image information, exports the image into a file
                  in the logbook image diretory and returs a full path to the
                  image.  This is not intended for general use. Normally it's
                   used internally as part of
                   <methodname>substituteImages</methodname>, however it turned
                   out to be useful by they Python bindings API.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>      
    </refsect1>
    <refsect1>
      <title>DATA TYPES</title>
      <para>
         <classname>LogBookNote</classname> exports several data types.
      </para>
      <refsect2>
         <title>NoteText</title>
         <para>
            This data type encapsulates the raw note text and metadata.
         </para>
         <variablelist>
            <varlistentry>
               <term><type>int</type> <structfield>s_id</structfield></term>
               <listitem>
                   <para>
                     The primary key of the note.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>int</type> <structfield>s_runId</structfield></term>
               <listitem>
                   <para>
                     If there is an associated run, this is it's primary key. If
                     not, this value is <literal>0</literal> which is an invalid
                     primary key value.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>int</type> <structfield>s_authoriId</structfield></term>
               <listitem>
                   <para>
                     The primary key of the person who authored the note.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>time_t</type> <structfield>s_noteTime</structfield></term>
               <listitem>
                   <para>
                     The time(2) at which the note was entered in the database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>std::string</type> <structfield>s_contents</structfield></term>
               <listitem>
                   <para>
                     The text of the note itself.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
      <refsect2>
         <title>ImageInfo</title>
         <para>
            This struct provides information about images referenced in the note text.
            This struct is used to specify files to capture into the database.
         </para>
         <variablelist>
            <varlistentry>
               <term><type>std::string</type> <structfield>s_filename</structfield></term>
               <listitem>
                   <para>
                     The original file path specifying an image that is to be
                     loaded into the database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>size_t</type> <structfield>s_offset</structfield></term>
               <listitem>
                   <para>
                     The byte offset of the <literal>!</literal> that is the
                     first character of the reference to this image in the
                     note text.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
      <refsect2>
         <title>NoteImage</title>
         <para>
            This struct captures the data stored in the database for images that
            are captured in the database.
         </para>
         <variablelist>
            <varlistentry>
               <term><type>int</type> <structfield>s_id</structfield></term>
               <listitem>
                   <para>
                     The primary key of the image in its table.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>int</type> <structfield>s_noteId</structfield></term>
               <listitem>
                   <para>
                     The primary key of the note that needs this image.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>int</type> <structfield>s_noteOffset</structfield></term>
               <listitem>
                   <para>
                     The offset in the note text at which the link referencing
                     this note begins.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>std::string</type>s_originalFilename</term>
               <listitem>
                   <para>
                     The original filename of the note.  This is normally
                     used to help construct the name of the exportefile.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>size_t</type> <structfield>s_imageLength</structfield></term>
               <listitem>
                   <para>
                     Number of bytes of image data.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>void*</type> <structfield>s_pImageData</structfield></term>
               <listitem>
                   <para>
                     Pointer to image data; that is the original contents of
                     the file.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>

    </refsect1>
    <refsect1>
      <title>FILES</title>
      <variablelist>
         <varlistentry>
            <term><filename>~/.nscl-logbook</filename></term>
            <listitem>
                <para>
                  Directory into which the image files are exported from the
                  data base by e.g. <methodname>substituteImages</methodname>.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>

<!-- /manpage -->

<!-- manpage 3tcl -->
<refentry id='tcl3.logbook'>
   <refmeta>
      <refentrytitle id='tcl3.logbook.title'>logbook</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>logbook</refname>
      <refpurpose>Access Logbooks from Tcl</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
         
lappend auto_path [file join $::env(DAQROOT) TclLibs]
package require logbook

      </programlisting>
      <cmdsynopsis>
         <command>
logbook::logbook create <replaceable>filename experiment spokesperson purpose</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set instance [logbook::logbook open <replaceable>filename</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set logbookTempdir [logbook::logbook tempdir]
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            The <literal>logbook</literal> package provides access to NSCL
            logbook databases.  It provides the <command>logbook::logbook</command>
            command which can create and access databases.  
          </para>
          <para>
            A disadvantage of the <literal>logbook</literal> package is, that while
            it provides an object oriented interface to the C++ API, it places
            the burden of resource management directly on the script author.
            Generally, this is terra incongnita for a Tcl programmer.  If
            possible We recommend that you use the
            <link linkend='tcl3.logbookadmin' endterm='tcl3.logbookadmin.title' />
            package instead as that procedural interface does storage management
            for you.
          </para>
          <refsect2>
            <title>SUBCOMMANDS</title>
            <para>
               The <literal>logbook</literal> package provides a single command
               <command>logbook::logbook</command> which is the base command
               of a command ensemble with three subcommands:
            </para>
            <variablelist>
               <varlistentry>
                  <term><command>create <replaceable>filename experiment spokesperson purpose</replaceable></command></term>
                  <listitem>
                      <para>
                        Creates a new logbook database in
                        <parameter>filename</parameter>.  <parameter>filename</parameter>
                        must not yet exist.  <parameter>experiment</parameter>
                        should be the experiment identifier, usually assigned by
                        the institution that scheduled the experiment,
                        <parameter>spokesperson</parameter> should be the
                        person who proposed the experiment, <parameter>purpose</parameter>
                        should be a brief statement of purpose for the experiment.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><command>open <replaceable>filename</replaceable></command></term>
                  <listitem>
                      <para>
                        Provides access to the logbook database in the file
                        <parameter>filename</parameter>.  This access is
                        provided in the form of a <firstterm>logbook instance</firstterm>
                        command.  This, is a command ensmeble whose subcommands
                        allow you to manipulate the logbook.  See
                        <link linkend='tcl3.logbookinstance' endterm='tcl3.logbookinstance.title' />
                        for more about logbook instances and what you can do with them.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><command>tempdir</command></term>
                  <listitem>
                      <para>
                        Returns a path to the directory the logbook system
                        uses to hold files it need to create.  If your software
                        needs to create files that don't require preservation
                        beyond the lifetime of your script place them here.
                        The files placed here are normally files for which there
                        is only a transient need (e.g. rendered markdown which
                        will then be passed to a browser or image files needed
                        in the rendering of markdown text).
                   </para>
                </listitem>
               </varlistentry>
            </variablelist>
          </refsect2>
    </refsect1>
</refentry>
<refentry id='tcl3.logbookinstance'>
   <refmeta>
      <refentrytitle id='tcl3.logbookinstance.title'>logbookinstance</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>logbook instance</refname>
      <refpurpose>Logbook API instance object.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
lappend auto_path [file join $::env(DAQROOT) TclLibs]
package require logbook

set instance [logbook::logbook open <replaceable>logbook-file</replaceable>]

...
      </programlisting>
      <cmdsynopsis>
         <command>
$instance destroy
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set person [$instance addPerson <replaceable>lastname firstname ?salutation?</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set people [$instance findPeople ?where-clause?]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set people [$instance listPeople]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set person [$instance getPerson <replaceable>id</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set shift [$instance createShift <replaceable>shiftname ?people?</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set shift [$instance getShift <replaceable>id</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
$instance addShiftMember <replaceable>shift-instance person-instance</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
$instance removeShiftMember <replaceable>shift-instance person-instance</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set shifts [$instance listShifts]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set shift [$instance findShift <replaceable>shift-name</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
$instancce setCurrentShift <replaceable>shift-name</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set shift [$instance getCurrentShift]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set run [$instance begin <replaceable>number title ?remark?</replaceable>      
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
$instance end <replaceable>run ?remark?</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
$instance pause <replaceable>run ?remark?</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
$instance resume <replaceable>run ?remark?</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
$instance emergencyStop <replaceable>run ?remark?</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set runs [$instance listRuns]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set run [$instance findRun <replaceable>run-number</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set id [$instance runId <replaceable>run</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set run [$instance currentRun]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set note [$instance createNote <replaceable>author text ?run?</replaceable>]
         </command>
         <command>
set note [$instance createNote <replaceable>author text images imageoffsets ?run?]</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set note [$instance getNote <replaceable>id</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set notes [$instance listAllNotes]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set notes [$instance listNotesForRunId <replaceable>id</replaceable>]
         </command>
         <command>
set notes [$instance listNotesForRunNumber <replaceable>run-number</replaceable>]
         </command>
         <command>
set notes [$instance listNotesForRun <replaceable>run</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set notes [$instance listNonRunNotes]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set run [$instance getNoteRun <replaceable>note</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set person [$instance getNoteAuthor <replaceable>note</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set flag [$instance kvExists <replaceable>key</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set value [$instance kvGet <replaceable>key</replaceable>]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
$instance kvSet <replaceable>new-or-existing-key value</replaceable>      
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
$instance kvCreate <replaceable>new-key value</replaceable>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            It's not possible for you to directly instantiate a logbook instance
            object. You obtain one from the <command>logbook::logbook</command>
            command.  See
            <link linkend='tcl3.logbook' endterm='tcl3.logbook.title' />.
            Logbook instances are command ensembles who's subcommand manipulate
            the logbook database they were connected to by the
            <command>logbook::logbook open</command> command.
          </para>
          <refsect2>
            <title>SUBCOMMANDS</title>
           <para>
              The subcommands of a logbook instance are:
            </para>
           <variablelist>
            <varlistentry>
               <term>
                  <command>destroy</command>
               </term>
               <listitem>
                   <para>
                     All logbook instance commands are dynamically created and
                     have storage and other resources associated with them.
                     When a logbook instance is not longer needed this subcommand
                     should be used to destroy it.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>addPerson <replaceable>lastname firstname ?salutation?</replaceable></command></term>
               <listitem>
                   <para>
                     Registers a new person with the logbook data base.
                     The <parameter>lastname</parameter> and <parameter>firstname</parameter>
                     define the person as does an optional <parameter>salutation</parameter>
                     (e.g. Mr., Ms. Dr. Prof. etc.).  The result of this command
                     is a <firstterm>person instance</firstterm>.
                   </para>
                   <para>
                     Person instances are described in
                     <link linkend='tcl3.personinstance'
                           endterm='tcl3.personinstance.title' />.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>findPeople <replaceable>?where-clause?</replaceable></command></term>
               <listitem>
                   <para>
                     Returns a list of person instances that match the
                     conditions in the optional <parameter>where-clause</parameter>.
                     The <parameter>where-clause</parameter> is an SQL
                     fragment that can be appended to the <literal>WHERE</literal>
                     part of the database query that satisfies this command.
                     
                   </para>
                   <para>
                     If <parameter>where-clause</parameter> is not supplied,
                     all people are returned.  This is functionally equivalent
                     to <command>listPeople</command> below.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>listPeople</command></term>
               <listitem>
                   <para>
                     Equivalent to <command>findPeople</command> with a
                     where-clause that's always true, this command returns
                      a list of people instances that encapsulate all people
                      defined to the database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>getPerson <replaceable>id</replaceable></command></term>
               <listitem>
                   <para>
                     Given the primary key (<parameter>id</parameter>) of a person
                     retrieves information about that person from the logbook
                     database and wraps a person instance around it.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>createShift <replaceable>shiftname ?people?</replaceable></command></term>
               <listitem>
                   <para>
                     Creates a new shift <parameter>shiftname</parameter>. If
                     <parameter>people</parameter> is supplied it must be a list
                     of person instances.  Each of those people will be added
                     to the shift.  The return value from this
                     subcommand is a <firstterm>shift instance</firstterm>.
                     Shift intances are command ensembles that are described in
                     <link linkend='tcl3.shiftinstance'
                           endterm='tcl3.shiftinstance.title' />.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>getShift <replaceable>id</replaceable></command></term>
               <listitem>
                   <para>
                     Returns a shift instance for the shift with primary key
                     <parameter>id</parameter>.  If there is no shift with that
                     primary key, the command completes with an error signalled.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>addShiftMember <replaceable>shift-instance person-instance</replaceable></term>
               <listitem>
                   <para>
                     Adds a member to the shift with <parameter>shift-instance</parameter>
                     as its shift instance object command. The person added
                     has <parameter>person-instance</parameter> as its person
                     instance object command.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>removeShiftMember <replaceable>shift-instance person-instance</replaceable></command></term>
               <listitem>
                   <para>
                     Removes a member from a shift.  THe parameters are the
                     same as for <command>addShiftMember</command>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>listShifts</command></term>
               <listitem>
                   <para>
                     Returns a Tcl list whose elements are shift instance object
                     commands.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>findShift <replaceable>shift-name</replaceable></command></term>
               <listitem>
                   <para>
                     Finds the shift named <parameter>shift-name</parameter>
                     and wraps it in a shift instance object command.  If
                     <parameter>shift-name</parameter> does not exist,  an
                     empty string is returned instea.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>setCurrentShift <replaceable>shift-name</replaceable></term>
               <listitem>
                   <para>
                     Sets the current shift to be the shift named
                     <parameter>shift-name</parameter>. An error is raised if
                     <parameter>shift-name</parameter> is not the name of any
                     shift.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>getCurrentShift</command></term>
               <listitem>
                   <para>
                     If a current shift has been established, this returns a
                     shift instance command that refers to it.  If not,
                     an empty string is returned. 
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term> begin <replaceable>number title ?remark?</replaceable> </term>
               <listitem>
                   <para>
                     Begins a new run with run number <parameter>number</parameter>
                     and title <parameter>title</parameter>.  If provided the optional
                     <parameter>remark</parameter> is a textual remark that his
                     associated with the run's begin state transition. The return value, on success,
                     is a run object instance.
                     See <link linkend='tcl3.runinstance'
                              endterm='tcl3.runinstance.title' /> for information
                     about run instance object commands.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>end <replaceable>run ?remark?</replaceable></command></term>
               <listitem>
                   <para>
                     Ends the run whose run instance command is
                     <parameter>run</parameter>.  The optional
                     <parameter>remark</parameter> is a textual remark that's
                     associated with the end run operation.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>pause <replaceable>run ?remark?</replaceable></command></term>
               <listitem>
                   <para>
                     Pauses the run whose run instance command is
                     <parameter>run</parameter>.  The optional
                     <parameter>remark</parameter> is a textual remark that's
                     associated with the end pause operation.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>resume <replaceable>run ?remark?</replaceable></command></term>
               <listitem>
                   <para>
                     Resumes the run whose run instance command is
                     <parameter>run</parameter>.  The optional
                     <parameter>remark</parameter> is a textual remark that's
                     associated with the resume run operation.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>emergencyStop <replaceable>run ?remark?</replaceable></command></term>
               <listitem>
                   <para>
                     Performs an emergency end run on the run
                     run instance command is
                     <parameter>run</parameter>.  The optional
                     <parameter>remark</parameter> is a textual remark that's
                     associated with the end run operation.
                   </para>
                   <para>
                     An emergency stop, or emergency end as it's also referred to,
                     flags the end of a run that, due to data acquisition system
                     failures is not able to end properly.  For all intents and
                     purposes it is an end run but a different transition code
                     is used to log that something funny happened to cause the end.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>listRuns</command></term>
               <listitem>
                   <para>
                     Returns a list of all of the runs known to the database
                     as run instance commands.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>findRun <replaceable>run-number</replaceable></command></term>
               <listitem>
                   <para>
                     Finds the run with the number <parameter>run-number</parameter>
                     in the database and packages it up in a run instance command
                     which the command returns.  If there is no matching run,
                     an empty string is returned.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>runId <replaceable>run</replaceable></command></term>
               <listitem>
                   <para>
                     Given a run instance command, returns the primary key of the
                     run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>currentRun</command></term>
               <listitem>
                   <para>
                     If there is a current run, a run instance command wrapping
                     it is returned.  If not an empty string is returned.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <cmdsynopsis>
                     <command>createNote <replaceable>author text ?run?</replaceable></command>
                     <command>createNote <replaceable>author text images imageoffsets ?run?</replaceable></command>
                  </cmdsynopsis>
               </term>
               <listitem>
                   <para>
                     Creates a new note and returns a note instance command.
                     For information about note instance commands, see
                     <link linkend='tcl3.noteinstance'
                           endterm='tcl3.noteinstance.title' />.
                     While, as you can see there are a couple of forms of this
                     command the meanings of the parameters across these forms
                     are the same.  In cases where items are not present, they are
                     not part of the note being created, for example
                     the fact that in both command forms <parameter>run</parameter>
                     is optional means that if it is not provided the note
                     is not associated with any run.  If <parameter>images</parameter>
                     and <parameter>imageoffsets</parameter> are not present,
                     no images are considered to be embedded in the note
                     text.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>getNote <replaceable>id</replaceable></command></term>
               <listitem>
                   <para>
                     Returns a note instance command that wraps the note with
                     <parameter>id</parameter> as its primary key.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>listAllNotes</command></term>
               <listitem>
                   <para>
                     Returns a list containing run instance commands for all
                     notes.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <cmdsynopsis>
                     <command>
                        listNotesForRunId <replaceable>id</replaceable>
                     </command>
                     <command>
                        listNotesForRunNumber <replaceable>run-number</replaceable>
                     </command>
                     <command>
                        listNotesForRun <replaceable>run</replaceable>
                     </command>
                  </cmdsynopsis>
               </term>
               <listitem>
                   <para>
                     All of these subcommands return a list of the notes associated
                     with a run.  They differ only in how the run is specified.
                     In <command>listNotesForRunId</command>, <parameter>id</parameter>
                     specifies the desired run's primary key.  In
                     <command>listNotesForRunNumber</command>
                     <parameter>run-number</parameter> is the number of the
                     desired run. For <command>listNotesForRun</command>,
                     <parameter>run</parameter> is a run instance command for
                     the run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>listNonRunNotes</command></term>
               <listitem>
                   <para>
                     Returns a list of run instance command for the notes
                      in the database that do not have an associated run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>getNoteRun <replaceable>note</replaceable></command></term>
               <listitem>
                   <para>
                     Given a note instance command, <parameter>note</parameter>,
                     if the note is associated with a run, a run instance command
                     for the associated run is returned.  If there is no associated
                     run, then an empty string is returned instead.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>getNoteAuthor <replaceable>note</replaceable></command></term>
               <listitem>
                   <para>
                     Give a <parameter>note</parameter> instance command
                     extracts the author and returns it as a person instance
                     command.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>kvExists <replaceable>key</replaceable></command></term>
               <listitem>
                   <para>
                     If the database key value store contains an entry for
                     <parameter>key</parameter> a boolean true is returned,
                     otherwise a boolean false value is returned.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>kvGet <replaceable>key</replaceable></command></term>
               <listitem>
                   <para>
                     If <parameter>key</parameter> has an entry in the database
                     key value store, its value is returned.  If not,
                     an error is raised.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>kvSet <replaceable>new-or-existing-key value</replaceable></command></term>
               <listitem>
                   <para>
                     If <parameter>new-or-existing-key</parameter> exists
                     in the database, its value is modified to <parameter>value</parameter>.
                     If <parameter>new-or-existing-key</parameter> does not
                     exist, a new entry is created with that key and is given the
                     <parameter>value</parameter> as a value.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command><replaceable>new-key value</replaceable></command></term>
               <listitem>
                   <para>
                     Same as <command>kvSet</command>, however the
                     <parameter>new-key</parameter> must not yet exist in the
                     key value store.
                   </para>
                </listitem>
            </varlistentry>
           </variablelist>
          </refsect2>

    </refsect1>
</refentry>
<refentry id='tcl3.personinstance'>
   <refmeta>
      <refentrytitle id='tcl3.personinstance.title'>personinstance</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>personinstance</refname>
      <refpurpose>Encapsulate a logbook person for Tcl scripts</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require logbook
set logbook [logbook::logbook open <replaceable>logbookfile</replaceable>]
...
set person [$logbook getPerson <replaceable>1</replaceable>]
...

      </programlisting>
      <cmdsynopsis>
         <command>
$person destroy
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set lastName [$person lastName]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set firstName [$person firstName]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set salutation [$person salutation]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set id [$person id]
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Provides an object oriented encapsulation of the data for a logbook
            person.  The data are cached in the object rather than fetched
            on demand from the database.  Since people are  write once objects,
            in general this is not a problem for scripts.
          </para>
          <para>
            All person instance commands are command ensembles.  See
            <literal>SUBCOMMANDS</literal> for the subcommands each instance
            provides.  It is important to note that when a person instance is
            no longer needed by the script its <literal>destroy</literal>
            subcommand must be called to avoid memory leaks.
          </para>
    </refsect1>
    <refsect1>
      <title>SUBCOMMANDS</title>
      <variablelist>
         <varlistentry>
            <term><command>destroy</command></term>
            <listitem>
                <para>
                  Destroys the object command. This releases all storage associated
                  with the command and removes the command from the interpreter.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>lastName</command></term>
            <listitem>
                <para>
                  Returns the last name of the person encapsulated by this
                  command.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>firstName</command></term>
            <listitem>
                <para>
                  Returns the first name of the person encapsulated by this
                  command.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>salutation</command></term>
            <listitem>
                <para>
                  Returns the salutation of the person encapsulated by this
                  command.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>id</command></term>
            <listitem>
                <para>
                  Returns the primary key of the person encapsulated by this
                  command.  This is a unique integer assigned to each person.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<refentry id='tcl3.shiftinstance'>
   <refmeta>
      <refentrytitle id='tcl3.shiftinstance.title'>shiftinstance</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>shiftinstance</refname>
      <refpurpose>Encapsulate a shift for Tcl scripts</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require logbook
set book [logbook::logbook open <replaceable>mylogbook</replaceable>]
# e.g.
set shifts [$book listshifts]
set shift [lindex $shifts 0]
foreach s [lrange $shifts 1 end] {
   $s destroy
}
...
      </programlisting>
      <cmdsynopsis>
<command>$shift destroy</command>
      </cmdsynopsis>
      <cmdsynopsis>
<command>set name [$shift name]</command>
      </cmdsynopsis>
      <cmdsynopsis>
<command>set id   [$shift id]</command>
      </cmdsynopsis>
      <cmdsynopsis>
<command>set members [$shift members]</command>
      </cmdsynopsis>
      
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Shift instances are command ensembles that are generated
            by the logbookinstance objects (see
            <link linkend='tcl3.logbookinstance'
                  endterm='tcl3.logbookinstance.title' />).
            Shift instances encapsulate resources and must be destroyed
            using their <command>destroy</command> subcommand when they
            are no longer needed (see the <literal>SYNOPSIS</literal> for
            an example of that.).
          </para>
    </refsect1>
    <refsect1>
      <title>SUBCOMMANDS</title>
      <variablelist>
         <varlistentry>
            <term><command>destroy</command></term>
            <listitem>
                <para>
                  Destroys the shfit instance.  All resources held by the object
                  are relesed and the command is removed from the Tcl interpreter
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>name</command></term>
            <listitem>
                <para>
                  Returns the name of the encapsulated shift.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>id</command></term>
            <listitem>
                <para>
                  Returns the primary key assigned to the encapsulated shift.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>members</command></term>
            <listitem>
                <para>
                  Returns person instances for all of the members of the
                  encapsulated shift.  See
                  <link linkend='tcl3.personinstance'
                        endterm='tcl3.personinstance.title' /> for information
                  about person instances
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<refentry id='tcl3.runinstance'>
   <refmeta>
      <refentrytitle id='tcl3.runinstance.title'>runinstance</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>runinstance</refname>
      <refpurpose>Encapsulate logbook runs for Tcl scripts</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require logbook
set book [logbook::logbook open <replaceable>mylogbook</replaceable>]
set run [$book currentRun]
if {$run eq ""} {
   puts stderr "There is no currently active run"
}
...
      </programlisting>
      <cmdsynopsis>
         <command>
set key [$run  id]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set number [$run number]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set title [$run title]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set transitions [$run transitions]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
if {[$run isActive]} {
   puts "The run is active"
}
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
$run destroy
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Run instance objects are command ensembles that encapsulate
            a single run.  Instance objects don't get created directly by your
            script.  They are returned from some of the API subcommands in
            logbook instance as shown, for example, in the
            <literal>SYNOPSIS</literal> section.
          </para>
          <para>
            Run instance objects encapsulate resources and, when no longer
            needed, those resources must be released using the
            <command>destroy</command> subcommand.
          </para>
    </refsect1>
    <refsect1>
      <title>
         SUBCOMMANDS
      </title>
      <variablelist>
         <varlistentry>
            <term><command>destroy</command></term>
            <listitem>
                <para>
                  Destroys the instance and releases any resources it may have.
                  The instance command is removed from the interpreter.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>id</command></term>
            <listitem>
                <para>
                  Returns the primary key that was assigned to the encapsulated
                  run.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>number</command></term>
            <listitem>
                <para>
                  Returns the number of the run encapsulated by this object.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>title</command></term>
            <listitem>
                <para>
                  Returns the title of the run encapsulated by this object.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>transitions</command></term>
            <listitem>
                <para>
                  Returns a list of dicts that describes the transitions this
                  run has undergone.  Each run will have at least one transition
                  (the begin run is what creates the run).  The
                  keys and values in these dicts are described in
                  <literal>TRANSITION DICTS</literal> below.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>isActive</command></term>
            <listitem>
                <para>
                  Returns a boolean that is <literal>true</literal>
                  if this run is the active run.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <refsect2>
         <title>TRANSITION DICTS</title>
         <para>
            A transition dict is a Tcl dict that describes one transition.
            The <command>transitions</command> subcommand of the run instance
            command returns a list of these describing the transition history
            of the run.
         </para>
         <para>
            Each transition dict contains the following keys:
         </para>
         <variablelist>
            <varlistentry>
               <term><literal>id</literal></term>
               <listitem>
                   <para>
                     The primary key value assigned to the transition by the
                     database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>transition</term>
               <listitem>
                   <para>
                     An integer code that describes the transition.
                     See the table of values in
                     <link linkend='daq3.logbookrun.trantbl'
                           endterm='daq3.logbookrun.trantbl.title' />
                     in the reference page for <classname>LogBookRun</classname>
                     for possible values.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>transitionName</literal></term>
               <listitem>
                   <para>
                     Contains a text string that describes the transition.
                     See the table of values in
                     <link linkend='daq3.logbookrun.trantbl'
                           endterm='daq3.logbookrun.trantbl.title' />
                     in the reference page for <classname>LogBookRun</classname>
                     for possible values.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>transitionTime</literal></term>
               <listitem>
                   <para>
                     The <command>clock seconds</command> at which the
                     transition was logged. <command>clock format</command>
                     can be used to create a human readable date/time string
                     from this value.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>shift</literal></term>
               <listitem>
                   <para>
                     A shift instance that encapulates the shift that was on duty
                     when the transition was logged. See
                     <link linkend='tcl3.shiftinstance'
                           endterm='tcl3.shiftinstance.title' />
                     for information about shift instances.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
    </refsect1>
</refentry>
<refentry id='tcl3.noteinstance'>
   <refmeta>
      <refentrytitle id='tcl3.noteinstance.title'>noteinstance</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>noteinstance</refname>
      <refpurpose>Tcl encapsulation of a note</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
package require logbook
set book [logbook::logbook open <replaceable>logbook-file</replaceable>]
set notes [$book listAllNotes]
set note [lindex $notes 0]
      </synopsis>
      <cmdsynopsis>
         <command>
$note destroy
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set id [$note id]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set run [$note run]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set noteTime [clock seconds [$note timestamp]]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set rawContents [$note contents]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set embeddedImageList [$note images]
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
set renderableMarkdown [$note substituteImages]
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            A note instance is a Tcl command ensemble that provides access to
            all of the information contained in a note.  In general, as shown,
            you don't directly create a note ensemble but use one of the
            subcommands of a logbook instance to generate one or more instances.
            See
            <link linkend='tcl3.logbookinstance'
                  endterm='tcl3.logbookinstance.title' /> for subcommands that
            can generate notess
          </para>
          <para>
            Each note instance is a unique Tcl interpreter command and encapsulates
            specific resources.  As such, when no longer necessaryy, a note instance
            and its resources should be freed using its <literal>destroy</literal>
            subcommand.
          </para>
          <refsect2><title>SUBCOMMANDS</title>
          <variablelist>
            <varlistentry>
               <term>
                  <cmdsynopsis>
                     <command>
<replaceable>$note</replaceable> destroy
                     </command>
                  </cmdsynopsis>
               </term>
               <listitem>
                   <para>
                     This subcommand destroys the note instance. All resources
                     owned by the instance are destroyed.  Once the command
                     returns, the instance command is no longer a valid interpreter
                     command.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <cmdsynopsis>
                     <command>
set id [<replaceable>$note</replaceable> id]
                     </command>
                  </cmdsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the primary key associated with the note instance.
                     This is a unique integer assigned to a note when it is
                     created in the database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <cmdsynopsis>
                     <command>
set run [<replaceable>$note</replaceable> run]
                     </command>
                  </cmdsynopsis>
               </term>
               <listitem>
                   <para>
                     If the note has an associated run, this subcommand returns
                     that run encapsulated in a run instance.  See
                     <link linkend='tcl3.runinstance'
                           endterm='tcl3.runinstance.title' />
                     for more on run instances.
                     If ther eis no associated run, an empty string is returned.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <cmdsynopsis>
                     <command>
set noteTime [clock seconds [<replaceable>$note</replaceable> timestamp]]
                     </command>
                  </cmdsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns a clock timestamp at which the note was entered
                     in the database.  As shown, this timestamp is compatible
                     input for <command>clock format</command>, which allows
                     a time string to be produced.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <cmdsynopsis>
                     <command>
set rawContents [<replaceable>$note</replaceable> contents]
                     </command>
                  </cmdsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the raw contents of the note. In general; this is
                     not usable as a source of data for rendering the note unless
                     the note has no associated images.  See the
                     <command>substituteImages</command> subcommand if you want
                     note text as a source for markdown rendering.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <cmdsynopsis>
                     <command>
set embeddedImageList [<replaceable>$note</replaceable> images]
                     </command>
                  </cmdsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns a list of dicts. Each dict describes an image that's
                     sucked into the database to fulfil an image link in the
                     note.  See <literal>IMAGE DICTS</literal> below for
                     the contents of these dicts.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <cmdsynopsis>
                     <command>
set renderableMarkdown [<replaceable>$note</replaceable> substituteImages]
                     </command>
                  </cmdsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns markdown text that can be rendered by a markdown
                     processor.  This subcommand exports the images that are
                     are in the database, associated with this note to files.
                     It then
                     modifies all image references to point to the exported files.
                     The result is the modified note text. 
                   </para>
                   <para>
                     If the resulting text is passed to a markdown processor
                     (e.g. the Tcl <literal>Markdown</literal> package or
                     the <literal>pandoc</literal> filter), the image links will
                     be processed properly to either include or reference
                     the images.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          </refsect2>
          <refsect2>
            <title>IMAGE DICTS</title>
            <para>
               The <command>images</command> subcommand returns a list of
               dicts.  Each dict describes a single image that's referenced
               by the markdown note text and sucked into the database so that
               the log is fully portable as a single file.  The dicts have the
               following key/value pairs:
            </para>
            <variablelist>
               <varlistentry>
                  <term><literal>offset</literal></term>
                  <listitem>
                   <para>
                     The offset into the note text at which the <literal>!</literal>
                     that leads of an image reference begins.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>originalFilename</literal></term>
                  <listitem>
                      <para>
                        Contains the original file path of the image.  This
                        can be used to check the integrity of the image
                        list.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>imageLength</literal></term>
                  <listitem>
                      <para>
                        The number of bytes in the original image data.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>imageData</literal></term>
                  <listitem>
                      <para>
                        Binary object containing the image data.  This can be
                        written to file to re-create the image file.
                   </para>
                </listitem>
               </varlistentry>
            </variablelist>
          </refsect2>
    </refsect1>
</refentry>
<refentry id='tcl3.logbookadmin'>
   <refmeta>
      <refentrytitle id='tcl3.logbookadmin.title'>logbookadmin</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>logbookadmin</refname>
      <refpurpose>High level logbook interface</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
package require logbookadmin
      </synopsis>
      <cmdsynopsis>
         <command>
createLogBook <replaceable>path experiment spokesperson purpose ?select?</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
currentLogBook
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
setCurrentLogBook <replaceable>path</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
currentLogBookOrError
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
addPerson <replaceable>lastName firstName ?salutation?</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
listPeople
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
createShift <replaceable>name members</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
addMembersToShift <replaceable>shiftName members</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
removeMemberFromShift <replaceable>shiftName member</replaceable>      
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
setCurrentShift <replaceable>shiftName</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
listShiftMembers <replaceable>shiftName</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
listShifts
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
currentShift
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
beginRun <replaceable>number title ?remark?</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
endRun <replaceable>?remark?</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
pauseRun <replaceable>?remark?</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
resumeRun <replaceable>?remark?</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
emergencyEndRun ?remark?
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
listRuns
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
currentRun
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
findRun <replaceable>number</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
getNote <replaceable>id</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
getNoteText <replaceable>note</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
getNoteTitle ?note?
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
listAllNotes
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
listNotesForRun <replaceable>number</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
listNonRunNotes
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
kvExists <replaceable>key</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
kvGet <replaceable>key</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
kvSet <replaceable>key value</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
kvCreate <replaceable>key value</replaceable>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Using the low level logbook Tcl bindings can be painful because
            of the need to track the creation of instance commands and to ensure
            they get destroyed when on longer needed.  At the cost of making
            many more transient objects than otherwise required, the
            <literal>logbookadmin</literal> package provides a much easier
            to use interface to the logbook API.
          </para>
          <para>
            One of the features of <literal>logbookadmin</literal>, is that
            it adds the concept of a <firstterm>current logbook</firstterm> to
            the API.  The current logbook is the one that all commands
            will operate on, other than commands that can modify the
            current logbook.
          </para>
          <para>
            A feature of the <literal>logbookadmin</literal> API is that rather
            than returning command ensemble objects for complex objects,
            instead it returns dicts for them.  See
            <link linkend='tcl3.logbookadmin.dicts'
                  endterm='tcl3.logbookadmin.dicts.title'
                  />
            for a description of these dicts and their keys.
          </para>
    </refsect1>
    <refsect1>
      <title>COMMANDS</title>
      <para>
         The <literal>logbookadmin</literal> interface is procedural. The interface,
         therefore appears as simple commands.
      </para>
      <variablelist>
      <varlistentry>
         <term>
       <cmdsynopsis>
         <command>
createLogBook <replaceable>path experiment spokesperson purpose ?select?</replaceable>
         </command>
      </cmdsynopsis>     
         </term>
         <listitem>
             <para>
               Creates a new logbook with the <parameter>experiment</parameter>
               identifier, <parameter>spokesperson</parameter> and
               <parameter>purpose</parameter> requested in the new database
               file named <parameter>path</parameter>.  If <parameter>select</parameter>
               is provided and evaluates to a boolean true, the logbook
               is made current and all other operations that don't specify
               a logbook will operate on this logbook.
               If not suppled, <parameter>select</parameter> defaults to a
               boolean false value.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
currentLogBook
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               If a current logbook has been established, the path to it is
               returned. If there is no current logbook,
               an empty string is returned.  See, however
               <command>currentLogBookOrError</command> below.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
            <cmdsynopsis>
         <command>
setCurrentLogBook <replaceable>path</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Sets the current logbook to be <parameter>path</parameter>.
               Note that this does not validate the file as a logbook.
               That's done on the first access.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
    <cmdsynopsis>
         <command>
currentLogBookOrError
         </command>
      </cmdsynopsis>        
         </term>
         <listitem>
             <para>
               Returns the path to the current logbook.  If no logbook has been
               established as current, the command throws an error.
               This is most commonly used internally as well to obtain
               the logbook to operate on.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
addPerson <replaceable>lastName firstName ?salutation?</replaceable>
         </command>
      </cmdsynopsis>      
         </term>
         <listitem>
             <para>
               Adds a new person to the current logbook whose
               last name and first name are <parameter>lastName</parameter>
               and <parameter>firstName</parameter> respectively.  If
               the optional <parameter>salutation</parameter> is provided it is
               the salutation associated with the person.  If not, then
               the person is associated with a saluation that is an empty string.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
listPeople
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Returns a list containing person dictionaries.  Each entry describes
               one person in the logbook and altogether all people registered
                in the logbook are returned.  The dicts returned are descriged in
                <link linkend='tcl3.logbookadmin.dicts'
                      endterm='tcl3.logbookadmin.dicts.title' />
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
createShift <replaceable>name members</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Creates a new shift.  The shift will be named
               <parameter>name</parameter> and initially have
               <parameter>members</parameter> as its members.
               The <parameter>members</parameter> list is a list of person
               primary keys (ids). These can be gotten from person dicts.
               To create an empty shift simply supply
               <literal>[list]</literal> as the
               <parameter>members</parameter> parameter to provide an
               emptylist.
           </para>
            <para>
               Once created, <command>addMembersToShift</command> and
               <command>removeMemberFromShift</command> can be used to
               edit the shift membership.   Remember that shifts, not their
               members are associated with run state changes so the shift
               members should remain constant once data taking has begun.
            </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
addMembersToShift <replaceable>shiftName members</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Adds new
               <parameter>members</parameter>
               to the shift named <parameter>shiftName</parameter>.
               The <parameter>members</parameter> parameter is a list of
               person ids (primary keys).  The id of a person can be gotten
               from its dict. representation.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
removeMemberFromShift <replaceable>shiftName member</replaceable>      
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Removes the person whose primary key is<parameter>member</parameter>
               from the shift named <parameter>shiftName</parameter>.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
setCurrentShift <replaceable>shiftName</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               The logbook has the concept of a current shift.  This shift is
               associated with all run state transitions and is intended to
               describe who is on-duty during a segment of data taking.  This
               command sets the current shift to the shift named
               <parameter>shiftName</parameter>.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
listShiftMembers <replaceable>shiftName</replaceable>
         </command>
      </cmdsynopsis>      
         </term>
         <listitem>
             <para>
               Returns person dicts for all of the members of the shift
               named <parameter>shiftName</parameter>
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
listShifts
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Returns a list whose members are the names of all of the shifts
               defined to the logbook.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
currentShift
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               If a current shift has been established, returns the name of
               that shift.  If there is no current shift, an empty string is
               returned.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
beginRun <replaceable>number title ?remark?</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Creates a new run with  run number and title
               given by <parameter>number</parameter> and <parameter>title</parameter>
               respectively and logs a <literal>BEGIN</literal> state transition
               immediately.   If <parameter>remark</parameter> is provided
               it is a remark that is associated with the transition.
               Note that for this to work a current shift must also have been established
               and there cannot be another run with the same
               <parameter>number</parameter>.
           </para>
           <para>
            This command also establishes a current run. All future state transitions
            operate on that run until the run has ended at which point
            there is no longer a current run and state transitions other than
            those initiated by <command>beginRun</command> fail.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
endRun <replaceable>?remark?</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Ends the current run by logging an <literal>END</literal>
               state transition for it and indicating there is no current run.
               If provided <parameter>remark</parameter> is a textual remark that
               is associated with the transition.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
pauseRun <replaceable>?remark?</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Pauses the current run by logging a <literal>PAUSE</literal>
               transition for it.  The current run remains the current run.
               If provided <parameter>remark</parameter> is a textual comment
               associated with the transition.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
resumeRun <replaceable>?remark?</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Resumes a paused current run by logging a <literal>RESUME</literal>
               transition.  <parameter>remark</parameter>
               if provided is a text comment string that is associated with the
               transition
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
emergencyEndRun ?remark?
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Ends a run with an <literal>EMERGENCY_END</literal> transition.
               This differs from an <literal>END</literal> transition only in that
               it implies the end of the run was not handled normally.  The
               <parameter>remark</parameter>, if supplied is a text string
               associated with the transition.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
listRuns
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Returns a list.  Each list element is a run dict that describes
               one run.  All runs known to the logbook (including the current run
               if any) are represented by elements in the list.
           </para>
             <para>
               For information about the contents of each dict see:
               <link linkend='tcl3.logbookadmin.dicts'
                     endterm='tcl3.logbookadmin.dicts.title' />.
             </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
currentRun
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               If there is a current run (sometimes referred to as the active run),
               returns a run dict that describes that run. If there is no current
               run an empty dict is returned.  The command
               <command>dict size</command> applied to that dictionary value
               will be zero if the dictionary is not empty.  For example:
           </para>
            <informalexample>
               <programlisting>
set current [currentRun]
if {[dict size $current] != 0} {
   puts "There is a current run; number [dict get $current number]" 
} else {
   puts "There is not a currently active run."
}
               </programlisting>
            </informalexample>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
       <cmdsynopsis>
         <command>
findRun <replaceable>number</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               If there is a run in the logbook with run number
               <parameter>number</parameter> the run dict that describes it
               is returned.  If not an empty dict is returned.
               As with <command>currentRun</command>,
               <command>dict size</command> can be used to determine if the
               returned value is empty.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
getNote <replaceable>id</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Returns a note dict that describes the note with primary key
               <parameter>id</parameter>.  The contents of note dicts is described
                in
                <link linkend='tcl3.logbookadmin.dicts'
                      endterm='tcl3.logbookadmin.dicts.title' />.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
getNoteText <replaceable>note</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Given a note dict, returns the markdown text associated with the note
               whose note dict is <parameter>note</parameter>.
               This proc exports images associated with the note text and
               fixe up image references so that they will be handled correctly
               by markdown renderers.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
getNoteTitle ?note?
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Returns up to the first 20 characters of the first line of the
               note text given a note dict <parameter>note</parameter>.
               This is assumed to be a title string that can give a user some
               idea of what the note is about.
               If the first line of the note is over 20 characters long, the
               first 20 characters followed by the text <literal>...</literal>
               is returned.
             </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
listAllNotes
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Returns  list containing the note dicts for all notes in the
               logbook.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
listNotesForRun <replaceable>number</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Returns a list containing the note dicts for all notes associated
               with the run numbered <parameter>number</parameter>.  It is perfectly
               acceptable for this list to be empty, if there are no notes
               associated with the run.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
listNonRunNotes
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Returns a list of dicts for all notes that are not associated with
               any run.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
kvExists <replaceable>key</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Returns a boolean true if the key value store of the current
               logbook database contains a key with the string value
               <parameter>key</parameter>
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
kvGet <replaceable>key</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               If the key <parameter>key</parameter> exists in the key value store,
               the value associated with the key is returned.  Otherwise, the
               command raises an error.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
kvSet <replaceable>key value</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               If there is a key <parameter>key</parameter> in the key value
               store, the value associated with it is changed to
               <parameter>value</parameter>.  If not, a new key is created
               and has a value <parameter>value</parameter>.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>
      <cmdsynopsis>
         <command>
kvCreate <replaceable>key value</replaceable>
         </command>
      </cmdsynopsis>
         </term>
         <listitem>
             <para>
               Creates a new <parameter>key</parameter>, <parameter>value</parameter>
               pair in the logbook's key value store.  If <parameter>key</parameter>
               is already defined in the logbook database, an error is raised.
           </para>
        </listitem>
      </varlistentry>
      </variablelist>      
    </refsect1>
    <refsect1 id='tcl3.logbookadmin.dicts'>
      <title id='tcl3.logbookadmin.dicts.title'>DICTIONARIES</title>
      <para>
         Several object types in the logbook database have dict representations.
         This section describes the key/value pairs in each dict.
      </para>
      <formalpara>
         <title>Person Dict</title>
         <para>
            This dict contains key/value pairs that define a person in the logbook:\
            <variablelist>
               <varlistentry>
                  <term><literal>id</literal></term>
                  <listitem>
                      <para>
                        Contains the primary key of the person.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>lastName</literal></term>
                  <listitem>
                      <para>
                        Contains the person's last name.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>firstName</literal></term>
                  <listitem>
                      <para>
                        Contains the person's first name.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>saluation</literal></term>
                  <listitem>
                      <para>
                        Contains the person's salutation.  This string is
                        empty if there is no saulation associated with the
                        person.
                   </para>
                </listitem>
               </varlistentry>
            </variablelist>
         </para>
      </formalpara>
      <formalpara>
         <title>Run dict</title>
         <para>
            This dict describes the run metadata and its transitiongs. By nature
            each run has at least one transition.  The key value pairs are:
            <variablelist>
               <varlistentry>
                  <term><literal>number</literal></term>
                  <listitem>
                      <para>
                        The run's run number.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>title</literal></term>
                  <listitem>
                      <para>
                        The run's title string.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>isActive</literal></term>
                  <listitem>
                      <para>
                        Evaluates to a boolean that is true if the run is active.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>transitions</literal></term>
                  <listitem>
                      <para>
                        list of transition dicts.   Transition dicts
                        contain the following key/value pairs:
                        <variablelist>
                           <varlistentry>
                              <term><literal>transitionName</literal></term>
                              <listitem>
                                  <para>
                                    The transition type name string e.g.
                                    <literal>BEGIN</literal> is always the
                                    first transition in a run.
                               </para>
                            </listitem>
                           </varlistentry>
                           <varlistentry>
                              <term><literal>transitionTime</literal></term>
                              <listitem>
                                  <para>
                                    The <command>clock seconds</command> when
                                    the transition was logged.
                               </para>
                            </listitem>
                           </varlistentry>
                           <varlistentry>
                              <term><literal>transitionComment</literal></term>
                              <listitem>
                                  <para>
                                    The remark string associated with this state
                                    transition.
                               </para>
                            </listitem>
                           </varlistentry>
                        </variablelist>
                   </para>
                </listitem>
               </varlistentry>
            </variablelist>
         </para>
      </formalpara>
      <formalpara>
         <title>Note Dict</title>
         <para>
            Contains data associated with a note. Note that in order to make
            these dicts relatively light-weight, the text and images associated with
            a note cannot be directly accessed via this dict.  Its
            key value pairs are:
            <variablelist>
               <varlistentry>
                  <term><literal>id</literal></term>
                  <listitem>
                      <para>
                        The primary key assigned to the note.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>run</literal> (optional)</term>
                  <listitem>
                      <para>
                        If present the contents of this key are the run dict
                        that describes the run associated with this note.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>timestamp</literal></term>
                  <listitem>
                      <para>
                        The <command>clock seconds</command> at which the
                        note was loaded into the database.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>author</literal></term>
                  <listitem>
                      <para>
                        Contains the person dict that describes the note's
                        author.
                   </para>
                </listitem>
               </varlistentry>
            </variablelist>
         </para>
      </formalpara>
    </refsect1>
    <refsect1>
      <title>FILES</title>
      <variablelist>
         <varlistentry>
            <term><filename>~/.nscl-logbook-current</filename></term>
            <listitem>
                <para>
                  Contains the name of the current logbook.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><filename>~/.nscl-logbook</filename></term>
            <listitem>
                <para>
                  Directory into which the image files are exported.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<refentry id='tcl3.logbookbundle'>
   <refmeta>
      <refentrytitle id='tcl3.logbookbundle.title'>logbookbundle</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>logbookbundle</refname>
      <refpurpose>Automate logging transitions in ReadoutGui</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
package require logbookbundle
      </synopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Loading this package in the readout gui (e.g. through
            <filename>ReadoutCallouts.tcl</filename>) makes the GUI automatically
            log state transitions when recording is enabled in the current logbook.
          </para>
    </refsect1>
</refentry>
<refentry id='tcl3.lg_noteutilities'>
   <refmeta>
      <refentrytitle id='tcl3.lg_noteutilities.title'>lg_noteutilities</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_noteutilities</refname>
      <refpurpose>Utilties for dealing with notes</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
package require lg_noteutilities
      </synopsis>
      <cmdsynopsis>
         <command>
makeNoteImageList <replaceable>text</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
validateImageFiles <replaceable>images</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
makeNoteMarkdown <replaceable>noteDict</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
_noteToFd <replaceable>id fd</replaceable>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This package provides some utilities that support high level note
            processing.  The package was written to support the note composition
            software, howver it may be used generally as well.
          </para>
    </refsect1>
    <refsect1>
      <title>COMMANDS</title>
      <variablelist>
         <varlistentry>
            <term>
         <cmdsynopsis>
         <command>
makeNoteImageList <replaceable>text</replaceable>
         </command>
      </cmdsynopsis>
            </term>
            <listitem>
                <para>
                  Creating a note requries that the images referenced by the
                  notes be included in the database to support later rendering.
                  <command>makeNoteImageList</command> takes the raw text of
                  a note, locates image references and creates a list of pairs,
                  one for each image reference.  The pairs are the the
                  byte offset at
                  which the image reference occurs in the text and the  filename
                  of the image itself.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
      <cmdsynopsis>
         <command>
validateImageFiles <replaceable>images</replaceable>
         </command>
      </cmdsynopsis>         
            </term>
            <listitem>
                <para>
                  Given a list of pairs such as that produced by
                  <command>makeNoteImageList</command>, ensures that each of
                  the filenames in the image list exists and is readable.  Returns
                  a list of strings, where each string is an unreadable image file.
                  For a note to be imported, all image file references must
                  point to files that exist and are readable so they can be imported
                  into the database.
               </para>
                <para>
                  Note that no effort is made to ensure that the files are, in fact,
                  valid image files. If a reference to an image file is invalid,
                  the markdown generated will be invalid but some renderers,
                  such as the PDF renderer may not be able to create output.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
       <cmdsynopsis>
         <command>
makeNoteMarkdown <replaceable>noteDict</replaceable>
         </command>
      </cmdsynopsis>  
            </term>
            <listitem>
                <para>
                  When the logbook software generates the note for rendering,
                  in addition to exporting images and fixing up their references
                  it prepends a table of metatdata about the note, including
                  the author's name, when the note wsas written and, if the
                  note is associated with a run, the run number, title and
                  when the run started and, if the run ended, when the run
                  ended.
               </para>
                <para>
                  This command takes a note dict and performs the processing
                  described above.  The resulting markdown texts
                  is the return value of this command.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
         <cmdsynopsis>
         <command>
_noteToFd <replaceable>id fd</replaceable>
         </command>
      </cmdsynopsis>
            </term>
            <listitem>
                <para>
                  Given a note who's primary key is <parameter>id</parameter>,
                  and an open file descriptor <parameter>fd</parameter>,
                  Creates the full markdown text
                  (what <command>makeNoteMarkdown</command>) creates, and outputs
                  it to <parameter>fd</parameter>.   This is used internally to
                  the logbook browser software to e.g. pipe fully formed
                  markdown to the <command>pandoc</command> markdown processor.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<refentry id='tcl3.lg_utilities'>
   <refmeta>
      <refentrytitle id='tcl3.lg_utilities.title'>lg_utilities</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>lg_utilities</refname>
      <refpurpose>Utilties for Tcl logbook procssessing.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
package require lg_utiltities
      </synopsis>
      <cmdsynopsis>
         <command>
set ::timezone <replaceable>timezone-string</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
reportPeople <replaceable>people-dict-list</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
shiftExists <replaceable>shiftName</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
duplicateShiftMessage <replaceable>shiftName</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
peopleToids <replaceable>person-dict-list</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
_runToFd <replaceable>number fd</replaceable>
         </command>
      </cmdsynopsis>
      <cmdsynopsis>
         <command>
printall <replaceable>fd</replaceable>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This package provides utility commands that are used in the
            <command>lg_xxxx</command> logbook support commands but are also
            useable by any Tcl script that access the logbook.
          </para>
          <para>
            One note that there is a global variable in this package:
            <varname>timezone</varname>.  This variable contains the
            timezone string for the timezone in which the logbook was filled in.
            It is used in time formatting.  It defaults to
            <literal>:America/Detroit</literal> which is the timezone for
            FRIB/NSCL (East Lansing, Michgigan).  Which is eastern time with
            daylight saving time adjustments.  If your script is processing
            a logbook created at a different location, you can set this
            variable to get times formatted for that timezone.  Note as well
            that future logbook versions may write the timezone string into the
            logbook's KV store and use that for time formatting.
          </para>
    </refsect1>
    <refsect1>
      <title>COMMANDS</title>
      <variablelist>
         <varlistentry>
            <term>
         <cmdsynopsis>
         <command>
reportPeople <replaceable>people-dict-list</replaceable>
         </command>
      </cmdsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a string that reports information about the people
                  provided in <parameter>people-dict-list</parameter>.  This
                  argument is a list whose elements are people dicts.
                  See
                  <link linkend='tcl3.logbookadmin'
                        endterm='tcl3.logbookadmin.title' />
                  for information about people dicts and for commands that
                  can return them.
               </para>
                <para>
                  The string has the same form as the report output by
                  <command>$DAQBIN/lg_lspeople</command>.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
         <cmdsynopsis>
         <command>
shiftExists <replaceable>shiftName</replaceable>
         </command>
      </cmdsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a boolean that evaluates to true if the
                  <parameter>shiftName</parameter> names a shift that is known
                  to the logbook.  If not returns a false value. 
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
         <cmdsynopsis>
         <command>
duplicateShiftMessage <replaceable>shiftName</replaceable>
         </command>
      </cmdsynopsis>
            </term>
            <listitem>
                <para>
                  Produces a string containing an error message appropriate
                  to not allowing a duplicate shift to be created. The
                  message is the same as that produced by
                  <command>$DAQBIN/lg_mkshift</command> given then name of an
                  existing shift;  It indicates the shift exists and provides
                  a report of its members.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
         <cmdsynopsis>
         <command>
peopleToids <replaceable>person-dict-list</replaceable>
         </command>
      </cmdsynopsis>
            </term>
            <listitem>
                <para>
                  Converts a list of person dicts,
                  <parameter>person-dict-list</parameter>, into a list of the
                  primary keys of those people. 
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
      <cmdsynopsis>
         <command>
      
_runToFd <replaceable>number fd</replaceable>
         </command>
      </cmdsynopsis>
            </term>
            <listitem>
                <para>
                  Creates the standardized markdown for a run numbered
                  <parameter>number</parameter> and writes it to the file
                  descriptor <parameter>fd</parameter>.  The output consist of
                  a header describing the run and then a chronological list of
                  events that occured in the run.  This list includes
                  both transitions and notes associated with the run.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
      <cmdsynopsis>
         <command>
printall <replaceable>fd</replaceable>
         </command>
      </cmdsynopsis>   
            </term>
            <listitem>
                <para>
                  Produces the markdown for the entire logbook writing it to
                  the file descriptor open on <parameter>fd</parameter>.
                  First all runs are written using <command>_runToFd</command>,
                  next all notes not associated with a run are written
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<!-- /manpage -->
<!-- manpage 3python -->

<refentry id='py3.logbook'>
   <refmeta>
      <refentrytitle id='py3.logbook.title'>LogBook</refentrytitle>
      <manvolnum>3python</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>LogBook</refname>
      <refpurpose>Python bindings to LogBook Api.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
PYTHONPATH=$DAQROOT/pythonLibs/nscldaq python3

import LogBook.LogBook as LogBook         
      </synopsis>
      <programlisting>
try:
   ...
except LogBook.error:
   ...
   
      </programlisting>
      <programlisting>
         
LogBook.create(<replaceable>filename, expid, spokesperson, purpose</replaceable>)
book = LogBook.LogBook(filename)

      </programlisting>
      <programlisting>
# People interface      

person = book.add_person(lastname, firstname[, salutation])
people = book.find_people([whereclause])
people = book.list_people()
person = book.get_person(id)
      </programlisting>
      <programlisting>

# Shift interface

shift = book.get_shift(id)
shift = book.create_shift(name[, people])
shift = book.find_shift(name)
shift = book.current_shift()

      </programlisting>
      <programlisting>
         
# Run interface

run  = book.current_run()
runs = book.list_runs()
run  = book.find_run(number)
run  = book.begin_run(number, title[, comment])

      </programlisting>
      <programlisting>

# Note interface:

note = get_note(id)
notes = list_all_notes();
notes = list_all_notes_for_run_number(number)
notes = list_all_notes_for_run_id(id)
notes = list_all_notes_for_run(run)
notes = list_nonrun_notes()
run   = get_note_run(note)

note = create_note(author, text [,images=filenames, offsets=offsets][, run])

      </programlisting>
      <programlisting>
# Key Value store interface

if (kv_exists(key)):
    # It exists
         ...
value = kv_get(key)
kv_set(key, value)
kv_create(newkey, value)

      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This is the top level reference page for the python bindings to the
            logbook API.  In addition to a static method to create new logbooks,
            and an exception type (<classname>LogBook.error</classname>),
            the API allows construction of a <classname>LogBook.Logbook</classname>
            object on an existing logbook filename.
            Once constructed, that object
            provides several API subsections, each of these will be given its
            own section.
          </para>
          <para>
            Each of the API subsections may produce objects of other types
            that can be manipulated to gain further detailed information about
            the logbook or provide additional information to the logbook.
            These will have their own reference pages (they are called out in the
            text as well as appearing in <literal>SEE ALSO</literal>)
          </para>
          
    </refsect1>
    <refsect1>
      <title>PEOPLE API section</title>
      <para>
         This section allows you to create and retrieve people from the logbook.
         A persin is encapsulated in a <classname>LogBook.Person</classname>
         object.   This object is described in the reference page:
         <link linkend='py3.person' endterm='py3.person.title' />.
      </para>
      <para>
         Here are the methods that make up the People API section:
      </para>
      <variablelist>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBook.Person</type>
                  <methodname>add_person</methodname>
                  <methodparam>
                      <type>string</type><parameter>lastname</parameter>
                  </methodparam>
                  <methodparam>
                      <type>string</type><parameter>firstname</parameter>
                  </methodparam>
                  <methodparam>
                     <modifier>(optional)</modifier>
                      <type>string</type><parameter>salutation</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Creates a new logbook person and returns an object that
                  encapsulates it.  The parameters can be ordered or specified
                  via keywords whose keys are the parameter names above.
                  The <parameter>lastname</parameter> and
                  <parameter>firstname</parameter> parameters are mandatory and
                  specify the person's last name and first name respectively.
                  The <parameter>salutation</parameter> parameter is optional.
                  If supplied a non-empty salutation will be provided for the
                  person (e.g. <literal>'Mr.'</literal>) If not, on retrieval,
                  this person will have an empty salutation.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>tuple of LogBook.Person</type>
                  <methodname>find_people</methodname>
                  <methodparam>
                     <modifier>optional</modifier>
                      <type>string</type><parameter>whereclause</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Finds people that match the optional <parameter>whereclause</parameter>.
                  The result is a tuple containing <classname>LogBook.Person</classname>
                  objects that encapsulate people that satisfy the
                  <parameter>whereclause</parameter>.
                  <parameter>whereclause</parameter> is optional.  If omitted,
                  this method is functionally equivalent to
                  <methodname>list_people</methodname> below.
                  If provided, <parameter>whereclause</parameter> must be a
                  valid SQLite3 WHERE clause (without the <literal>WHERE</literal>)
                  clause that will be used to filter out the matching people.
               </para>
               <para>
                  For more information about the strings that can be used
                  for <parameter>whereclause</parameter>, refer to the
                  Sqlite3 reference page for expressions (
                  <ulink url='https://sqlite.org/syntax/expr.html' />
                  ).  
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>tuple of LogBook.Person</type>
                  <methodname>list_people</methodname>
                  <void />
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a tuple that contains all people in the logbook.
                  This is functionally equivalent to not supplying a
                  <parameter>whereclause</parameter> to
                  <methodname>find_people</methodname>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBook.Person</type>
                  <methodname>get_person()</methodname>
                  <methodparam>
                      <type>number</type><parameter>id</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the person with the primary key <parameter>id</parameter>.
                  This parameter must be treatable as an integer.
               </para>
            </listitem>
         </varlistentry>      
      </variablelist>
    </refsect1>
    <refsect1>
      <title>SHIFT API Section</title>
      <para>
         The Shift part of the API manipulates collections of people that
         can be on-duty while data taking is in progress.  Shifts, returned by
         this part of the API are encapsulated in <classname>LogBook.Shift</classname>
         objects.  These are described in the
         <link linkend='py3.shift' endterm='py3.shift.title' /> reference page.
      </para>
      <para>
         These methods make up the Shift API section:
      </para>
      <variablelist>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBook.Shift</type>
                  <methodname>get_shift</methodname>
                  <methodparam>
                      <type>number</type><parameter>id</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a <classname>LogBook.Shift</classname> object that
                  encapsulates the person with the primary key
                  <parameter>id</parameter>.  This parameter must be convertible
                  to an integer.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBook.Shift</type>
                  <methodname>create_shift</methodname>
                  <methodparam>
                      <type>string</type><parameter>name</parameter>
                  </methodparam>
                  <methodparam>
                     <modifier>(optional)</modifier>
                      <type>iterable of LogBook.Person</type><parameter>people</parameter>
                  </methodparam>
               </methodsynopsis>

            </term>
            <listitem>
               <para>
                  Creates a shift and optionally stocks it with people.
                  The <parameter>name</parameter> parameter is mandatory and
                  is the new name to give to the shift.  Shift names must be
                  unique.  The optional <parameter>people</parameter>
                  parameter can be specified either positionally or by keyword
                  (<literal>people</literal>).  If provided it must be an
                  iterable Python object whose members are all
                  <classname>LogBook.Person</classname> people who will initially
                  be members of the shift.  Note that the
                  <classname>LogBook.Shift</classname> object that's returned
                  also provides methods that allow you to manipulate membership.
               </para>
               <para>
                  A caution here that shift membership should not change
                  once data taking starts.  This is because run state translations
                  get associated with a shift.  Therefore changing the membership of
                  a shift will change the logbook database's understanding
                  of who was on-duty at the time of the shift change.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBook.Shift</type>
                  <methodname>find_shift</methodname>
                  <methodparam>
                      <type>string</type><parameter>name</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a <classname>LogBook.Shift</classname> object that
                  encapsulates the shift that is named <parameter>name</parameter>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBook.Shift</type>
                  <methodname>current_shift</methodname>
                  <void />
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  The logbook has the concept of a <firstterm>current shift</firstterm>.
                  This has meaning during data taking.  When run transitions
                  are logged, the current shift is associated with that transition.
                  This logs who was on duty and responsible for that transition.
                  If no current shift has been established; <literal>None</literal>
                  is returned.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>RUN API Section</title>
      <para>
         Runs are segments of data taking.  They are encapsulated with
         <classname>LogBook.Run</classname> objects. For more on those, see
         <link linkend='py3.run' endterm='py3.run.title' />.
         This part of the API provides the ability to create new runs, by beginning
         data taking, and retreive existing runs.  One of the most important
         bits of metadata associated with a run is its run number. Among recorded
         runs, this is a unique integer.  
      </para>
      <para>
         One other  key concept in the run API is that, natrually, data taking
         can only be active in one run at a time.  The logbook API enforces this
         by refusing to allow a run be created while another run is active.
         The active run, if there is one is called the
         <emphasis>current run</emphasis>.
      </para>
      <para>
         Here are the methods that make up the run api:
      </para>
      <variablelist>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBook.Run</type>
                  <methodname>current_run</methodname>
                  <void />
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the current run if there is one or
                  <literal>None</literal> if no data taking is in progress
                  (according to the logbook).
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>tuple of LogBook.Run</type>
                  <methodname>list_runs</methodname>
                  <void />
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returs a tuple of <classname>LogBook.Run</classname>
                  that contains all of the runs in the logbook.  Note that the
                  current run, if there is one, is included in the tuple.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBook.Run</type>
                  <methodname>find_run</methodname>
                  <methodparam>
                      <type>Number</type><parameter>number</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the <classname>LogBook.Run</classname>
                  that has the run number <parameter>number</parameter>.
                  If there is no match, <literal>None</literal> is returned.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBook.Run</type>
                  <methodname>begin_run </methodname>
                  <methodparam>
                      <type>Number</type><parameter>number</parameter>
                  </methodparam>
                  <methodparam>
                      <type>String</type><parameter>title</parameter>
                  </methodparam>
                  <methodparam>
                     <modifier>optional</modifier>
                      <type>String</type><parameter>comment</parameter>
                  </methodparam>
               </methodsynopsis>

            </term>
            <listitem>
                <para>
                  Creates a new run logging a <literal>BEGIN</literal>
                  transition for it.  The <parameter>number</parameter>
                  and <parameter>title</parameter> specify the run number
                  and title respectively and are mandatory.  The
                  optional parameter <parameter>comment</parameter>
                  provides a comment that's associated with the begin
                  state transition.  All parameters can be either positional
                  or be keyworded with the name of the parameter as the keyword
                  (e.g. <literal>number=1</literal>).
               </para>
            </listitem>
         </varlistentry>      
      </variablelist>
    </refsect1>
    <refsect1>
      <title>
         NOTE API section
      </title>
      <para>
         Notes are documentation about the experiment that can be entered at
         any time.  Notes can be associated with runs or free standing.  A note
         has, minimally an author and a time at which it was created.  Notes
         can be rich text using the Markdown formatting language.
         See <ulink url='https://https://www.markdownguide.org/' /> for information
         about Markdown.
      </para>
      <para>
         Markdown supports the inclusion of images via image links.  The logbook
         database, however is all inclusive.  Therefore, the images that
         are referred to in notes are pulled into the database where they can be
         recovered when the note is later rendered.
      </para>
      <para>
         Notes are incapsulated in <classname>LogBook.Note</classname> objects.
         These objects are described in
         <link linkend='py3.note' endterm='py3.note.title' />.
      </para>
      <para>
         Here are the methods in the note API
      </para>
      <variablelist>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBook.Note</type>
                  <methodname>get_note</methodname>
                  <methodparam>
                      <type>Number</type><parameter>id</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a <classname>LogBook.Note</classname> that
                  encapsulates the note that has the primary key
                  <parameter>id</parameter>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>Tuple of LogBook.Note</type>
                  <methodname>list_all_notes</methodname>
                  <void />
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a tuple that contains all of the notes
                  known to the logbook.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>Tuple of LogBook.Note</type>
                  <methodname>list_all_notes_for_run_number</methodname>
                  <methodparam>
                      <type>Number</type><parameter>number</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a tuple of <classname>LogBook.Note</classname>
                  objects that represent all of the notes that have been
                  associated with the run numbered <parameter>number</parameter>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>Tuple of LogBook.Note</type>
                  <methodname>list_all_notes_for_run_id</methodname>
                  <methodparam>
                      <type>Number</type><parameter>id</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a tuple of <classname>LogBook.Note</classname>
                  objects that represent all of the notes that have
                  been associated with the run whose primary key is
                  <parameter>id</parameter>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>Tuple of LogBook.Note</type>
                  <methodname>list_all_notes_for_run</methodname>
                  <methodparam>
                      <type>LogBook.Run</type><parameter>run</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a tuple of <classname>LogBook.Note</classname>
                  objects that represent all of the notes that have
                  been associated with the <classname>LogBook.Run</classname>
                  object <parameter>run</parameter>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>Tuple of LogBook.Note</type>
                  <methodname>list_nonrun_notes</methodname>
                  <void />
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns a tuple of <classname>LogBook.Note</classname>
                  that represent the notes that are not associated with
                  any run.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBook.Run</type>
                  <methodname>get_note_run</methodname>
                  <methodparam>
                      <type>LogBook.Note</type><parameter>note</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  If the <parameter>note</parameter> is associated with a run,
                  this method returns a <classname>LogBook.Run</classname>
                  encapsulating that run.  If not, <literal>None</literal>
                  is returned.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>LogBook.Note</type>
                  <methodname>create_note</methodname>
                  <methodparam>
                      <type>LogBook.Person</type><parameter>author</parameter>
                  </methodparam>
                  <methodparam>
                      <type>String</type><parameter>text</parameter>
                  </methodparam>
                  <methodparam>
                     <modifier>optional</modifier>
                      <type>Iterable of Strings</type><parameter>images</parameter>
                  </methodparam>
                  <methodparam>
                     <modifier>optional</modifier>
                      <type>Iterable of Numbers</type><parameter>offsets</parameter>
                  </methodparam>
                  <methodparam>
                     <modifier>(optional)</modifier>
                      <type>LogBook.Run</type><parameter>run</parameter>
                  </methodparam>
               </methodsynopsis>

            </term>
            <listitem>
                <para>
                  Creates a new note in the logbook and returns a
                  <classname>LogBook.Note</classname> that encapsulates it.
                  Two mandatory parameters; <parameter>author</parameter>
                  and <parameter>text</parameter> provide the
                  <classname>LogBook.Person</classname> that is the note author
                  and note text respectively.  If the markdown in
                  <parameter>text</parameter> contains image references,
                  the <parameter>images</parameter> and <parameter>offsets</parameter>
                  must provide the filenames of those images and byte offsets
                  into the <parameter>text</parameter> at which the link to each
                  image occurs.   If the note is associated with a run,
                  <parameter>run</parameter> is the
                  <classname>LogBook.Run</classname> that represents the associated
                  run.  
               </para>
               <para>
                  The parameters can be positional as shown or keywords where
                  the parameter names above are the keywords you can use e.g.
               </para>
               <informalexample>
                  <programlisting>
...
author = book.find_people('lastname = "Fox"')[0]
run = book.current_run()
note = book.create_note(author, "This a note for the current run", run=run)

                  </programlisting>
               </informalexample>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>KEY VALUE STORE API Section</title>
      <para>
         The key value store provides the ability to store keyword value pairs that
         can be retrieved by keyword. Here are the methods that make up this section
         of the API.
      </para>
      <variablelist>
         <varlistentry>
            <term>
            <methodsynopsis>
               <type>Boolean</type>
               <methodname>kv_exists</methodname>
               <methodparam>
                   <type>String</type><parameter>key</parameter>
               </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns <literal>True</literal> if there is an entry in
                  the key value store with the key <parameter>key</parameter>.
                  If not, returns <literal>False</literal>.
                </para>
             </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>String</type>
                  <methodname>kv_get</methodname>
                  <methodparam>
                      <type>String</type><parameter>key</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Returns the value of the key <parameter>key</parameter>
                  from the key value store.  If there is no matching
                  <parameter>key</parameter>, raises
                  <classname>LogBook.error</classname>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>None</type>
                  <methodname>kv_set</methodname>
                  <methodparam>
                      <type>String</type><parameter>key</parameter>
                  </methodparam>
                  <methodparam>
                      <type>String</type><parameter>value</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  If <parameter>key</parameter> exists, its value is
                  overridden and set to <parameter>value</parameter>.  If
                  <parameter>key</parameter> does not exist, it is created with
                  a value of <parameter>value</parameter>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>None</type>
                  <methodname>kv_create</methodname>
                  <methodparam>
                      <type>String</type><parameter>newkey</parameter>
                  </methodparam>
                  <methodparam>
                      <type>String</type><parameter>value</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  If <parameter>newkey</parameter> does not exist it is created
                  with <parameter>value</parameter> as its value.  If it does
                  exist, <classname>LogBook.error</classname> is raised.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      
    </refsect1>
    <refsect1>
      <title>SEE ALSO</title>
      <simplelist>
         <member><link linkend='py3.person' endterm='py3.person.title' /></member>
         <member><link linkend='py3.shift' endterm='py3.shift.title' /></member>
         <member><link linkend='py3.run' endterm='py3.run.title' /></member>
         <member><link linkend='py3.note' endterm='py3.note.title' /></member>
      </simplelist>
    </refsect1>
</refentry>
<refentry id='py3.person'>
   <refmeta>
      <refentrytitle id='py3.person.title'>LogBook.Person</refentrytitle>
      <manvolnum>3python</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>LogBook.Person</refname>
      <refpurpose>Python class encapsulating Log Book people.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
PYTHONPATH=$DAQROOT/pythonLibs/nscldaq python3

import LogBook.LogBook as LogBook
...
book = LogBook.LogBook(<replaceable>'logbookfile.log'</replaceable>)
person = book.get_person(1)
      </synopsis>
      <programlisting>
id    = person.id
last  = person.lastname
first = person.firstname
sal   = person.salutation


      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            <classname>LogBook.Person</classname> is a python class that wraps
            instances of persons in the logbook database
            <link linkend='py3.logbook' endterm='py3.logbook.title' />
            provides methods that produce <classname>LogBook.Person</classname>
            objects, or tuples of them.
          </para>
          <para>
            A <classname>LogBook.Person</classname> object should be thought of
            as a container with several read-only attributes. These are:
          </para>
          <variablelist>
            <varlistentry>
               <term><type>Integer</type><structfield> id</structfield></term>
               <listitem>
                   <para>
                     The primary key associated with that person.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>String</type><structfield> lastname</structfield></term>
               <listitem>
                   <para>
                     The last name of the encapsulated person.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>string</type><structfield> firstname</structfield></term>
               <listitem>
                   <para>
                     The given (first) name of the encapsulated person.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>String</type><structfield> salutation</structfield></term>
               <listitem>
                   <para>
                     The salutation for the encapsulated person.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
    </refsect1>
</refentry>
<refentry id='py3.shift'>
   <refmeta>
      <refentrytitle id='py3.shift.title'>LogBook.Shift</refentrytitle>
      <manvolnum>3python</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>LogBook.Shift</refname>
      <refpurpose>Encapsulate logbook shifts for python</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
PYTHONPATH=$DAQROOT/pythonLibs/nscldaq python3

import LogBook.LogBook as LogBook
...
book = LogBook.LogBook(<replaceable>'logbookfile.log'</replaceable>)
person = book.get_person(1)
shift = book.find_shift('Owl')

      </synopsis>
      <programlisting>
         
id      = shift.id
name    = shift.name
members = shift.members

      </programlisting>
      <programlisting>
         
shift.add_member(person)
shift.remove_member(person)
shift.set_current()
         
      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This class provides a wrapping for LogBook shifts.  A shift is a
            collection of people.   Note that shifts are not directly comparable
            via <literal>=</literal>.  If, however, their <structfield>id</structfield>
            attributes are the sam, they wrap the same shift.
          </para>
    </refsect1>
    <refsect1>
      <title>ATTRIBUTES</title>
      <para>
         <classname>LogBook.Shift</classname> objects have readonly attributes:
      </para>
      <variablelist>
         <varlistentry>
            <term><type>Integer</type><structfield> id</structfield></term>
            <listitem>
                <para>
                  The primary  key associated with the shift.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>String</type><structfield> name</structfield></term>
            <listitem>
                <para>
                  The name of the shift.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>Tuple of LogBook.Person</type><structfield> members</structfield></term>
            <listitem>
                <para>
                  Tuple of <classname>LogBook.Person</classname> objects that
                  represent the members of the shift.
                  <classname>LogBook.Person</classname> is described in
                  <link linkend='py3.person' endterm='py3.person.title' />
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>METHODS</title>
      <variablelist>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>None</type>
                  <methodname>add_member</methodname>
                  <methodparam>
                      <type>LogBook.Person</type><parameter>person</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Adds <parameter>person</parameter> to the shift.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>None</type>
                  <methodname>remove_member</methodname>
                  <methodparam>
                      <type>LogBook.Person</type><parameter>person</parameter>
                  </methodparam>
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Removes <parameter>person</parameter> from the shift.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <methodsynopsis>
                  <type>None</type>
                  <methodname>set_current</methodname>
                  <void />
               </methodsynopsis>
            </term>
            <listitem>
                <para>
                  Sets the shift to be the current shift. Run state changes
                  logged after this will be logged as having occured when this
                  shift was on-duty.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<refentry id='py3.run'>
   <refmeta>
      <refentrytitle id='py3.run.title'>LogBook.Run</refentrytitle>
      <manvolnum>3python</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>LogBook.Run</refname>
      <refname>LogBook.Transition</refname>
      <refpurpose>Encapsulate runs and their transitions for Python</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
PYTHONPATH=$DAQROOT/pythonLibs/nscldaq python3

import LogBook.LogBook as LogBook
...
book = LogBook.LogBook(<replaceable>'logbookfile.log'</replaceable>)
run  = LogBook.find_run(1)
      </synopsis>
      <programlisting>
id     = run.id
number = run.number
title  = run.title

      </programlisting>
      <programlisting>
n   = run.transition_count()
tnum = 0
begin_run = run.get_transition(tnum)
if run.is_current():
     #  Run is the current/active run
     
last_transitionid = run.last_transitionid()
last_text         = run.last_transition()

if run.is_active():
      # Run is still active.

run.end([remark])
run.pause([remark])
run.resume([remark])
run.emergency_end([remark])

      </programlisting>
      <programlisting>

id             = transition.id
transitionid   = transition.transition
transitiontext = transition.transition_name
timestamp      = transition.time
comment        = transition.comment
shift          = transition.shift

      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This page describes two classes:
            <classname>LogBook.Run</classname> which encapsulates a run and
            the associated <classname>LogBook.Transition</classname> which
            encapsulates a single run state transition.
          </para>
    </refsect1>
    <refsect1>
      <title>LogBook.Run</title>
      <para>
         This section desccribes the <classname>LogBook.Run</classname>
         class which provides readonly attributes
         and methods to access and modify runs.
      </para>
      <refsect2>
         <title>Attributes</title>
         <variablelist>
            <varlistentry>
               <term><type>Integer</type><structfield> id</structfield></term>
               <listitem>
                   <para>
                     Contains the run's primary key.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>Integer</type><structfield> number</structfield></term>
               <listitem>
                   <para>
                     Provides the run number.  This differs from the primary key
                     because some experimenters assign skip run numbers for
                     organizational purposes.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>String</type><structfield> title</structfield></term>
               <listitem>
                   <para>
                     Provides the run title string.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
      <refsect2>
         <title>METHODS</title>
         <variablelist>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>Integer</type>
                     <methodname>transition_count</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the number of transitions the run has undergone.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBook.Transition</type>
                     <methodname>get_transition</methodname>
                     <methodparam>
                         <type>Number</type><parameter>n</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns a <classname>LogBook.Transition</classname>
                     object that encapsulates transition number
                     <parameter>n</parameter> numbered from zero.
                     If <parameter>n</parameter> is out of range
                     <classname>LogBook.error</classname> is raised.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>Boolean</type>
                     <methodname>is_current</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns <literal>True</literal> if this object is the
                     current run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>Boolean</type>
                     <methodname>is_active</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Given the constraints enforced by the database
                     API, this is equivalent to <methodname>is_current</methodname>
                     because the API enforces that there only be one active
                     run at a time and that it is the current one.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>Integer</type>
                     <methodname>last_transitionid</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the numerical value that specifies the last
                     transition.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>String</type>
                     <methodname>last_transition</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the transition name string of the last transition.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBook.Run</type>
                     <methodname>end</methodname>
                     <methodparam>
                        <modifier>optional</modifier>
                         <type>String</type><parameter>remark</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Logs an end run for the run.  If provided
                     <parameter>remark</parameter> is a text string that
                     is logged along with the transition.  The return value of
                     this method is the run being operated on, this supports
                     Chaining like
                   </para>
                   <informalexample>
                   <programlisting>
print(run.end('end run example').title + ' ended just now')
                   </programlisting>
                   </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBook.Run</type>
                     <methodname>pause</methodname>
                     <methodparam>
                        <modifier>optional</modifier>
                         <type>String</type><parameter>remark</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Pauses the run. If <parameter>remark</parameter>
                     is provided it is a text string that's loggeda long
                     with the pause transition. The return value is the
                     run itself to support chaining.  See the example in
                     <methodname>end</methodname>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBook.Run</type>
                     <methodname>resume</methodname>
                     <methodparam>
                        <modifier>optional</modifier>
                         <type>String</type><parameter>remark</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Logs a pause run with the optional <parameter>remark</parameter>
                     string. The return value is the run being resumed.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBook.Run</type>
                     <methodname>emergency_end</methodname>
                     <methodparam>
                        <modifier>optional</modifier>
                         <type>String</type><parameter>remark</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Logs an emergency end of run for the run with the optional
                     remark string <parameter>remark</parameter>.
                     The retrun value is the run operated on.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         
      </refsect2>
    </refsect1>
    <refsect1>
      <title>LogBook.Transition</title>
      <para>
         Transitions (<classname>LogBook.Transition</classname> objects)
         are fetched from a <classname>LogBook.Run</classname>
         object via the <methodname>get_transition</methodname> method.
         These have no methods but support the following read-only attributes:
      </para>
      <variablelist>
         <varlistentry>
            <term>
               <type>Integer</type> <structfield> id</structfield>
            </term>
            <listitem>
                <para>
                  Primary key of the transition
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>Integer</type><structfield> transition</structfield></term>
            <listitem>
                <para>
                  Integer code that defines the transition.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>String</type><structfield> transition_name</structfield></term>
            <listitem>
                <para>
                  Human readable string that defines the transition.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>int</type><structfield> time</structfield></term>
            <listitem>
                <para>
                  Timestamp that can be passed to e.g.
                  <methodname>datetime.fromtimestamp</methodname>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>String</type><structfield> comment</structfield></term>
            <listitem>
                <para>
                  Comment associated with the transition.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>LogBook.Shift</type><structfield> shift</structfield></term>
            <listitem>
                <para>
                  Returns a <classname>LogBook.Shift</classname> object
                  that wraps the shift that was on-duty at the time the
                  transition was logged.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<refentry id='py3.note'>
   <refmeta>
      <refentrytitle id='py3.note.title'>LogBook.Note</refentrytitle>
      <manvolnum>3python</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>LogBook.Note</refname>
      <refname>LogBook.Image</refname>
      <refpurpose>Encapsulate notes for python</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <synopsis>
PYTHONPATH=$DAQROOT/pythonLibs/nscldaq python3

import LogBook.LogBook as LogBook
...
book  = LogBook.LogBook(<replaceable>'logbookfile.log'</replaceable>)
note  = book.get_note(1)
image = note.get_image(0)
      </synopsis>
      <programlisting>

image_id    = image.id
note_id     = image.note_id
note_no     = image.index
offset      = image.offset
original_fn = image.original_file
exported_fn = image.exported_file

      </programlisting>
      <programlisting>

note_id     = note.id
note_run    = note.run
if note_run is None:
    print("Note has no associated run")
timestamp   = note.time
raw_text    = note.contents
author      = note.author
      
      </programlisting>
      <programlisting>

nimages  = note.image_count()
image    = note.get_image(index)
markdown = note.sustitute_images()

         
      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            <classname>LogBook.Note</classname> encapsulates a single
            logbook note.  Related to this class is
            <classname>LogBook.Image</classname> which encapsulates
            a single image.  Images can be fetched from a note object
            using <methodname>get_image</methodname>.
          </para>
          <para>
            Notes are stored in the logbook along with their associated images.
            The note text is assumed to be in Markdown format.  Image links,
            however point to image files that may or may not still be in the
            filesystem.  These images, however, have been pulled into the logbook
            database.  They can be exported back out into the filesystem and
            the raw note text image references fixed up to point to these exported
            images using <methodname>substitute_images</methodname>.
            Therefore the way to render a note is to first invoke
            substitute_image on the note to get usable Markdown from the note
            and then append or prepend any markdown headers or trailers desired
            (for example, <command>lg_browse</command> and
            <command>lg_print</command> prepend a table of note metadata), and
            then pass the resulting text to a mardown processor, such as
            <literal>Python-Markdown</literal>
            (<ulink url='https://python-markdown.github.io' />) for html output
            or <command>pandoc</command> for other output formats such
            as e.g. PDF.   NSCL Container images include pandoc
            (<ulink url='https://pandoc.org' /> -- packages exist as well for
            most Linux variants).
          </para>
          <para>
            The remaining sections  of this reference page will first
            document the attributes and methods of
            <classname>LogBook.Note</classname> and then the attributes
            of <classname>LogBook.Image</classname>, instances of which can
            be produced by note instances.
          </para>
    </refsect1>
    <refsect1>
      <title>LogBook.Note</title>
      <para>
         <classname>LogBook.Note</classname> objects encapsulate a single note
         from the logbook database.  In general they are not constructed
         directly but obtaind from method calls to
         <classname>LogBook.LogBook</classname> instances.  See:
         <link linkend='py3.logbook' endterm='py3.logbook.title' />
      </para>
      <refsect2>
         <title>Attributes</title>
         <para>
            <classname>LogBook.Note</classname> objects have several read-only
            attributes:
         </para>
         <variablelist>
            <varlistentry>
               <term><type>Integer</type><structfield> id</structfield></term>
               <listitem>
                   <para>
                     Returns the primary key of the note.  This is a unique
                     integer that identifies the note.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>LogBook.Run</type><structfield> run</structfield></term>
               <listitem>
                   <para>
                     If the note is associated with a run, this attribute will
                     provide a <classname>LogBook.Run</classname> object
                     encapsulating that run.  <classname>LogBook.Run</classname>
                     objects are described in
                     <link linkend='py3.run' endterm='py3.run.title' />.
                   </para>
                   <para>
                     If there is no run associated with this note, the value of
                     this attribute is
                     <literal>None</literal>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>Long</type><structfield> time</structfield></term>
               <listitem>
                   <para>
                     Returns the time the note was added to the logbook in
                     a form usable as input to
                     <methodname>datetime.fromtimestamp</methodname>.
                     The time provided is not the time at which note authoring
                     began,  authoring can take a macroscopic amount of time,
                     but the time at which the note was added to the logbook database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>String</type><structfield> contents</structfield></term>
               <listitem>
                   <para>
                     Accesses the raw text of the note.  Unless the note has no
                     associated images, this is not suitable for rendering as
                     it will contain possibly broken image references.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><type>LogBook.Person</type><structfield> author</structfield></term>
               <listitem>
                   <para>
                     Returns a <classname>LogBook.Person</classname> that
                     wraps the author of the note.
                     <classname>LogBook.Person</classname> is described in
                     <link linkend='py3.person' endterm='py3.person.title' />
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
      <refsect2>
         <title>METHODS</title>
         <para>
            <classname>LogBook.Note</classname> defines the following methods:
         </para>
         <variablelist>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>Integer</type>
                     <methodname>image_count</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the number of images that are referenced by the
                     note.  
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>LogBook.Image</type>
                     <methodname>get_image</methodname>
                     <methodparam>
                         <type>Integer</type><parameter>index</parameter>
                     </methodparam>
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     Returns the <parameter>index</parameter>'th image
                     associated with the note as a
                     <classname>LogBook.Image</classname> object.
                     If <parameter>index</parameter> is out of range,
                     a <classname>LogBook.error</classname> exception
                     is raised.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodsynopsis>
                     <type>String</type>
                     <methodname>substitute_images</methodname>
                     <void />
                  </methodsynopsis>
               </term>
               <listitem>
                   <para>
                     This method generates usable markdown from the raw note text
                     and
                     referenced images.  It does so by exporting referenced images to the
                     filesystem and fixing up the markdown links to them
                     to point at the exported images.  The return value of this
                     method is the fixed markdown text.  This text is suitable
                     to be rendered by a markdown processor.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
    </refsect1>
    <refsect1>
      <title>LogBook.Image</title>
      <para>
         This class encapsulates a single image.  It is not
         generally constructed directly but via a call to a <classname>LogBook.Note</classname>
         object's <methodname>get_image</methodname> method.
         <classname>LogBook.Image</classname> objects have several
         read-only attributes:
      </para>
      <variablelist>
         <varlistentry>
            <term>
               <type>Integer</type><structfield> id</structfield>
            </term>
            <listitem>
                <para>
                  Provides the primary key of the image.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <type>Integer</type><structfield> note_id</structfield>
            </term>
            <listitem>
                <para>
                  Provides the primary key of the note this image is
                  used in.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <type>Integer</type><structfield> index</structfield>
            </term>
            <listitem>
                <para>
                  Provides the note index within the note.  This is the
                  value that was passed to
                  a note's <methodname>get_image</methodname> method call.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <type>Integer</type><structfield> offset</structfield>
            </term>
            <listitem>
                <para>
                  The byte offset in the note text at which the
                  markdown link referencing this note begins.  This is the
                  index of that link's leading <literal>!</literal> character.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <type>String</type><structfield> orgininal_file</structfield>
            </term>
            <listitem>
                <para>
                  Provides the image's original file system path.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <type>String</type><structfield>exported_file</structfield>
            </term>
            <listitem>
                <para>
                  Provides the image's exported filesystem path.  The first
                  call of this method does the export. Note that this is
                  because all of the Python image processing packages
                  I peeked at operate on
                  files rather than bytes in memory.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      
    </refsect1>
    <refsect1>
      <title>FILES</title>
      <simplelist>
         <member><filename>~/.nscl-logbook</filename> - image export directory</member>
      </simplelist>
    </refsect1>
</refentry>
<!-- /manpage -->

<!-- manpage 5daq -->
<refentry id='daq5.logbookschema'>
   <refmeta>
      <refentrytitle id='daq5.logbookschema.title'>Logbook Schema</refentrytitle>
      <manvolnum>5daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>Logbook Schema</refname>
      <refpurpose>Describe schema of logbook databases.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
CREATE TABLE IF NOT EXISTS kvstore (           
    id   INTEGER PRIMARY KEY,                   
    key  TEXT,                                  
    value TEXT                                  
);    
CREATE TABLE IF NOT EXISTS person  (                
    id         INTEGER PRIMARY KEY,                  
    lastname   TEXT,                                  
    firstname  TEXT,                                  
    salutation TEXT                                  
);
CREATE TABLE IF NOT EXISTS shift (                 
    id    INTEGER PRIMARY KEY,                      
    name TEXT                                       
);
CREATE TABLE IF NOT EXISTS shift_members (        
      shift_id   INTEGER,                            
      person_id  INTEGER                             
);
CREATE TABLE IF NOT EXISTS current_shift (  
    shift_id  INTEGER                              
);
CREATE TABLE IF NOT EXISTS run (             
    id   INTEGER PRIMARY KEY,                 
    number INTEGER,                           
    title TEXT                                
);
CREATE TABLE IF NOT EXISTS run_transitions ( 
    id   INTEGER PRIMARY KEY,                  
    run_id INTEGER,                            
    transition_type INTEGER,                   
    time_stamp      INTEGER,                   
    shift_id        INTEGER,                   
    short_comment   TEXT                      
);
CREATE TABLE IF NOT EXISTS valid_transitions ( 
    id      INTEGER PRIMARY KEY,              
    type    TEXT                              
);
CREATE TABLE IF NOT EXISTS  valid_state_transitions (
    from_id   INTEGER,                                   
    to_id     INTEGER                                    
);
CREATE TABLE IF NOT EXISTS current_run (id INTEGER);
CREATE TABLE IF NOT EXISTS note (                 
   id INTEGER PRIMARY  KEY,                        
   run_id INTEGER,                                 
   author_id INTEGER NOT NULL,                     
   note_time INTEGER NOT NULL,                    
   note   TEXT NOT NULL                           
);
CREATE TABLE IF NOT EXISTS note_image (           
   id          INTEGER PRIMARY KEY,                
   note_id     INTEGER NOT NULL,                   
   note_offset INTEGER NOT NULL,                   
   original_filename TEXT NOT NULL,                
   image       BLOB NOT NULL                      
);
 
      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
         <para>
            If you are reading this and you are not either an NSCLDAQ programming/maintainer
            or formulating a where clause for one of the API functions that
            accepts one, you've come to the wrong place.  Instead you should
            be looking at the API or language bindings for Python or Tcl.
            If you program directly to the database, you may not get some
            of the business logic of the logbook correct.
         </para>
          <para>
            The synpopsis shows the Sqlite3 commands that create the
            logbook databas schema.  This manpage will describe the contents
            of the tables and how they interrelate.  The tables fall into the
            following broad categories of interrelated tables with some relationships
            carried across these categories:
          </para>
          <variablelist>
            <varlistentry>
               <term>Key value store</term>
               <listitem>
                   <para>
                     The <literal>kvstore</literal> table provides a generic
                     key value store.  This is initially stocked when the
                     database is created, however  the APIs in all languages
                     support manipulation of this store.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Personel</term>
               <listitem>
                   <para>
                     The <literal>person</literal>, <literal>shift</literal>
                     <literal>shift_members</literal> and <literal>current_shift</literal>
                     tables provide the twin concepts of people and shifts that
                     are collections of people that work together during data
                     taking.  
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Runs</term>
               <listitem>
                   <para>
                     The <literal>run</literal>, <literal>run_transitions</literal>,
                     <literal>valid_transitions</literal>,
                     <literal>valid_state_transitions</literal> and
                     <literal>current_run</literal> provide support for logging
                     segments of data taking commonly called runs.
                     This set of tables crosses over into the Personel set of
                     tables because each run state transition is documented
                     to have taken place during a shift.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Notes</term>
               <listitem>
                   <para>
                     The <literal>note</literal>, and
                     <literal>note_image</literal> tables provide support for
                     experimenters to log arbitrary rich text artifacts.
                     These artifacts cross over in to both Personel (notes
                     are written by an author who is a person on the experiment),
                     and optinoally Runs (notes can be associated with a run).
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          <para>
            All tables have an auto incrementing integer primary key called
            <structfield>id</structfield>.  By convention, foreign keys
            will have field names that end in <literal>_id</literal>.
          </para>
          <para>
            The remaining sections of this reference will describe the
            tables for each category.
          </para>
          
    </refsect1>
    <refsect1>
      <title>Key value store</title>
      <para>
         A key value store simply associates arbitrary text content (a
         value) with an arbitrary text name by which the value can be
         retrieved (key).  A single table, <literal>kvstore</literal>
         provides support for the key value store.  This has the follwing
         fields:
      </para>
      <variablelist>
         <varlistentry>
            <term><type>INTEGER</type><structfield> id</structfield></term>
            <listitem>
                <para>
                  Primary key.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>TEXT</type><structfield> key</structfield></term>
            <listitem>
                <para>
                  The retrieval key.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>TEXT</type><structfield> value</structfield></term>
            <listitem>
                <para>
                  The value associated with the key.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         When a logbook database is created, several key/value pairs are
         stored:
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>experiment</literal></term>
            <listitem>
                <para>
                  The experiment id the log book is for.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>spokesperson</literal></term>
            <listitem>
                <para>
                  The free text name of the spokesperson. Note that the
                  presence of this key does not imply the spokesperson is a
                  a logbook person in the Personel sense.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>purpose</literal></term>
            <listitem>
                <para>
                  A brief statement of the purpose of the experiment.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>version</literal></term>
            <listitem>
                <para>
                  The database version.  Currently this has the value
                  <literal>1.0</literal>. 
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>Personel</title>
      <para>
         This subset of data base tables provides definitions of the people
         that are working on the experiment (<literal>person</literal> table),
         groups of people that are on-duty concurrently during data taking
         (<literal>shift</literal> and <literal>shift_members</literal> tables).
         In addition while the experiment is running ther is a concept of a
         <literal>current_shift</literal>.  This indicates the shift that is
         on-duty currently.  The <literal>current_shift</literal> table is used
         by the API to determine which shift a run state transition should be
         linked to.
      </para>
      <para>
         Here are the fields in each of these tables:
      </para>
      <variablelist>
         <title>person Table</title>
         <varlistentry>
            <term><type>INTEGER</type><structfield> id</structfield></term>
            <listitem>
                <para>
                  Primary key.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>TEXT</type><structfield> lastname</structfield></term>
            <listitem>
                <para>
                  Surname of the person in a record of the table.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>TEXT</type><structfield> firstname</structfield></term>
            <listitem>
                <para>
                  Given name of the person in a record of the table.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>TEXT</type><structfield>salutation</structfield></term>
            <listitem>
                <para>
                  Salutation by which a person is known (e.g. <literal>Mr.</literal>,
                  <literal>Ms.</literal> or <literal>Prof.</literal>).
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <variablelist>
         <title>shift Table</title>
         <varlistentry>
            <term><type>INTEGER</type><structfield> id</structfield></term>
            <listitem>
                <para>
                  Primary key.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>TEXT</type><structfield> name</structfield></term>
            <listitem>
                <para>
                  Name of the shift.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         The <literal>shift_members</literal> table is what is called a
         <firstterm>join table</firstterm>.  It's purpose is to join records in
         the <literal>person</literal> table and records in the <literal>shift</literal>
         table in a many to many relationship.  That is a person can be in many shifts
         and a shift can have many members.  This table has no primary key,
         just two foreign keys:
      </para>
      <variablelist>
         <title>shift_members Join Table</title>
         <varlistentry>
            <term><type>INTEGER</type><structfield> shift_id</structfield></term>
            <listitem>
                <para>
                  Primary key of a shift.  This entry will describe
                  a member of that shift.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>INTEGER</type><structfield> person_id</structfield></term>
            <listitem>
                <para>
                  Primary key of a person.  The person that has that primary
                  key is a member of the shift with the primary key
                  <structfield>shift_id</structfield>.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         Finally, the <literal>current_shift</literal> table only ever has zero
         or one entry.  It has a single field
         <type>INTEGER</type><structfield> shift_id</structfield>.  If there
         is an entry, the value of this field is the primary key of a shift.
         That shift is considered to be the current, or on-duty shift.
      </para>
    </refsect1>
    <refsect1>
      <title>Runs</title>
      <para>
         Runs are a segment of data taking.  Runs have information that
         describes them and state transitions.  State transitions are associated
         with a shift.  Futhermore, as we will see, Runs can have notes
         associated with them.
      </para>
      <para>
         The database tables in this section are a bit involved.
         <literal>run</literal> and <literal>run_transitions</literal>
         provide tables to record each run and its sequence of transitions.
         The <literal>valid_transitions</literal> table provides textual names
         to go along with each transition type and <literal>valid_state_transitions</literal>
         provides the directed graph of valid transitions for each state
         (the result of a transition).  Finally, when a run is active (it has
         been started but not yet ended), <literal>current_run</literal>
         indicates this. 
      </para>
      <para>
         Under normal circumstances, a run is created and has an initial
         <literal>BEGIN</literal> transition indicating it has started.
         There may be other transitions but its final transition, if all goes
         well is an <literal>END</literal> transition indicating the run ended
         normally.  Data acquisition system failures can prevent a good
         <literal>END</literal> from being logged for the current run.
         A transition called <literal>EMERGENCY_END</literal> is, therefore
         defined that operates identically to <literal>END</literal> but indicates
         the run ended improperly.
      </para>
      <para>
         Here are the fields for each of the tables in this section of the
         database:
      </para>
      <variablelist>
         <title>run Table</title>
         <varlistentry>
            <term><type>INTEGER</type><structfield> id</structfield></term>
            <listitem>
                <para>
                  Primary key.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>INTEGER</type><structfield> number</structfield></term>
            <listitem>
                <para>
                  This is a unique number for he run assigned by the experimenters
                  as opposed to <structfield>id</structfield> which is assigned
                  by the database itself.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>TEXT</type><structfield> title</structfield></term>
            <listitem>
                <para>
                  The title of the run.  Again assigned by the experimenters.
                  This is just some text that describes the run.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <variablelist>
         <title>run_transitions Table</title>
         <varlistentry>
            <term><type>INTEGER</type><structfield> id</structfield></term>
            <listitem>
                <para>
                  Primary key.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>INTEGER</type><structfield> run_id</structfield></term>
            <listitem>
                <para>
                  Primary key of the entry in <literal>run</literal>
                  that describes the run for which this is a transition.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>INTEGER</type><structfield> transition_type</structfield></term>
            <listitem>
                <para>
                  Primary key in the <literal>valid_transitions</literal>
                  table that indicates the state transition this transition logs.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>INTEGER</type><structfield> time_stamp</structfield></term>
            <listitem>
                <para>
                  The  <literal>time_t</literal> at which the run transition
                  was logged.  This is gotten from <literal>time(2)</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>INTEGER</type><structfield> shift_id</structfield></term>
            <listitem>
                <para>
                  Primary key of an entry in the <literal>shift</literal>
                  table that indicates which shift was on-duty when the
                  transition was logged.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>TEXT</type><structfield> short_comment</structfield></term>
            <listitem>
                <para>
                  Short textual comment that is associated with the transition.
                  The API often refers to this as a <firstterm>remark</firstterm>.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         The <literal>valid_transitions</literal> table provides a correspondence
         between the numeric transitions in <literal>transition.transition_type</literal>
         and a human readable transition name.  In addition to the 
         <type>INTEGER</type><structfield> id</structfield> primary key referenced
         by <literal>transition.transition_type</literal>, this table has
         a <type>TEXT</type><structfield> type</structfield> field.  When
         the database is created/initialized this table is stocked with the
         following values:
         
      </para>
      <table id='daq5.logbookrun.trantbl'>
         <title id='daq5.logbookrun.trantbl.title'>State transition values</title>
         <tgroup cols='3'>
            <thead>
               <row>
                  <entry>s_transition value</entry>
                  <entry>s_transitionName value</entry>
                  <entry>Transition type</entry>
               </row>
            </thead>
            <tbody>
               <row>
                  <entry>1</entry><entry>BEGIN</entry>
                  <entry>Begin run. This is always the first transition</entry>
               </row>
               <row>
                  <entry>2</entry><entry>END</entry>
                  <entry>
                     End of run.  This or <literal>EMERGENCY_END</literal>
                     are always the last transition.
                  </entry>
               </row>
               <row>
                  <entry>3</entry><entry>PAUSE</entry>
                  <entry>
                     Pause run. Data taking is temporarly paused.
                  </entry>
               </row>
               <row>
                  <entry>4</entry><entry>RESUME</entry>
                  <entry>
                     Resume run. Indicates a paused run has resumed taking
                     data.
                  </entry>
               </row>
               <row>
                  <entry>5</entry><entry>EMERGENCY_END</entry>
                  <entry>Abnormal end of run.</entry>
               </row>
            </tbody>
         </tgroup>
      </table>
      <para>
         Finally, not all transitions are legal.
         The <literal>valid_state_transitions</literal> table joins
         entries in <literal>valid_transitions</literal> to the entries
         the are valid next transitions. It contains:
         <type>INTEGER</type><structfield> from_id</structfield>, the
         prior transition and <type>INTEGER</type><structfield> to_id</structfield>,
         a legal next transition.  This table is also stocked at
         database initialization time as follows:
      </para>
      <table>
         <title>valid_state_transitions table contents</title>
         <tgroup cols='3'>
            <thead>
               <row>
                  <entry><literal>from_id</literal></entry>
                  <entry><literal>to_id</literal></entry>
                  <entry>Meaning.</entry>
               </row>
            </thead>
            <tbody>
               <row>
                  <entry>1</entry>
                  <entry>2</entry>
                  <entry>BEGIN -&gt; END</entry>
               </row>
               <row>
                  <entry>1</entry>
                  <entry>3</entry>
                  <entry>BEGIN -&gt; PAUSE</entry>
               </row>
               <row>
                  <entry>1</entry>
                  <entry>5</entry>
                  <entry>BEGIN -&gt; EMERGENCY_END</entry>
               </row>
               <row>
                  <entry>3</entry>
                  <entry>4</entry>
                  <entry>PAUSE -&gt; RESUME</entry>
               </row>
               <row>
                  <entry>3</entry>
                  <entry>2</entry>
                  <entry>PAUSE -gt; END</entry>
               </row>
               <row>
                  <entry>3</entry>
                  <entry>5</entry>
                  <entry>PAUSE -gt; EMERGENCY_END</entry>
               </row>
            </tbody>
         </tgroup>
      </table>
      <para>
         Finally, <literal>current_run</literal> has zero or 1 entries.
         If there is a run that has been begun but not ended
         (either through <literal>END</literal> or <literal>EMERGENCY_END</literal>)
         this table's <literal>id</literal> field will contain the primary key
         of an entry in <literal>run.id</literal>, which is the active run.
      </para>
    </refsect1>
    <refsect1>
      <title>Note tables</title>
      <para>
         Notes are items containing arbitrary rich text.  The text is formatted
         using the <literal>Markdown</literal> formatting language.
         Markdown supports references to images that are in the filesystem.
         The notes themselves are in the <literal>note</literal> table.  The
         <literal>note_image</literal> table will store data in image files
         that are referenced by notes.
      </para>
      <para>
         Rendering a note requires transforming
         the text stored in the database or <firstterm>raw text</firstterm> by
         first exporting the image files it references back out into the
         file system and then fixing up references to images in the original
         raw text to properly reference the exported images.  API calls support
         doing that.
      </para>
      <para>
         Here are the table contents for the tables in this section of the
         database.
      </para>
      <variablelist>
         <title>note Table contents</title>
         <varlistentry>
            <term><type>INTEGER</type><structfield> id</structfield></term>
            <listitem>
                <para>
                  Primary key.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>INTEGER</type><structfield> run_id</structfield></term>
            <listitem>
                <para>
                  If not null, this is the primary key in the
                  <literal>run</literal> table of the run this note is
                  associated with.  If this is null, no run associated
                  with this note.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>INTEGER</type><structfield> author_id</structfield></term>
            <listitem>
                <para>
                  Primary key of an entry in ther <literal>person</literal>
                  table that designates the author of this note.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>INTEGER</type><structfield> note_time</structfield></term>
            <listitem>
                <para>
                  time(2) value of when the note was entered in the database
                  by the API.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>TEXT</type><structfield> note</structfield></term>
            <listitem>
                <para>
                  Raw text of the note.  See the discussion at the beginning
                  of this section about needing to transform this text
                  before it can be rendered.  There are API calls to do that.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         Here are the fields in the <literal>note_image</literal> table, which
         contains images that were referenced by the note.
      </para>
      <variablelist>
         <title>note_image table fields.</title>
         <varlistentry>
            <term><type>INTEGER</type><structfield> id</structfield></term>
            <listitem>
                <para>
                  Primary key of the image entry
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>INTEGER</type><structfield> note_id</structfield></term>
            <listitem>
                <para>
                  Primary key of the note in the <literal>note</literal> table
                  which references this image.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>INTEGER</type><structfield> note_offset</structfield></term>
            <listitem>
                <para>
                  Byte offset into the note raw text at which the image
                  link to this image begins.  Markdown image links look like
                  <literal>![some text](/the/file/name)</literal>.  The
                  value is the offset to the <literal>!</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <type>TEXT</type><structfield> original_filename</structfield>
            </term>
            <listitem>
                <para>
                  This is the name of the file prior to it having been loaded
                   into this table.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><type>BLOB</type><structfield>image</structfield></term>
            <listitem>
                <para>
                  This is the raw contents of the image.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<!-- /manpage  -->

